!SESSION 2024-04-12 16:58:34.943 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.20
java.vendor=Microsoft
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

This is a continuation of log file C:\Users\Giannis\Desktop\DS\.metadata\.bak_0.log
Created Time: 2024-04-12 17:23:27.575

!ENTRY org.eclipse.jdt.ui 4 2 2024-04-12 17:23:27.576
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2024-04-12 17:23:27.577
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-12 17:23:27.597
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.UnknownHostException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.imageio.ImageIO;

public class Master {
	
	private int propertyCounter;
    private List<Worker> workers;
    private Socket clientSocket;
    private ArrayList<Socket> workerSockets;
    private ArrayList<ObjectInputStream> workerInputStreams;
    private ArrayList<ObjectOutputStream> workerOutputStreams;
    
    public Master(int[] workerPorts) {
    	Socket sock=null;
    	this.propertyCounter=0;
        this.workers = new ArrayList<>();
        workerSockets=new ArrayList<>();
        workerInputStreams = new ArrayList<>();
        workerOutputStreams = new ArrayList<>();
        
        for (int port : workerPorts) {
            Worker worker = new Worker(port); // Pass the port number to the Worker constructor
			worker.start(); // Start the worker thread
			workers.add(worker);
			System.out.println("Worker connected on port: " + port);
			try {
				sock=new Socket("localhost", port);
				workerInputStreams.add(new ObjectInputStream(sock.getInputStream()));
				workerOutputStreams.add(new ObjectOutputStream(sock.getOutputStream()));
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			workerSockets.add(sock);
			
        }
        
    }


    public void start() throws IOException, ParseException, ClassNotFoundException{
//        for (Worker worker : workers) {
//            worker.start();
//        }
        // Start listening for client requests
        try (ServerSocket serverSocket = new ServerSocket(5000)) {
            System.out.println("Master server started...");
            while (true) {
                clientSocket = serverSocket.accept();
                System.out.println("A");
                handleClientRequest(clientSocket);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void handleClientRequest(Socket clientSocket) throws IOException, ParseException, ClassNotFoundException {
    	
    	String managerUsername;
    	String renterUsername;
    	String propertyName;
    	Integer stars;
    	String area;
    	DateRange dateRange;
    	Integer people;
    	Integer price;
    	
    	 try (ObjectInputStream objectInputStream = new ObjectInputStream(clientSocket.getInputStream());
    			 ObjectOutputStream objectOutputStream = new ObjectOutputStream(clientSocket.getOutputStream());
    	        ) {
    		 
    		 while (true) {
    			 System.out.println("Awaiting action command from user");
	    	     String action = (String) objectInputStream.readObject();
	//            String[] tokens = request.split(":");
	//            String action = tokens[0];
	//            String propertyId = tokens[1];
	            switch (action) {
	                case "ADD":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	readPropertyFromStream(objectInputStream);
	                    break;
	                case "SHOW":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	managerUsername = (String) objectInputStream.readObject();
	                	System.out.println("Action at worker:"+action);
	                	System.out.println(managerUsername);
	                	objectOutputStream.writeObject(showManagerProperties(managerUsername));
	                    break;
	                case "AVAILABILITY":
	                	readAvailabilityFromStream(objectInputStream);
	                    break;
	                case "BOOKINGS":
	                	managerUsername = (String) objectInputStream.readObject();
	                	showManagerBookings(managerUsername);
	                    break;
	                case "BOOK":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	DateRange bookingRange = readDateRangeFromStream(objectInputStream);
	                    forwardPropertyBooking(renterUsername, propertyName, bookingRange);
	                    break;
	                case "RATE":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                    forwardPropertyRating(renterUsername, propertyName, stars);
	                    break;
	                case "FILTER":
	                	area = (String) objectInputStream.readObject();
	                	dateRange=readDateRangeFromStream(objectInputStream);
	                	people = (Integer) objectInputStream.readObject();
	                	price = (Integer) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                	forwardPropertyFiltering(area, dateRange, people, price, stars);
	                    break;
	                // Implement cases for other request types (UPDATE, etc.) as needed
	                default:
	                    // Unknown action, send error response
	                    break;
	               }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void readPropertyFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyInfo = (String) objectInputStream.readObject();

        // Read property info
        String[] keyValuePairs = propertyInfo.substring(1, propertyInfo.length() - 1).split(",");

        String roomName = "";
        int noOfPersons = 0;
        String area = "";
        int stars = 0;
        int noOfReviews = 0;
        String roomImage = "";

        // Iterate over key-value pairs and split them based on colons
        for (String pair : keyValuePairs) {
            System.out.println(pair);
            String[] keyValue = pair.split(":");
            String key = keyValue[0].trim().replaceAll("\"", "");
            String value = keyValue[1].trim().replaceAll("\"", ""); // Remove quotes

            // Assign values to appropriate variables based on keys
            switch (key) {
                case "roomName":
                    roomName = value;
                    break;
                case "noOfPersons":
                    noOfPersons = Integer.parseInt(value);
                    break;
                case "area":
                    area = value;
                    break;
                case "stars":
                    stars = Integer.parseInt(value);
                    break;
                case "noOfReviews":
                    noOfReviews = Integer.parseInt(value);
                    break;
                case "roomImage":
                    roomImage = value;
                    break;
            }
        }
        
     // Print the values to verify
        System.out.println("Room Name: " + roomName);
        System.out.println("Number of Persons: " + noOfPersons);
        System.out.println("Area: " + area);
        System.out.println("Stars: " + stars);
        System.out.println("Number of Reviews: " + noOfReviews);
        System.out.println("Room Image: " + roomImage);

        // Read image data
        byte[] imageData = (byte[]) objectInputStream.readObject();

        // Convert byte array to BufferedImage
        ByteArrayInputStream bis = new ByteArrayInputStream(imageData);
//        BufferedImage bufferedImage = ImageIO.read(bis);
        
        forwardPropertyAddition(roomName, managerUsername ,new Property(roomName, noOfPersons, area, stars, noOfReviews, roomImage,propertyCounter++), imageData);

        // Return property object with image
    }
    
    private void readAvailabilityFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyName = (String) objectInputStream.readObject();
        
        String dateRangeAvailability = (String) objectInputStream.readObject();
        
        forwardPropertyAvailability(managerUsername, propertyName,dateRangeAvailability);

        // Return property object with image
    }

    private Map<String, Object> readFiltersFromStream(BufferedReader reader) throws IOException {
        Map<String, Object> filters = new HashMap<>();
        
        String line;
        while ((line = reader.readLine()) != null) {
            String[] tokens = line.split(":");
            String filterName = tokens[0];
            Object filterValue = tokens[1]; // Assuming filter value is string for simplicity, you may need to parse it accordingly
            filters.put(filterName, filterValue);
        }
        
        return filters;
    }

    private DateRange readDateRangeFromStream(ObjectInputStream objectInputStream) throws IOException, ParseException, ClassNotFoundException {
    	String startDateStr = (String) objectInputStream.readObject();
        String endDateStr = (String) objectInputStream.readObject();
        // Assuming date format is in "day/month/year"
        SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
        Date startDate = dateFormat.parse(startDateStr);
        Date endDate = dateFormat.parse(endDateStr);
        return new DateRange(startDate, endDate);
    }

    private void forwardPropertyAddition(String propertyName, String managerUsername,Property property, byte [] imageBytes) throws IOException {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new property...");

       String add = "ADD";
       objectOutputStream.writeObject(add);
       System.out.println("ADD SENT");
       objectOutputStream.writeObject(managerUsername);
       objectOutputStream.writeObject(property);
       objectOutputStream.writeObject(imageBytes);

          
    }
    
    private void forwardPropertyAvailability(String managerUsername,String propertyName,String dateRangeAvailability) {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        try (
                BufferedReader consoleReader = new BufferedReader(new InputStreamReader(System.in));
                ObjectOutputStream objectOutputStream = new ObjectOutputStream(workerSockets.get(workerIndex).getOutputStream());
                BufferedReader reader = new BufferedReader(new InputStreamReader(workerSockets.get(workerIndex).getInputStream()))) {

               System.out.println("Established connection with worker on port:"+ port);
               System.out.println("Adding new availability...");

               String availability = "AVAILABILITY";
               objectOutputStream.writeObject(availability);
               objectOutputStream.writeObject(managerUsername);
               objectOutputStream.writeObject(propertyName);
               objectOutputStream.writeObject(dateRangeAvailability);

           } catch (IOException e) {
               e.printStackTrace();
           }
    }

    private String showManagerProperties(String managerUsername) {
    	
    	ArrayList<Property> mergedProperties = new ArrayList<>();
        
    	// Iterate over worker ports
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
    	    ObjectInputStream objectInputStream = workerInputStreams.get(i);

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("SHOW");
    	        objectOutputStream.writeObject(managerUsername);
    	        System.out.println("talked to worker");
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> workerProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedProperties.addAll(workerProperties);

    	        System.out.println("Received properties from worker on port: " + port);
    	        
    	        
    	        
    	    } catch (IOException | ClassNotFoundException e) {
    	        e.printStackTrace();
    	    }
    	}
    	
    	return String.valueOf(mergedProperties.size());
    	
    }
    	
    	private void showManagerBookings(String managerUsername) {
        	
    		Map<String,List<DateRange>> mergedPropertyNamesBookings= new HashMap<>();
            
        	// Iterate over worker ports
        	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
        	    int port = 5000 + i; // Calculate port number

        	    try (
        	            ObjectOutputStream objectOutputStream = new ObjectOutputStream(workerSockets.get(i).getOutputStream());
        	            ObjectInputStream objectInputStream = new ObjectInputStream(workerSockets.get(i).getInputStream())) {

        	        // Send "SHOW" request to worker
        	        objectOutputStream.writeObject("BOOKINGS");
        	        objectOutputStream.writeObject(managerUsername);
        	        
        	        // Receive ArrayList<Property> response from worker
        	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
        	        Map<String,List<DateRange>> propertyNamesBookings = (Map<String,List<DateRange>>) objectInputStream.readObject();
        	        
                    for (Map.Entry<String, List<DateRange>> entry : propertyNamesBookings.entrySet()) {
                        String propertyName = entry.getKey();
                        List<DateRange> bookings = entry.getValue();
                        
                        if (mergedPropertyNamesBookings.containsKey(propertyName)) {
                            // If the property already exists in the merged map, merge its bookings
                            mergedPropertyNamesBookings.get(propertyName).addAll(bookings);
                        } else {
                            // If the property doesn't exist in the merged map, add it with its bookings
                            mergedPropertyNamesBookings.put(propertyName, new ArrayList<>(bookings));
                        }
                    }

                    System.out.println("Received property bookings from worker on port: " + port);
        	        
        	        
        	    } catch (IOException | ClassNotFoundException e) {
        	        e.printStackTrace();
        	    }
        	}
    	
    	try (PrintWriter writer = new PrintWriter(clientSocket.getOutputStream(), true)) {
            // Send the string to the client
            writer.println("These are your properties:");
            System.out.println("Sent merged properties to the client");
        } catch (IOException e) {
            e.printStackTrace();
        }
    	
    }

    private void forwardPropertySearch(String propertyId, Map<String, Object> filters) {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyId.hashCode()) % workers.size();
        Worker worker = workers.get(workerIndex);

        // Search for properties on the chosen worker
        List<Property> searchResults = worker.searchProperties(filters);

        // Print search results to the console
        System.out.println("Search results for property ID " + propertyId + ":");
        for (Property property : searchResults) {
            System.out.println(property.toString()); // Assuming Property class overrides toString() method
        }
    }


    private void forwardPropertyBooking(String renterUsername, String propertyName, DateRange bookingRange) {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        try (
                BufferedReader consoleReader = new BufferedReader(new InputStreamReader(System.in));
                ObjectOutputStream objectOutputStream = new ObjectOutputStream(workerSockets.get(workerIndex).getOutputStream());
                BufferedReader reader = new BufferedReader(new InputStreamReader(workerSockets.get(workerIndex).getInputStream()))) {

               System.out.println("Established connection with worker on port:"+ port);
               System.out.println("Adding new booking...");

               String book = "BOOK";
               objectOutputStream.writeObject(book);
               objectOutputStream.writeObject(renterUsername);
               objectOutputStream.writeObject(propertyName);
               objectOutputStream.writeObject(bookingRange);

           } catch (IOException e) {
               e.printStackTrace();
           }
    }
    
    private void forwardPropertyRating(String renterUsername, String propertyName, Integer stars) {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        try (
                BufferedReader consoleReader = new BufferedReader(new InputStreamReader(System.in));
                ObjectOutputStream objectOutputStream = new ObjectOutputStream(workerSockets.get(workerIndex).getOutputStream());
                BufferedReader reader = new BufferedReader(new InputStreamReader(workerSockets.get(workerIndex).getInputStream()))) {

               System.out.println("Established connection with worker on port:"+ port);
               System.out.println("Adding new rating...");

               String rate = "RATE";
               objectOutputStream.writeObject(rate);
               objectOutputStream.writeObject(renterUsername);
               objectOutputStream.writeObject(propertyName);
               objectOutputStream.writeObject(stars);

           } catch (IOException e) {
               e.printStackTrace();
           }
    }
    
    private void forwardPropertyFiltering(String area, DateRange dateRange, Integer people, Integer price, Integer stars) {
    	
    	ArrayList<Property> mergedFilteredProperties= new ArrayList<Property>();
    	
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    try (
    	            ObjectOutputStream objectOutputStream = new ObjectOutputStream(workerSockets.get(i).getOutputStream());
    	            ObjectInputStream objectInputStream = new ObjectInputStream(workerSockets.get(i).getInputStream())) {

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("FILTER");
    	        objectOutputStream.writeObject(area);
    	        objectOutputStream.writeObject(dateRange);
    	        objectOutputStream.writeObject(people);
    	        objectOutputStream.writeObject(price);
    	        objectOutputStream.writeObject(stars);
    	        
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> filteredProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedFilteredProperties.addAll(filteredProperties);

    	        System.out.println("Received filtered properties from worker on port: " + port);
    	        
    	        
    	    } catch (IOException | ClassNotFoundException e) {
    	        e.printStackTrace();
    	    }
    	}
    }
    
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-04-12 17:23:27.598
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-04-12 17:23:27.599
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-12 17:23:30.596
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.UnknownHostException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.imageio.ImageIO;

public class Master {
	
	private int propertyCounter;
    private List<Worker> workers;
    private Socket clientSocket;
    private ArrayList<Socket> workerSockets;
    private ArrayList<ObjectInputStream> workerInputStreams;
    private ArrayList<ObjectOutputStream> workerOutputStreams;
    
    public Master(int[] workerPorts) {
    	Socket sock=null;
    	this.propertyCounter=0;
        this.workers = new ArrayList<>();
        workerSockets=new ArrayList<>();
        workerInputStreams = new ArrayList<>();
        workerOutputStreams = new ArrayList<>();
        
        for (int port : workerPorts) {
            Worker worker = new Worker(port); // Pass the port number to the Worker constructor
			worker.start(); // Start the worker thread
			workers.add(worker);
			System.out.println("Worker connected on port: " + port);
			try {
				sock=new Socket("localhost", port);
				workerInputStreams.add(new ObjectInputStream(sock.getInputStream()));
				workerOutputStreams.add(new ObjectOutputStream(sock.getOutputStream()));
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			workerSockets.add(sock);
			
        }
        
    }


    public void start() throws IOException, ParseException, ClassNotFoundException{
//        for (Worker worker : workers) {
//            worker.start();
//        }
        // Start listening for client requests
        try (ServerSocket serverSocket = new ServerSocket(5000)) {
            System.out.println("Master server started...");
            while (true) {
                clientSocket = serverSocket.accept();
                System.out.println("A");
                handleClientRequest(clientSocket);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void handleClientRequest(Socket clientSocket) throws IOException, ParseException, ClassNotFoundException {
    	
    	String managerUsername;
    	String renterUsername;
    	String propertyName;
    	Integer stars;
    	String area;
    	DateRange dateRange;
    	Integer people;
    	Integer price;
    	
    	 try (ObjectInputStream objectInputStream = new ObjectInputStream(clientSocket.getInputStream());
    			 ObjectOutputStream objectOutputStream = new ObjectOutputStream(clientSocket.getOutputStream());
    	        ) {
    		 
    		 while (true) {
    			 System.out.println("Awaiting action command from user");
	    	     String action = (String) objectInputStream.readObject();
	//            String[] tokens = request.split(":");
	//            String action = tokens[0];
	//            String propertyId = tokens[1];
	            switch (action) {
	                case "ADD":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	readPropertyFromStream(objectInputStream);
	                    break;
	                case "SHOW":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	managerUsername = (String) objectInputStream.readObject();
	                	System.out.println("Action at worker:"+action);
	                	System.out.println(managerUsername);
	                	objectOutputStream.writeObject(showManagerProperties(managerUsername));
	                    break;
	                case "AVAILABILITY":
	                	readAvailabilityFromStream(objectInputStream);
	                    break;
	                case "BOOKINGS":
	                	managerUsername = (String) objectInputStream.readObject();
	                	showManagerBookings(managerUsername);
	                    break;
	                case "BOOK":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	DateRange bookingRange = readDateRangeFromStream(objectInputStream);
	                    forwardPropertyBooking(renterUsername, propertyName, bookingRange);
	                    break;
	                case "RATE":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                    forwardPropertyRating(renterUsername, propertyName, stars);
	                    break;
	                case "FILTER":
	                	area = (String) objectInputStream.readObject();
	                	dateRange=readDateRangeFromStream(objectInputStream);
	                	people = (Integer) objectInputStream.readObject();
	                	price = (Integer) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                	forwardPropertyFiltering(area, dateRange, people, price, stars);
	                    break;
	                // Implement cases for other request types (UPDATE, etc.) as needed
	                default:
	                    // Unknown action, send error response
	                    break;
	               }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void readPropertyFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyInfo = (String) objectInputStream.readObject();

        // Read property info
        String[] keyValuePairs = propertyInfo.substring(1, propertyInfo.length() - 1).split(",");

        String roomName = "";
        int noOfPersons = 0;
        String area = "";
        int stars = 0;
        int noOfReviews = 0;
        String roomImage = "";

        // Iterate over key-value pairs and split them based on colons
        for (String pair : keyValuePairs) {
            System.out.println(pair);
            String[] keyValue = pair.split(":");
            String key = keyValue[0].trim().replaceAll("\"", "");
            String value = keyValue[1].trim().replaceAll("\"", ""); // Remove quotes

            // Assign values to appropriate variables based on keys
            switch (key) {
                case "roomName":
                    roomName = value;
                    break;
                case "noOfPersons":
                    noOfPersons = Integer.parseInt(value);
                    break;
                case "area":
                    area = value;
                    break;
                case "stars":
                    stars = Integer.parseInt(value);
                    break;
                case "noOfReviews":
                    noOfReviews = Integer.parseInt(value);
                    break;
                case "roomImage":
                    roomImage = value;
                    break;
            }
        }
        
     // Print the values to verify
        System.out.println("Room Name: " + roomName);
        System.out.println("Number of Persons: " + noOfPersons);
        System.out.println("Area: " + area);
        System.out.println("Stars: " + stars);
        System.out.println("Number of Reviews: " + noOfReviews);
        System.out.println("Room Image: " + roomImage);

        // Read image data
        byte[] imageData = (byte[]) objectInputStream.readObject();

        // Convert byte array to BufferedImage
        ByteArrayInputStream bis = new ByteArrayInputStream(imageData);
//        BufferedImage bufferedImage = ImageIO.read(bis);
        
        forwardPropertyAddition(roomName, managerUsername ,new Property(roomName, noOfPersons, area, stars, noOfReviews, roomImage,propertyCounter++), imageData);

        // Return property object with image
    }
    
    private void readAvailabilityFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyName = (String) objectInputStream.readObject();
        
        String dateRangeAvailability = (String) objectInputStream.readObject();
        
        forwardPropertyAvailability(managerUsername, propertyName,dateRangeAvailability);

        // Return property object with image
    }

    private Map<String, Object> readFiltersFromStream(BufferedReader reader) throws IOException {
        Map<String, Object> filters = new HashMap<>();
        
        String line;
        while ((line = reader.readLine()) != null) {
            String[] tokens = line.split(":");
            String filterName = tokens[0];
            Object filterValue = tokens[1]; // Assuming filter value is string for simplicity, you may need to parse it accordingly
            filters.put(filterName, filterValue);
        }
        
        return filters;
    }

    private DateRange readDateRangeFromStream(ObjectInputStream objectInputStream) throws IOException, ParseException, ClassNotFoundException {
    	String startDateStr = (String) objectInputStream.readObject();
        String endDateStr = (String) objectInputStream.readObject();
        // Assuming date format is in "day/month/year"
        SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
        Date startDate = dateFormat.parse(startDateStr);
        Date endDate = dateFormat.parse(endDateStr);
        return new DateRange(startDate, endDate);
    }

    private void forwardPropertyAddition(String propertyName, String managerUsername,Property property, byte [] imageBytes) throws IOException {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new property...");

       String add = "ADD";
       objectOutputStream.writeObject(add);
       System.out.println("ADD SENT");
       objectOutputStream.writeObject(managerUsername);
       objectOutputStream.writeObject(property);
       objectOutputStream.writeObject(imageBytes);

          
    }
    
    private void forwardPropertyAvailability(String managerUsername,String propertyName,String dateRangeAvailability) {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        try (
                BufferedReader consoleReader = new BufferedReader(new InputStreamReader(System.in));
                ObjectOutputStream objectOutputStream = new ObjectOutputStream(workerSockets.get(workerIndex).getOutputStream());
                BufferedReader reader = new BufferedReader(new InputStreamReader(workerSockets.get(workerIndex).getInputStream()))) {

               System.out.println("Established connection with worker on port:"+ port);
               System.out.println("Adding new availability...");

               String availability = "AVAILABILITY";
               objectOutputStream.writeObject(availability);
               objectOutputStream.writeObject(managerUsername);
               objectOutputStream.writeObject(propertyName);
               objectOutputStream.writeObject(dateRangeAvailability);

           } catch (IOException e) {
               e.printStackTrace();
           }
    }

    private String showManagerProperties(String managerUsername) {
    	
    	ArrayList<Property> mergedProperties = new ArrayList<>();
        
    	// Iterate over worker ports
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
    	    ObjectInputStream objectInputStream = workerInputStreams.get(i);

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("SHOW");
    	        objectOutputStream.writeObject(managerUsername);
    	        System.out.println("talked to worker");
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> workerProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedProperties.addAll(workerProperties);

    	        System.out.println("Received properties from worker on port: " + port);
    	        
    	        
    	        
    	    } catch (IOException | ClassNotFoundException e) {
    	        e.printStackTrace();
    	    }
    	}
    	
    	return String.valueOf(mergedProperties.size());
    	
    }
    	
    	private void showManagerBookings(String managerUsername) {
        	
    		Map<String,List<DateRange>> mergedPropertyNamesBookings= new HashMap<>();
            
        	// Iterate over worker ports
        	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
        	    int port = 5000 + i; // Calculate port number

        	    try (
        	            ObjectOutputStream objectOutputStream = new ObjectOutputStream(workerSockets.get(i).getOutputStream());
        	            ObjectInputStream objectInputStream = new ObjectInputStream(workerSockets.get(i).getInputStream())) {

        	        // Send "SHOW" request to worker
        	        objectOutputStream.writeObject("BOOKINGS");
        	        objectOutputStream.writeObject(managerUsername);
        	        
        	        // Receive ArrayList<Property> response from worker
        	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
        	        Map<String,List<DateRange>> propertyNamesBookings = (Map<String,List<DateRange>>) objectInputStream.readObject();
        	        
                    for (Map.Entry<String, List<DateRange>> entry : propertyNamesBookings.entrySet()) {
                        String propertyName = entry.getKey();
                        List<DateRange> bookings = entry.getValue();
                        
                        if (mergedPropertyNamesBookings.containsKey(propertyName)) {
                            // If the property already exists in the merged map, merge its bookings
                            mergedPropertyNamesBookings.get(propertyName).addAll(bookings);
                        } else {
                            // If the property doesn't exist in the merged map, add it with its bookings
                            mergedPropertyNamesBookings.put(propertyName, new ArrayList<>(bookings));
                        }
                    }

                    System.out.println("Received property bookings from worker on port: " + port);
        	        
        	        
        	    } catch (IOException | ClassNotFoundException e) {
        	        e.printStackTrace();
        	    }
        	}
    	
    	try (PrintWriter writer = new PrintWriter(clientSocket.getOutputStream(), true)) {
            // Send the string to the client
            writer.println("These are your properties:");
            System.out.println("Sent merged properties to the client");
        } catch (IOException e) {
            e.printStackTrace();
        }
    	
    }

    private void forwardPropertySearch(String propertyId, Map<String, Object> filters) {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyId.hashCode()) % workers.size();
        Worker worker = workers.get(workerIndex);

        // Search for properties on the chosen worker
        List<Property> searchResults = worker.searchProperties(filters);

        // Print search results to the console
        System.out.println("Search results for property ID " + propertyId + ":");
        for (Property property : searchResults) {
            System.out.println(property.toString()); // Assuming Property class overrides toString() method
        }
    }


    private void forwardPropertyBooking(String renterUsername, String propertyName, DateRange bookingRange) {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        try (
                BufferedReader consoleReader = new BufferedReader(new InputStreamReader(System.in));
                ObjectOutputStream objectOutputStream = new ObjectOutputStream(workerSockets.get(workerIndex).getOutputStream());
                BufferedReader reader = new BufferedReader(new InputStreamReader(workerSockets.get(workerIndex).getInputStream()))) {

               System.out.println("Established connection with worker on port:"+ port);
               System.out.println("Adding new booking...");

               String book = "BOOK";
               objectOutputStream.writeObject(book);
               objectOutputStream.writeObject(renterUsername);
               objectOutputStream.writeObject(propertyName);
               objectOutputStream.writeObject(bookingRange);

           } catch (IOException e) {
               e.printStackTrace();
           }
    }
    
    private void forwardPropertyRating(String renterUsername, String propertyName, Integer stars) {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        try (
                BufferedReader consoleReader = new BufferedReader(new InputStreamReader(System.in));
                ObjectOutputStream objectOutputStream = new ObjectOutputStream(workerSockets.get(workerIndex).getOutputStream());
                BufferedReader reader = new BufferedReader(new InputStreamReader(workerSockets.get(workerIndex).getInputStream()))) {

               System.out.println("Established connection with worker on port:"+ port);
               System.out.println("Adding new rating...");

               String rate = "RATE";
               objectOutputStream.writeObject(rate);
               objectOutputStream.writeObject(renterUsername);
               objectOutputStream.writeObject(propertyName);
               objectOutputStream.writeObject(stars);

           } catch (IOException e) {
               e.printStackTrace();
           }
    }
    
    private void forwardPropertyFiltering(String area, DateRange dateRange, Integer people, Integer price, Integer stars) {
    	
    	ArrayList<Property> mergedFilteredProperties= new ArrayList<Property>();
    	
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    try (
    	            ObjectOutputStream objectOutputStream = new ObjectOutputStream(workerSockets.get(i).getOutputStream());
    	            ObjectInputStream objectInputStream = new ObjectInputStream(workerSockets.get(i).getInputStream())) {

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("FILTER");
    	        objectOutputStream.writeObject(area);
    	        objectOutputStream.writeObject(dateRange);
    	        objectOutputStream.writeObject(people);
    	        objectOutputStream.writeObject(price);
    	        objectOutputStream.writeObject(stars);
    	        
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> filteredProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedFilteredProperties.addAll(filteredProperties);

    	        System.out.println("Received filtered properties from worker on port: " + port);
    	        
    	        
    	    } catch (IOException | ClassNotFoundException e) {
    	        e.printStackTrace();
    	    }
    	}
    }
    
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2024-04-12 17:23:30.597
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2024-04-12 17:23:30.597
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-12 17:23:30.615
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.UnknownHostException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.imageio.ImageIO;

public class Master {
	
	private int propertyCounter;
    private List<Worker> workers;
    private Socket clientSocket;
    private ArrayList<Socket> workerSockets;
    private ArrayList<ObjectInputStream> workerInputStreams;
    private ArrayList<ObjectOutputStream> workerOutputStreams;
    
    public Master(int[] workerPorts) {
    	Socket sock=null;
    	this.propertyCounter=0;
        this.workers = new ArrayList<>();
        workerSockets=new ArrayList<>();
        workerInputStreams = new ArrayList<>();
        workerOutputStreams = new ArrayList<>();
        
        for (int port : workerPorts) {
            Worker worker = new Worker(port); // Pass the port number to the Worker constructor
			worker.start(); // Start the worker thread
			workers.add(worker);
			System.out.println("Worker connected on port: " + port);
			try {
				sock=new Socket("localhost", port);
				workerInputStreams.add(new ObjectInputStream(sock.getInputStream()));
				workerOutputStreams.add(new ObjectOutputStream(sock.getOutputStream()));
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			workerSockets.add(sock);
			
        }
        
    }


    public void start() throws IOException, ParseException, ClassNotFoundException{
//        for (Worker worker : workers) {
//            worker.start();
//        }
        // Start listening for client requests
        try (ServerSocket serverSocket = new ServerSocket(5000)) {
            System.out.println("Master server started...");
            while (true) {
                clientSocket = serverSocket.accept();
                System.out.println("A");
                handleClientRequest(clientSocket);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void handleClientRequest(Socket clientSocket) throws IOException, ParseException, ClassNotFoundException {
    	
    	String managerUsername;
    	String renterUsername;
    	String propertyName;
    	Integer stars;
    	String area;
    	DateRange dateRange;
    	Integer people;
    	Integer price;
    	
    	 try (ObjectInputStream objectInputStream = new ObjectInputStream(clientSocket.getInputStream());
    			 ObjectOutputStream objectOutputStream = new ObjectOutputStream(clientSocket.getOutputStream());
    	        ) {
    		 
    		 while (true) {
    			 System.out.println("Awaiting action command from user");
	    	     String action = (String) objectInputStream.readObject();
	//            String[] tokens = request.split(":");
	//            String action = tokens[0];
	//            String propertyId = tokens[1];
	            switch (action) {
	                case "ADD":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	readPropertyFromStream(objectInputStream);
	                    break;
	                case "SHOW":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	managerUsername = (String) objectInputStream.readObject();
	                	System.out.println("Action at worker:"+action);
	                	System.out.println(managerUsername);
	                	objectOutputStream.writeObject(showManagerProperties(managerUsername));
	                    break;
	                case "AVAILABILITY":
	                	readAvailabilityFromStream(objectInputStream);
	                    break;
	                case "BOOKINGS":
	                	managerUsername = (String) objectInputStream.readObject();
	                	showManagerBookings(managerUsername);
	                    break;
	                case "BOOK":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	DateRange bookingRange = readDateRangeFromStream(objectInputStream);
	                    forwardPropertyBooking(renterUsername, propertyName, bookingRange);
	                    break;
	                case "RATE":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                    forwardPropertyRating(renterUsername, propertyName, stars);
	                    break;
	                case "FILTER":
	                	area = (String) objectInputStream.readObject();
	                	dateRange=readDateRangeFromStream(objectInputStream);
	                	people = (Integer) objectInputStream.readObject();
	                	price = (Integer) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                	forwardPropertyFiltering(area, dateRange, people, price, stars);
	                    break;
	                // Implement cases for other request types (UPDATE, etc.) as needed
	                default:
	                    // Unknown action, send error response
	                    break;
	               }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void readPropertyFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyInfo = (String) objectInputStream.readObject();

        // Read property info
        String[] keyValuePairs = propertyInfo.substring(1, propertyInfo.length() - 1).split(",");

        String roomName = "";
        int noOfPersons = 0;
        String area = "";
        int stars = 0;
        int noOfReviews = 0;
        String roomImage = "";

        // Iterate over key-value pairs and split them based on colons
        for (String pair : keyValuePairs) {
            System.out.println(pair);
            String[] keyValue = pair.split(":");
            String key = keyValue[0].trim().replaceAll("\"", "");
            String value = keyValue[1].trim().replaceAll("\"", ""); // Remove quotes

            // Assign values to appropriate variables based on keys
            switch (key) {
                case "roomName":
                    roomName = value;
                    break;
                case "noOfPersons":
                    noOfPersons = Integer.parseInt(value);
                    break;
                case "area":
                    area = value;
                    break;
                case "stars":
                    stars = Integer.parseInt(value);
                    break;
                case "noOfReviews":
                    noOfReviews = Integer.parseInt(value);
                    break;
                case "roomImage":
                    roomImage = value;
                    break;
            }
        }
        
     // Print the values to verify
        System.out.println("Room Name: " + roomName);
        System.out.println("Number of Persons: " + noOfPersons);
        System.out.println("Area: " + area);
        System.out.println("Stars: " + stars);
        System.out.println("Number of Reviews: " + noOfReviews);
        System.out.println("Room Image: " + roomImage);

        // Read image data
        byte[] imageData = (byte[]) objectInputStream.readObject();

        // Convert byte array to BufferedImage
        ByteArrayInputStream bis = new ByteArrayInputStream(imageData);
//        BufferedImage bufferedImage = ImageIO.read(bis);
        
        forwardPropertyAddition(roomName, managerUsername ,new Property(roomName, noOfPersons, area, stars, noOfReviews, roomImage,propertyCounter++), imageData);

        // Return property object with image
    }
    
    private void readAvailabilityFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyName = (String) objectInputStream.readObject();
        
        String dateRangeAvailability = (String) objectInputStream.readObject();
        
        forwardPropertyAvailability(managerUsername, propertyName,dateRangeAvailability);

        // Return property object with image
    }

    private Map<String, Object> readFiltersFromStream(BufferedReader reader) throws IOException {
        Map<String, Object> filters = new HashMap<>();
        
        String line;
        while ((line = reader.readLine()) != null) {
            String[] tokens = line.split(":");
            String filterName = tokens[0];
            Object filterValue = tokens[1]; // Assuming filter value is string for simplicity, you may need to parse it accordingly
            filters.put(filterName, filterValue);
        }
        
        return filters;
    }

    private DateRange readDateRangeFromStream(ObjectInputStream objectInputStream) throws IOException, ParseException, ClassNotFoundException {
    	String startDateStr = (String) objectInputStream.readObject();
        String endDateStr = (String) objectInputStream.readObject();
        // Assuming date format is in "day/month/year"
        SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
        Date startDate = dateFormat.parse(startDateStr);
        Date endDate = dateFormat.parse(endDateStr);
        return new DateRange(startDate, endDate);
    }

    private void forwardPropertyAddition(String propertyName, String managerUsername,Property property, byte [] imageBytes) throws IOException {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new property...");

       String add = "ADD";
       objectOutputStream.writeObject(add);
       System.out.println("ADD SENT");
       objectOutputStream.writeObject(managerUsername);
       objectOutputStream.writeObject(property);
       objectOutputStream.writeObject(imageBytes);

          
    }
    
    private void forwardPropertyAvailability(String managerUsername,String propertyName,String dateRangeAvailability) {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        try (
                BufferedReader consoleReader = new BufferedReader(new InputStreamReader(System.in));
                ObjectOutputStream objectOutputStream = new ObjectOutputStream(workerSockets.get(workerIndex).getOutputStream());
                BufferedReader reader = new BufferedReader(new InputStreamReader(workerSockets.get(workerIndex).getInputStream()))) {

               System.out.println("Established connection with worker on port:"+ port);
               System.out.println("Adding new availability...");

               String availability = "AVAILABILITY";
               objectOutputStream.writeObject(availability);
               objectOutputStream.writeObject(managerUsername);
               objectOutputStream.writeObject(propertyName);
               objectOutputStream.writeObject(dateRangeAvailability);

           } catch (IOException e) {
               e.printStackTrace();
           }
    }

    private String showManagerProperties(String managerUsername) {
    	
    	ArrayList<Property> mergedProperties = new ArrayList<>();
        
    	// Iterate over worker ports
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
    	    ObjectInputStream objectInputStream = workerInputStreams.get(i);

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("SHOW");
    	        objectOutputStream.writeObject(managerUsername);
    	        System.out.println("talked to worker");
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> workerProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedProperties.addAll(workerProperties);

    	        System.out.println("Received properties from worker on port: " + port);
    	        
    	        
    	        
    	    } catch (IOException | ClassNotFoundException e) {
    	        e.printStackTrace();
    	    }
    	}
    	
    	return String.valueOf(mergedProperties.size());
    	
    }
    	
    	private void showManagerBookings(String managerUsername) {
        	
    		Map<String,List<DateRange>> mergedPropertyNamesBookings= new HashMap<>();
            
        	// Iterate over worker ports
        	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
        	    int port = 5000 + i; // Calculate port number

        	    try (
        	            ObjectOutputStream objectOutputStream = new ObjectOutputStream(workerSockets.get(i).getOutputStream());
        	            ObjectInputStream objectInputStream = new ObjectInputStream(workerSockets.get(i).getInputStream())) {

        	        // Send "SHOW" request to worker
        	        objectOutputStream.writeObject("BOOKINGS");
        	        objectOutputStream.writeObject(managerUsername);
        	        
        	        // Receive ArrayList<Property> response from worker
        	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
        	        Map<String,List<DateRange>> propertyNamesBookings = (Map<String,List<DateRange>>) objectInputStream.readObject();
        	        
                    for (Map.Entry<String, List<DateRange>> entry : propertyNamesBookings.entrySet()) {
                        String propertyName = entry.getKey();
                        List<DateRange> bookings = entry.getValue();
                        
                        if (mergedPropertyNamesBookings.containsKey(propertyName)) {
                            // If the property already exists in the merged map, merge its bookings
                            mergedPropertyNamesBookings.get(propertyName).addAll(bookings);
                        } else {
                            // If the property doesn't exist in the merged map, add it with its bookings
                            mergedPropertyNamesBookings.put(propertyName, new ArrayList<>(bookings));
                        }
                    }

                    System.out.println("Received property bookings from worker on port: " + port);
        	        
        	        
        	    } catch (IOException | ClassNotFoundException e) {
        	        e.printStackTrace();
        	    }
        	}
    	
    	try (PrintWriter writer = new PrintWriter(clientSocket.getOutputStream(), true)) {
            // Send the string to the client
            writer.println("These are your properties:");
            System.out.println("Sent merged properties to the client");
        } catch (IOException e) {
            e.printStackTrace();
        }
    	
    }

    private void forwardPropertySearch(String propertyId, Map<String, Object> filters) {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyId.hashCode()) % workers.size();
        Worker worker = workers.get(workerIndex);

        // Search for properties on the chosen worker
        List<Property> searchResults = worker.searchProperties(filters);

        // Print search results to the console
        System.out.println("Search results for property ID " + propertyId + ":");
        for (Property property : searchResults) {
            System.out.println(property.toString()); // Assuming Property class overrides toString() method
        }
    }


    private void forwardPropertyBooking(String renterUsername, String propertyName, DateRange bookingRange) {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        try (
                BufferedReader consoleReader = new BufferedReader(new InputStreamReader(System.in));
                ObjectOutputStream objectOutputStream = new ObjectOutputStream(workerSockets.get(workerIndex).getOutputStream());
                BufferedReader reader = new BufferedReader(new InputStreamReader(workerSockets.get(workerIndex).getInputStream()))) {

               System.out.println("Established connection with worker on port:"+ port);
               System.out.println("Adding new booking...");

               String book = "BOOK";
               objectOutputStream.writeObject(book);
               objectOutputStream.writeObject(renterUsername);
               objectOutputStream.writeObject(propertyName);
               objectOutputStream.writeObject(bookingRange);

           } catch (IOException e) {
               e.printStackTrace();
           }
    }
    
    private void forwardPropertyRating(String renterUsername, String propertyName, Integer stars) {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        try (
                BufferedReader consoleReader = new BufferedReader(new InputStreamReader(System.in));
                ObjectOutputStream objectOutputStream = new ObjectOutputStream(workerSockets.get(workerIndex).getOutputStream());
                BufferedReader reader = new BufferedReader(new InputStreamReader(workerSockets.get(workerIndex).getInputStream()))) {

               System.out.println("Established connection with worker on port:"+ port);
               System.out.println("Adding new rating...");

               String rate = "RATE";
               objectOutputStream.writeObject(rate);
               objectOutputStream.writeObject(renterUsername);
               objectOutputStream.writeObject(propertyName);
               objectOutputStream.writeObject(stars);

           } catch (IOException e) {
               e.printStackTrace();
           }
    }
    
    private void forwardPropertyFiltering(String area, DateRange dateRange, Integer people, Integer price, Integer stars) {
    	
    	ArrayList<Property> mergedFilteredProperties= new ArrayList<Property>();
    	
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    try (
    	            ObjectOutputStream objectOutputStream = new ObjectOutputStream(workerSockets.get(i).getOutputStream());
    	            ObjectInputStream objectInputStream = new ObjectInputStream(workerSockets.get(i).getInputStream())) {

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("FILTER");
    	        objectOutputStream.writeObject(area);
    	        objectOutputStream.writeObject(dateRange);
    	        objectOutputStream.writeObject(people);
    	        objectOutputStream.writeObject(price);
    	        objectOutputStream.writeObject(stars);
    	        
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> filteredProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedFilteredProperties.addAll(filteredProperties);

    	        System.out.println("Received filtered properties from worker on port: " + port);
    	        
    	        
    	    } catch (IOException | ClassNotFoundException e) {
    	        e.printStackTrace();
    	    }
    	}
    }
    
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-04-12 17:23:30.615
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-04-12 17:23:30.616
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-12 17:23:32.839
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.UnknownHostException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.imageio.ImageIO;

public class Master {
	
	private int propertyCounter;
    private List<Worker> workers;
    private Socket clientSocket;
    private ArrayList<Socket> workerSockets;
    private ArrayList<ObjectInputStream> workerInputStreams;
    private ArrayList<ObjectOutputStream> workerOutputStreams;
    
    public Master(int[] workerPorts) {
    	Socket sock=null;
    	this.propertyCounter=0;
        this.workers = new ArrayList<>();
        workerSockets=new ArrayList<>();
        workerInputStreams = new ArrayList<>();
        workerOutputStreams = new ArrayList<>();
        
        for (int port : workerPorts) {
            Worker worker = new Worker(port); // Pass the port number to the Worker constructor
			worker.start(); // Start the worker thread
			workers.add(worker);
			System.out.println("Worker connected on port: " + port);
			try {
				sock=new Socket("localhost", port);
				workerInputStreams.add(new ObjectInputStream(sock.getInputStream()));
				workerOutputStreams.add(new ObjectOutputStream(sock.getOutputStream()));
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			workerSockets.add(sock);
			
        }
        
    }


    public void start() throws IOException, ParseException, ClassNotFoundException{
//        for (Worker worker : workers) {
//            worker.start();
//        }
        // Start listening for client requests
        try (ServerSocket serverSocket = new ServerSocket(5000)) {
            System.out.println("Master server started...");
            while (true) {
                clientSocket = serverSocket.accept();
                System.out.println("A");
                handleClientRequest(clientSocket);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void handleClientRequest(Socket clientSocket) throws IOException, ParseException, ClassNotFoundException {
    	
    	String managerUsername;
    	String renterUsername;
    	String propertyName;
    	Integer stars;
    	String area;
    	DateRange dateRange;
    	Integer people;
    	Integer price;
    	
    	 try (ObjectInputStream objectInputStream = new ObjectInputStream(clientSocket.getInputStream());
    			 ObjectOutputStream objectOutputStream = new ObjectOutputStream(clientSocket.getOutputStream());
    	        ) {
    		 
    		 while (true) {
    			 System.out.println("Awaiting action command from user");
	    	     String action = (String) objectInputStream.readObject();
	//            String[] tokens = request.split(":");
	//            String action = tokens[0];
	//            String propertyId = tokens[1];
	            switch (action) {
	                case "ADD":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	readPropertyFromStream(objectInputStream);
	                    break;
	                case "SHOW":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	managerUsername = (String) objectInputStream.readObject();
	                	System.out.println("Action at worker:"+action);
	                	System.out.println(managerUsername);
	                	objectOutputStream.writeObject(showManagerProperties(managerUsername));
	                    break;
	                case "AVAILABILITY":
	                	readAvailabilityFromStream(objectInputStream);
	                    break;
	                case "BOOKINGS":
	                	managerUsername = (String) objectInputStream.readObject();
	                	showManagerBookings(managerUsername);
	                    break;
	                case "BOOK":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	DateRange bookingRange = readDateRangeFromStream(objectInputStream);
	                    forwardPropertyBooking(renterUsername, propertyName, bookingRange);
	                    break;
	                case "RATE":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                    forwardPropertyRating(renterUsername, propertyName, stars);
	                    break;
	                case "FILTER":
	                	area = (String) objectInputStream.readObject();
	                	dateRange=readDateRangeFromStream(objectInputStream);
	                	people = (Integer) objectInputStream.readObject();
	                	price = (Integer) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                	forwardPropertyFiltering(area, dateRange, people, price, stars);
	                    break;
	                // Implement cases for other request types (UPDATE, etc.) as needed
	                default:
	                    // Unknown action, send error response
	                    break;
	               }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void readPropertyFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyInfo = (String) objectInputStream.readObject();

        // Read property info
        String[] keyValuePairs = propertyInfo.substring(1, propertyInfo.length() - 1).split(",");

        String roomName = "";
        int noOfPersons = 0;
        String area = "";
        int stars = 0;
        int noOfReviews = 0;
        String roomImage = "";

        // Iterate over key-value pairs and split them based on colons
        for (String pair : keyValuePairs) {
            System.out.println(pair);
            String[] keyValue = pair.split(":");
            String key = keyValue[0].trim().replaceAll("\"", "");
            String value = keyValue[1].trim().replaceAll("\"", ""); // Remove quotes

            // Assign values to appropriate variables based on keys
            switch (key) {
                case "roomName":
                    roomName = value;
                    break;
                case "noOfPersons":
                    noOfPersons = Integer.parseInt(value);
                    break;
                case "area":
                    area = value;
                    break;
                case "stars":
                    stars = Integer.parseInt(value);
                    break;
                case "noOfReviews":
                    noOfReviews = Integer.parseInt(value);
                    break;
                case "roomImage":
                    roomImage = value;
                    break;
            }
        }
        
     // Print the values to verify
        System.out.println("Room Name: " + roomName);
        System.out.println("Number of Persons: " + noOfPersons);
        System.out.println("Area: " + area);
        System.out.println("Stars: " + stars);
        System.out.println("Number of Reviews: " + noOfReviews);
        System.out.println("Room Image: " + roomImage);

        // Read image data
        byte[] imageData = (byte[]) objectInputStream.readObject();

        // Convert byte array to BufferedImage
        ByteArrayInputStream bis = new ByteArrayInputStream(imageData);
//        BufferedImage bufferedImage = ImageIO.read(bis);
        
        forwardPropertyAddition(roomName, managerUsername ,new Property(roomName, noOfPersons, area, stars, noOfReviews, roomImage,propertyCounter++), imageData);

        // Return property object with image
    }
    
    private void readAvailabilityFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyName = (String) objectInputStream.readObject();
        
        String dateRangeAvailability = (String) objectInputStream.readObject();
        
        forwardPropertyAvailability(managerUsername, propertyName,dateRangeAvailability);

        // Return property object with image
    }

    private Map<String, Object> readFiltersFromStream(BufferedReader reader) throws IOException {
        Map<String, Object> filters = new HashMap<>();
        
        String line;
        while ((line = reader.readLine()) != null) {
            String[] tokens = line.split(":");
            String filterName = tokens[0];
            Object filterValue = tokens[1]; // Assuming filter value is string for simplicity, you may need to parse it accordingly
            filters.put(filterName, filterValue);
        }
        
        return filters;
    }

    private DateRange readDateRangeFromStream(ObjectInputStream objectInputStream) throws IOException, ParseException, ClassNotFoundException {
    	String startDateStr = (String) objectInputStream.readObject();
        String endDateStr = (String) objectInputStream.readObject();
        // Assuming date format is in "day/month/year"
        SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
        Date startDate = dateFormat.parse(startDateStr);
        Date endDate = dateFormat.parse(endDateStr);
        return new DateRange(startDate, endDate);
    }

    private void forwardPropertyAddition(String propertyName, String managerUsername,Property property, byte [] imageBytes) throws IOException {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new property...");

       String add = "ADD";
       objectOutputStream.writeObject(add);
       System.out.println("ADD SENT");
       objectOutputStream.writeObject(managerUsername);
       objectOutputStream.writeObject(property);
       objectOutputStream.writeObject(imageBytes);

          
    }
    
    private void forwardPropertyAvailability(String managerUsername,String propertyName,String dateRangeAvailability) {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        try (
                BufferedReader consoleReader = new BufferedReader(new InputStreamReader(System.in));
                ObjectOutputStream objectOutputStream = new ObjectOutputStream(workerSockets.get(workerIndex).getOutputStream());
                BufferedReader reader = new BufferedReader(new InputStreamReader(workerSockets.get(workerIndex).getInputStream()))) {

               System.out.println("Established connection with worker on port:"+ port);
               System.out.println("Adding new availability...");

               String availability = "AVAILABILITY";
               objectOutputStream.writeObject(availability);
               objectOutputStream.writeObject(managerUsername);
               objectOutputStream.writeObject(propertyName);
               objectOutputStream.writeObject(dateRangeAvailability);

           } catch (IOException e) {
               e.printStackTrace();
           }
    }

    private String showManagerProperties(String managerUsername) {
    	
    	ArrayList<Property> mergedProperties = new ArrayList<>();
        
    	// Iterate over worker ports
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
    	    ObjectInputStream objectInputStream = workerInputStreams.get(i);

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("SHOW");
    	        objectOutputStream.writeObject(managerUsername);
    	        System.out.println("talked to worker");
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> workerProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedProperties.addAll(workerProperties);

    	        System.out.println("Received properties from worker on port: " + port);
    	        
    	        
    	        
    	    } catch (IOException | ClassNotFoundException e) {
    	        e.printStackTrace();
    	    }
    	}
    	
    	return String.valueOf(mergedProperties.size());
    	
    }
    	
    	private void showManagerBookings(String managerUsername) {
        	
    		Map<String,List<DateRange>> mergedPropertyNamesBookings= new HashMap<>();
            
        	// Iterate over worker ports
        	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
        	    int port = 5000 + i; // Calculate port number

        	    try (
        	            ObjectOutputStream objectOutputStream = new ObjectOutputStream(workerSockets.get(i).getOutputStream());
        	            ObjectInputStream objectInputStream = new ObjectInputStream(workerSockets.get(i).getInputStream())) {

        	        // Send "SHOW" request to worker
        	        objectOutputStream.writeObject("BOOKINGS");
        	        objectOutputStream.writeObject(managerUsername);
        	        
        	        // Receive ArrayList<Property> response from worker
        	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
        	        Map<String,List<DateRange>> propertyNamesBookings = (Map<String,List<DateRange>>) objectInputStream.readObject();
        	        
                    for (Map.Entry<String, List<DateRange>> entry : propertyNamesBookings.entrySet()) {
                        String propertyName = entry.getKey();
                        List<DateRange> bookings = entry.getValue();
                        
                        if (mergedPropertyNamesBookings.containsKey(propertyName)) {
                            // If the property already exists in the merged map, merge its bookings
                            mergedPropertyNamesBookings.get(propertyName).addAll(bookings);
                        } else {
                            // If the property doesn't exist in the merged map, add it with its bookings
                            mergedPropertyNamesBookings.put(propertyName, new ArrayList<>(bookings));
                        }
                    }

                    System.out.println("Received property bookings from worker on port: " + port);
        	        
        	        
        	    } catch (IOException | ClassNotFoundException e) {
        	        e.printStackTrace();
        	    }
        	}
    	
    	try (PrintWriter writer = new PrintWriter(clientSocket.getOutputStream(), true)) {
            // Send the string to the client
            writer.println("These are your properties:");
            System.out.println("Sent merged properties to the client");
        } catch (IOException e) {
            e.printStackTrace();
        }
    	
    }

    private void forwardPropertySearch(String propertyId, Map<String, Object> filters) {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyId.hashCode()) % workers.size();
        Worker worker = workers.get(workerIndex);

        // Search for properties on the chosen worker
        List<Property> searchResults = worker.searchProperties(filters);

        // Print search results to the console
        System.out.println("Search results for property ID " + propertyId + ":");
        for (Property property : searchResults) {
            System.out.println(property.toString()); // Assuming Property class overrides toString() method
        }
    }


    private void forwardPropertyBooking(String renterUsername, String propertyName, DateRange bookingRange) {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        try (
                BufferedReader consoleReader = new BufferedReader(new InputStreamReader(System.in));
                ObjectOutputStream objectOutputStream = new ObjectOutputStream(workerSockets.get(workerIndex).getOutputStream());
                BufferedReader reader = new BufferedReader(new InputStreamReader(workerSockets.get(workerIndex).getInputStream()))) {

               System.out.println("Established connection with worker on port:"+ port);
               System.out.println("Adding new booking...");

               String book = "BOOK";
               objectOutputStream.writeObject(book);
               objectOutputStream.writeObject(renterUsername);
               objectOutputStream.writeObject(propertyName);
               objectOutputStream.writeObject(bookingRange);

           } catch (IOException e) {
               e.printStackTrace();
           }
    }
    
    private void forwardPropertyRating(String renterUsername, String propertyName, Integer stars) {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        try (
                BufferedReader consoleReader = new BufferedReader(new InputStreamReader(System.in));
                ObjectOutputStream objectOutputStream = new ObjectOutputStream(workerSockets.get(workerIndex).getOutputStream());
                BufferedReader reader = new BufferedReader(new InputStreamReader(workerSockets.get(workerIndex).getInputStream()))) {

               System.out.println("Established connection with worker on port:"+ port);
               System.out.println("Adding new rating...");

               String rate = "RATE";
               objectOutputStream.writeObject(rate);
               objectOutputStream.writeObject(renterUsername);
               objectOutputStream.writeObject(propertyName);
               objectOutputStream.writeObject(stars);

           } catch (IOException e) {
               e.printStackTrace();
           }
    }
    
    private void forwardPropertyFiltering(String area, DateRange dateRange, Integer people, Integer price, Integer stars) {
    	
    	ArrayList<Property> mergedFilteredProperties= new ArrayList<Property>();
    	
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    try (
    	            ObjectOutputStream objectOutputStream = new ObjectOutputStream(workerSockets.get(i).getOutputStream());
    	            ObjectInputStream objectInputStream = new ObjectInputStream(workerSockets.get(i).getInputStream())) {

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("FILTER");
    	        objectOutputStream.writeObject(area);
    	        objectOutputStream.writeObject(dateRange);
    	        objectOutputStream.writeObject(people);
    	        objectOutputStream.writeObject(price);
    	        objectOutputStream.writeObject(stars);
    	        
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> filteredProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedFilteredProperties.addAll(filteredProperties);

    	        System.out.println("Received filtered properties from worker on port: " + port);
    	        
    	        
    	    } catch (IOException | ClassNotFoundException e) {
    	        e.printStackTrace();
    	    }
    	}
    }
    
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-04-12 17:23:32.840
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-04-12 17:23:32.841
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY de.yatta.platform.marketplace.licensing.client 2 0 2024-04-12 18:33:17.677
!MESSAGE Could not receive a valid response for solution feature de.yatta.feature.roundtrip from the license server.
!STACK 0
java.net.SocketTimeoutException: Read timed out
	at java.base/java.net.SocketInputStream.socketRead0(Native Method)
	at java.base/java.net.SocketInputStream.socketRead(SocketInputStream.java:115)
	at java.base/java.net.SocketInputStream.read(SocketInputStream.java:168)
	at java.base/java.net.SocketInputStream.read(SocketInputStream.java:140)
	at java.base/sun.security.ssl.SSLSocketInputRecord.read(SSLSocketInputRecord.java:484)
	at java.base/sun.security.ssl.SSLSocketInputRecord.readHeader(SSLSocketInputRecord.java:478)
	at java.base/sun.security.ssl.SSLSocketInputRecord.bytesInCompletePacket(SSLSocketInputRecord.java:70)
	at java.base/sun.security.ssl.SSLSocketImpl.readApplicationRecord(SSLSocketImpl.java:1459)
	at java.base/sun.security.ssl.SSLSocketImpl$AppInputStream.read(SSLSocketImpl.java:1070)
	at org.apache.http.impl.conn.LoggingInputStream.read(LoggingInputStream.java:84)
	at org.apache.http.impl.io.SessionInputBufferImpl.streamRead(SessionInputBufferImpl.java:137)
	at org.apache.http.impl.io.SessionInputBufferImpl.fillBuffer(SessionInputBufferImpl.java:153)
	at org.apache.http.impl.io.SessionInputBufferImpl.readLine(SessionInputBufferImpl.java:280)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:138)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:56)
	at org.apache.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:259)
	at org.apache.http.impl.DefaultBHttpClientConnection.receiveResponseHeader(DefaultBHttpClientConnection.java:163)
	at org.apache.http.impl.conn.CPoolProxy.receiveResponseHeader(CPoolProxy.java:157)
	at org.apache.http.protocol.HttpRequestExecutor.doReceiveResponse(HttpRequestExecutor.java:273)
	at de.yatta.eclipse.launcher.communication.utils.HttpRequestContext$RequestTemplateExecutor.doReceiveResponse(HttpRequestContext.java:707)
	at org.apache.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:125)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:272)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)
	at org.apache.http.client.fluent.Request.internalExecute(Request.java:173)
	at org.apache.http.client.fluent.Executor.execute(Executor.java:262)
	at de.yatta.eclipse.launcher.communication.utils.RequestTemplate.execute(RequestTemplate.java:200)
	at de.yatta.platform.marketplace.licensing.client.LicensingClient$1.run(LicensingClient.java:500)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2024-04-12 19:05:37.334 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.20
java.vendor=Microsoft
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.ecf.provider.filetransfer.httpclient45.win32 4 0 2024-04-12 19:05:38.896
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.ecf.provider.filetransfer.httpclient45.win32 [116]
  Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
       org.apache.httpcomponents.httpclient [40]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
  Unresolved requirement: Import-Package: org.apache.http.client.config; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client.config; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http"
  Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.impl.client; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="javax.net.ssl,org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.client.methods,org.apache.http.concurrent,org.apache.http.config,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.conn.socket,org.apache.http.conn.ssl,org.apache.http.conn.util,org.apache.http.cookie,org.apache.http.impl,org.apache.http.impl.auth,org.apache.http.impl.execchain,org.apache.http.message,org.apache.http.params,org.apache.http.pool,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth.win; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.auth.win; bundle-symbolic-name="org.apache.httpcomponents.httpclient.win"; bundle-version="4.5.10.v20200113-2105"; version="4.5.10"; x-internal:="true"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.impl.auth,org.apache.http.protocol,org.apache.http.util"
       org.apache.httpcomponents.httpclient.win [41]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
         Unresolved requirement: Import-Package: org.apache.http.conn.routing; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.conn.routing; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.epp.mpc.core.win32 4 0 2024-04-12 19:05:38.912
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.epp.mpc.core.win32 [135]
  Unresolved requirement: Import-Package: org.apache.http.impl.client; version="4.3.6"
    -> Export-Package: org.apache.http.impl.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="javax.net.ssl,org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.client.methods,org.apache.http.concurrent,org.apache.http.config,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.conn.socket,org.apache.http.conn.ssl,org.apache.http.conn.util,org.apache.http.cookie,org.apache.http.impl,org.apache.http.impl.auth,org.apache.http.impl.execchain,org.apache.http.message,org.apache.http.params,org.apache.http.pool,org.apache.http.protocol"
       org.apache.httpcomponents.httpclient [40]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
  Unresolved requirement: Import-Package: org.apache.http.client; version="4.3.6"
    -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth.win; version="4.3.6"
    -> Export-Package: org.apache.http.impl.auth.win; bundle-symbolic-name="org.apache.httpcomponents.httpclient.win"; bundle-version="4.5.10.v20200113-2105"; version="4.5.10"; x-internal:="true"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.impl.auth,org.apache.http.protocol,org.apache.http.util"
       org.apache.httpcomponents.httpclient.win [41]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
         Unresolved requirement: Import-Package: org.apache.http.conn.routing; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.conn.routing; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="4.3.6"
    -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.client.config; version="4.3.6"
    -> Export-Package: org.apache.http.client.config; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http"
  Unresolved requirement: Import-Package: org.apache.http.auth; version="4.3.6"
    -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.commons.notifications.feed 4 0 2024-04-12 19:05:39.024
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.commons.notifications.feed [603]
  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.tasks.ui 4 0 2024-04-12 19:05:39.071
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.tasks.ui [620]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.0.0"
    -> Bundle-SymbolicName: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.18.0.v20190930-2131"; singleton:="true"
       org.eclipse.mylyn.commons.notifications.feed [603]
         No resolution report for the bundle.  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.trac.ui 4 0 2024-04-12 19:05:39.103
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.trac.ui [622]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.tasks.ui; bundle-version="[3.8.0,4.0.0)"
    -> Bundle-SymbolicName: org.eclipse.mylyn.tasks.ui; bundle-version="3.25.2.v20200814-0512"; singleton:="true"
       org.eclipse.mylyn.tasks.ui [620]
         Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.0.0"
           -> Bundle-SymbolicName: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.18.0.v20190930-2131"; singleton:="true"
              org.eclipse.mylyn.commons.notifications.feed [603]
                No resolution report for the bundle.  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.jface 2 0 2024-04-12 19:05:43.953
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-04-12 19:05:43.953
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5c7a06ec,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@697b48e4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-04-12 19:05:51.610
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Giannis'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2024-04-12 19:09:58.930
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.UnknownHostException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.imageio.ImageIO;

public class Master {
	
	private int propertyCounter;
    private List<Worker> workers;
    private Socket clientSocket;
    private ArrayList<Socket> workerSockets;
    private ArrayList<ObjectInputStream> workerInputStreams;
    private ArrayList<ObjectOutputStream> workerOutputStreams;
    
    public Master(int[] workerPorts) {
    	Socket sock=null;
    	this.propertyCounter=0;
        this.workers = new ArrayList<>();
        workerSockets=new ArrayList<>();
        workerInputStreams = new ArrayList<>();
        workerOutputStreams = new ArrayList<>();
        
        for (int port : workerPorts) {
            Worker worker = new Worker(port); // Pass the port number to the Worker constructor
			worker.start(); // Start the worker thread
			workers.add(worker);
			System.out.println("Worker connected on port: " + port);
			try {
				sock=new Socket("localhost", port);
				workerInputStreams.add(new ObjectInputStream(sock.getInputStream()));
				workerOutputStreams.add(new ObjectOutputStream(sock.getOutputStream()));
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			workerSockets.add(sock);
			
        }
        
    }


    public void start() throws IOException, ParseException, ClassNotFoundException{
//        for (Worker worker : workers) {
//            worker.start();
//        }
        // Start listening for client requests
        try (ServerSocket serverSocket = new ServerSocket(5000)) {
            System.out.println("Master server started...");
            while (true) {
                clientSocket = serverSocket.accept();
                System.out.println("A");
                handleClientRequest(clientSocket);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void handleClientRequest(Socket clientSocket) throws IOException, ParseException, ClassNotFoundException {
    	
    	String managerUsername;
    	String renterUsername;
    	String propertyName;
    	Integer stars;
    	String area;
    	DateRange dateRange;
    	Integer people;
    	Integer price;
    	
    	 try (ObjectInputStream objectInputStream = new ObjectInputStream(clientSocket.getInputStream());
    			 ObjectOutputStream objectOutputStream = new ObjectOutputStream(clientSocket.getOutputStream());
    	        ) {
    		 
    		 while (true) {
    			 System.out.println("Awaiting action command from user");
	    	     String action = (String) objectInputStream.readObject();
	//            String[] tokens = request.split(":");
	//            String action = tokens[0];
	//            String propertyId = tokens[1];
	            switch (action) {
	                case "ADD":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	readPropertyFromStream(objectInputStream);
	                    break;
	                case "SHOW":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	managerUsername = (String) objectInputStream.readObject();
	                	System.out.println("Action at worker:"+action);
	                	System.out.println(managerUsername);
	                	objectOutputStream.writeObject(showManagerProperties(managerUsername));
	                    break;
	                case "AVAILABILITY":
	                	readAvailabilityFromStream(objectInputStream);
	                    break;
	                case "BOOKINGS":
	                	managerUsername = (String) objectInputStream.readObject();
	                	showManagerBookings(managerUsername);
	                    break;
	                case "BOOK":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	DateRange bookingRange = readDateRangeFromStream(objectInputStream);
	                    forwardPropertyBooking(renterUsername, propertyName, bookingRange);
	                    break;
	                case "RATE":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                    forwardPropertyRating(renterUsername, propertyName, stars);
	                    break;
	                case "FILTER":
	                	area = (String) objectInputStream.readObject();
	                	dateRange=readDateRangeFromStream(objectInputStream);
	                	people = (Integer) objectInputStream.readObject();
	                	price = (Integer) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                	forwardPropertyFiltering(area, dateRange, people, price, stars);
	                    break;
	                // Implement cases for other request types (UPDATE, etc.) as needed
	                default:
	                    // Unknown action, send error response
	                    break;
	               }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void readPropertyFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyInfo = (String) objectInputStream.readObject();

        // Read property info
        String[] keyValuePairs = propertyInfo.substring(1, propertyInfo.length() - 1).split(",");

        String roomName = "";
        int noOfPersons = 0;
        String area = "";
        int stars = 0;
        int noOfReviews = 0;
        String roomImage = "";

        // Iterate over key-value pairs and split them based on colons
        for (String pair : keyValuePairs) {
            System.out.println(pair);
            String[] keyValue = pair.split(":");
            String key = keyValue[0].trim().replaceAll("\"", "");
            String value = keyValue[1].trim().replaceAll("\"", ""); // Remove quotes

            // Assign values to appropriate variables based on keys
            switch (key) {
                case "roomName":
                    roomName = value;
                    break;
                case "noOfPersons":
                    noOfPersons = Integer.parseInt(value);
                    break;
                case "area":
                    area = value;
                    break;
                case "stars":
                    stars = Integer.parseInt(value);
                    break;
                case "noOfReviews":
                    noOfReviews = Integer.parseInt(value);
                    break;
                case "roomImage":
                    roomImage = value;
                    break;
            }
        }
        
     // Print the values to verify
        System.out.println("Room Name: " + roomName);
        System.out.println("Number of Persons: " + noOfPersons);
        System.out.println("Area: " + area);
        System.out.println("Stars: " + stars);
        System.out.println("Number of Reviews: " + noOfReviews);
        System.out.println("Room Image: " + roomImage);

        // Read image data
        byte[] imageData = (byte[]) objectInputStream.readObject();

        // Convert byte array to BufferedImage
        ByteArrayInputStream bis = new ByteArrayInputStream(imageData);
//        BufferedImage bufferedImage = ImageIO.read(bis);
        
        forwardPropertyAddition(roomName, managerUsername ,new Property(roomName, noOfPersons, area, stars, noOfReviews, roomImage,propertyCounter), imageData);
        propertyCounter=propertyCounter+1;
        // Return property object with image
    }
    
    private void readAvailabilityFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyName = (String) objectInputStream.readObject();
        
        String dateRangeAvailability = (String) objectInputStream.readObject();
        
        forwardPropertyAvailability(managerUsername, propertyName,dateRangeAvailability);

        // Return property object with image
    }

    private Map<String, Object> readFiltersFromStream(BufferedReader reader) throws IOException {
        Map<String, Object> filters = new HashMap<>();
        
        String line;
        while ((line = reader.readLine()) != null) {
            String[] tokens = line.split(":");
            String filterName = tokens[0];
            Object filterValue = tokens[1]; // Assuming filter value is string for simplicity, you may need to parse it accordingly
            filters.put(filterName, filterValue);
        }
        
        return filters;
    }

    private DateRange readDateRangeFromStream(ObjectInputStream objectInputStream) throws IOException, ParseException, ClassNotFoundException {
    	String startDateStr = (String) objectInputStream.readObject();
        String endDateStr = (String) objectInputStream.readObject();
        // Assuming date format is in "day/month/year"
        SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
        Date startDate = dateFormat.parse(startDateStr);
        Date endDate = dateFormat.parse(endDateStr);
        return new DateRange(startDate, endDate);
    }

    private void forwardPropertyAddition(String propertyName, String managerUsername,Property property, byte [] imageBytes) throws IOException {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new property...");

       String add = "ADD";
       objectOutputStream.writeObject(add);
       System.out.println("ADD SENT");
       objectOutputStream.writeObject(managerUsername);
       objectOutputStream.writeObject(property);
       objectOutputStream.writeObject(imageBytes);

          
    }
    
    private void forwardPropertyAvailability(String managerUsername,String propertyName,String dateRangeAvailability) throws IOException {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);
        

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new availability...");

       String availability = "AVAILABILITY";
       objectOutputStream.writeObject(availability);
       objectOutputStream.writeObject(managerUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(dateRangeAvailability);

    }

    private String showManagerProperties(String managerUsername) throws IOException, ClassNotFoundException {
    	
    	ArrayList<Property> mergedProperties = new ArrayList<>();
        
    	// Iterate over worker ports
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
    	    ObjectInputStream objectInputStream = workerInputStreams.get(i);

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("SHOW");
    	        objectOutputStream.writeObject(managerUsername);
    	        System.out.println("talked to worker");
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> workerProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedProperties.addAll(workerProperties);

    	        System.out.println("Received properties from worker on port: " + port);
    	        
    	        
    	        
    	 
    	}
    	
    	String returnedPropertiesAsString="";
    	
    	System.out.println(mergedProperties.get(0));
    	
    	for (int i=0;i<mergedProperties.size();i++) {
    		returnedPropertiesAsString=returnedPropertiesAsString+mergedProperties.get(i).toString();
    	}
    	
    	return returnedPropertiesAsString;
    	
    }
    	
    	private void showManagerBookings(String managerUsername) {
        	
    		Map<String,List<DateRange>> mergedPropertyNamesBookings= new HashMap<>();
            
        	// Iterate over worker ports
        	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
        	    int port = 5000 + i; // Calculate port number
        	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
        	    ObjectInputStream objectInputStream = workerInputStreams.get(i);

        	        // Send "SHOW" request to worker
        	        objectOutputStream.writeObject("BOOKINGS");
        	        objectOutputStream.writeObject(managerUsername);
        	        
        	        // Receive ArrayList<Property> response from worker
        	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
        	        Map<String,List<DateRange>> propertyNamesBookings = (Map<String,List<DateRange>>) objectInputStream.readObject();
        	        
                    for (Map.Entry<String, List<DateRange>> entry : propertyNamesBookings.entrySet()) {
                        String propertyName = entry.getKey();
                        List<DateRange> bookings = entry.getValue();
                        
                        if (mergedPropertyNamesBookings.containsKey(propertyName)) {
                            // If the property already exists in the merged map, merge its bookings
                            mergedPropertyNamesBookings.get(propertyName).addAll(bookings);
                        } else {
                            // If the property doesn't exist in the merged map, add it with its bookings
                            mergedPropertyNamesBookings.put(propertyName, new ArrayList<>(bookings));
                        }
                    }

                    System.out.println("Received property bookings from worker on port: " + port);
        	        
        	        
        	    } catch (IOException | ClassNotFoundException e) {
        	        e.printStackTrace();
        	    }
        	}
    	
    	try (PrintWriter writer = new PrintWriter(clientSocket.getOutputStream(), true)) {
            // Send the string to the client
            writer.println("These are your properties:");
            System.out.println("Sent merged properties to the client");
        } catch (IOException e) {
            e.printStackTrace();
        }
    	
    }

    private void forwardPropertySearch(String propertyId, Map<String, Object> filters) {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyId.hashCode()) % workers.size();
        Worker worker = workers.get(workerIndex);

        // Search for properties on the chosen worker
        List<Property> searchResults = worker.searchProperties(filters);

        // Print search results to the console
        System.out.println("Search results for property ID " + propertyId + ":");
        for (Property property : searchResults) {
            System.out.println(property.toString()); // Assuming Property class overrides toString() method
        }
    }


    private void forwardPropertyBooking(String renterUsername, String propertyName, DateRange bookingRange) throws IOException {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new booking...");

       String book = "BOOK";
       objectOutputStream.writeObject(book);
       objectOutputStream.writeObject(renterUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(bookingRange);

           
    }
    
    private void forwardPropertyRating(String renterUsername, String propertyName, Integer stars) throws IOException {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new rating...");

       String rate = "RATE";
       objectOutputStream.writeObject(rate);
       objectOutputStream.writeObject(renterUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(stars);

    }
    
    private void forwardPropertyFiltering(String area, DateRange dateRange, Integer people, Integer price, Integer stars) {
    	
    	ArrayList<Property> mergedFilteredProperties= new ArrayList<Property>();
    	
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    try (
    	            ObjectOutputStream objectOutputStream = new ObjectOutputStream(workerSockets.get(i).getOutputStream());
    	            ObjectInputStream objectInputStream = new ObjectInputStream(workerSockets.get(i).getInputStream())) {

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("FILTER");
    	        objectOutputStream.writeObject(area);
    	        objectOutputStream.writeObject(dateRange);
    	        objectOutputStream.writeObject(people);
    	        objectOutputStream.writeObject(price);
    	        objectOutputStream.writeObject(stars);
    	        
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> filteredProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedFilteredProperties.addAll(filteredProperties);

    	        System.out.println("Received filtered properties from worker on port: " + port);
    	        
    	        
    	    } catch (IOException | ClassNotFoundException e) {
    	        e.printStackTrace();
    	    }
    	}
    }
    
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2024-04-12 19:09:58.937
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2024-04-12 19:09:58.940
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-12 19:09:59.121
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.UnknownHostException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.imageio.ImageIO;

public class Master {
	
	private int propertyCounter;
    private List<Worker> workers;
    private Socket clientSocket;
    private ArrayList<Socket> workerSockets;
    private ArrayList<ObjectInputStream> workerInputStreams;
    private ArrayList<ObjectOutputStream> workerOutputStreams;
    
    public Master(int[] workerPorts) {
    	Socket sock=null;
    	this.propertyCounter=0;
        this.workers = new ArrayList<>();
        workerSockets=new ArrayList<>();
        workerInputStreams = new ArrayList<>();
        workerOutputStreams = new ArrayList<>();
        
        for (int port : workerPorts) {
            Worker worker = new Worker(port); // Pass the port number to the Worker constructor
			worker.start(); // Start the worker thread
			workers.add(worker);
			System.out.println("Worker connected on port: " + port);
			try {
				sock=new Socket("localhost", port);
				workerInputStreams.add(new ObjectInputStream(sock.getInputStream()));
				workerOutputStreams.add(new ObjectOutputStream(sock.getOutputStream()));
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			workerSockets.add(sock);
			
        }
        
    }


    public void start() throws IOException, ParseException, ClassNotFoundException{
//        for (Worker worker : workers) {
//            worker.start();
//        }
        // Start listening for client requests
        try (ServerSocket serverSocket = new ServerSocket(5000)) {
            System.out.println("Master server started...");
            while (true) {
                clientSocket = serverSocket.accept();
                System.out.println("A");
                handleClientRequest(clientSocket);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void handleClientRequest(Socket clientSocket) throws IOException, ParseException, ClassNotFoundException {
    	
    	String managerUsername;
    	String renterUsername;
    	String propertyName;
    	Integer stars;
    	String area;
    	DateRange dateRange;
    	Integer people;
    	Integer price;
    	
    	 try (ObjectInputStream objectInputStream = new ObjectInputStream(clientSocket.getInputStream());
    			 ObjectOutputStream objectOutputStream = new ObjectOutputStream(clientSocket.getOutputStream());
    	        ) {
    		 
    		 while (true) {
    			 System.out.println("Awaiting action command from user");
	    	     String action = (String) objectInputStream.readObject();
	//            String[] tokens = request.split(":");
	//            String action = tokens[0];
	//            String propertyId = tokens[1];
	            switch (action) {
	                case "ADD":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	readPropertyFromStream(objectInputStream);
	                    break;
	                case "SHOW":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	managerUsername = (String) objectInputStream.readObject();
	                	System.out.println("Action at worker:"+action);
	                	System.out.println(managerUsername);
	                	objectOutputStream.writeObject(showManagerProperties(managerUsername));
	                    break;
	                case "AVAILABILITY":
	                	readAvailabilityFromStream(objectInputStream);
	                    break;
	                case "BOOKINGS":
	                	managerUsername = (String) objectInputStream.readObject();
	                	showManagerBookings(managerUsername);
	                    break;
	                case "BOOK":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	DateRange bookingRange = readDateRangeFromStream(objectInputStream);
	                    forwardPropertyBooking(renterUsername, propertyName, bookingRange);
	                    break;
	                case "RATE":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                    forwardPropertyRating(renterUsername, propertyName, stars);
	                    break;
	                case "FILTER":
	                	area = (String) objectInputStream.readObject();
	                	dateRange=readDateRangeFromStream(objectInputStream);
	                	people = (Integer) objectInputStream.readObject();
	                	price = (Integer) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                	forwardPropertyFiltering(area, dateRange, people, price, stars);
	                    break;
	                // Implement cases for other request types (UPDATE, etc.) as needed
	                default:
	                    // Unknown action, send error response
	                    break;
	               }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void readPropertyFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyInfo = (String) objectInputStream.readObject();

        // Read property info
        String[] keyValuePairs = propertyInfo.substring(1, propertyInfo.length() - 1).split(",");

        String roomName = "";
        int noOfPersons = 0;
        String area = "";
        int stars = 0;
        int noOfReviews = 0;
        String roomImage = "";

        // Iterate over key-value pairs and split them based on colons
        for (String pair : keyValuePairs) {
            System.out.println(pair);
            String[] keyValue = pair.split(":");
            String key = keyValue[0].trim().replaceAll("\"", "");
            String value = keyValue[1].trim().replaceAll("\"", ""); // Remove quotes

            // Assign values to appropriate variables based on keys
            switch (key) {
                case "roomName":
                    roomName = value;
                    break;
                case "noOfPersons":
                    noOfPersons = Integer.parseInt(value);
                    break;
                case "area":
                    area = value;
                    break;
                case "stars":
                    stars = Integer.parseInt(value);
                    break;
                case "noOfReviews":
                    noOfReviews = Integer.parseInt(value);
                    break;
                case "roomImage":
                    roomImage = value;
                    break;
            }
        }
        
     // Print the values to verify
        System.out.println("Room Name: " + roomName);
        System.out.println("Number of Persons: " + noOfPersons);
        System.out.println("Area: " + area);
        System.out.println("Stars: " + stars);
        System.out.println("Number of Reviews: " + noOfReviews);
        System.out.println("Room Image: " + roomImage);

        // Read image data
        byte[] imageData = (byte[]) objectInputStream.readObject();

        // Convert byte array to BufferedImage
        ByteArrayInputStream bis = new ByteArrayInputStream(imageData);
//        BufferedImage bufferedImage = ImageIO.read(bis);
        
        forwardPropertyAddition(roomName, managerUsername ,new Property(roomName, noOfPersons, area, stars, noOfReviews, roomImage,propertyCounter), imageData);
        propertyCounter=propertyCounter+1;
        // Return property object with image
    }
    
    private void readAvailabilityFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyName = (String) objectInputStream.readObject();
        
        String dateRangeAvailability = (String) objectInputStream.readObject();
        
        forwardPropertyAvailability(managerUsername, propertyName,dateRangeAvailability);

        // Return property object with image
    }

    private Map<String, Object> readFiltersFromStream(BufferedReader reader) throws IOException {
        Map<String, Object> filters = new HashMap<>();
        
        String line;
        while ((line = reader.readLine()) != null) {
            String[] tokens = line.split(":");
            String filterName = tokens[0];
            Object filterValue = tokens[1]; // Assuming filter value is string for simplicity, you may need to parse it accordingly
            filters.put(filterName, filterValue);
        }
        
        return filters;
    }

    private DateRange readDateRangeFromStream(ObjectInputStream objectInputStream) throws IOException, ParseException, ClassNotFoundException {
    	String startDateStr = (String) objectInputStream.readObject();
        String endDateStr = (String) objectInputStream.readObject();
        // Assuming date format is in "day/month/year"
        SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
        Date startDate = dateFormat.parse(startDateStr);
        Date endDate = dateFormat.parse(endDateStr);
        return new DateRange(startDate, endDate);
    }

    private void forwardPropertyAddition(String propertyName, String managerUsername,Property property, byte [] imageBytes) throws IOException {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new property...");

       String add = "ADD";
       objectOutputStream.writeObject(add);
       System.out.println("ADD SENT");
       objectOutputStream.writeObject(managerUsername);
       objectOutputStream.writeObject(property);
       objectOutputStream.writeObject(imageBytes);

          
    }
    
    private void forwardPropertyAvailability(String managerUsername,String propertyName,String dateRangeAvailability) throws IOException {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);
        

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new availability...");

       String availability = "AVAILABILITY";
       objectOutputStream.writeObject(availability);
       objectOutputStream.writeObject(managerUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(dateRangeAvailability);

    }

    private String showManagerProperties(String managerUsername) throws IOException, ClassNotFoundException {
    	
    	ArrayList<Property> mergedProperties = new ArrayList<>();
        
    	// Iterate over worker ports
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
    	    ObjectInputStream objectInputStream = workerInputStreams.get(i);

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("SHOW");
    	        objectOutputStream.writeObject(managerUsername);
    	        System.out.println("talked to worker");
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> workerProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedProperties.addAll(workerProperties);

    	        System.out.println("Received properties from worker on port: " + port);
    	        
    	        
    	        
    	 
    	}
    	
    	String returnedPropertiesAsString="";
    	
    	System.out.println(mergedProperties.get(0));
    	
    	for (int i=0;i<mergedProperties.size();i++) {
    		returnedPropertiesAsString=returnedPropertiesAsString+mergedProperties.get(i).toString();
    	}
    	
    	return returnedPropertiesAsString;
    	
    }
    	
    	private void showManagerBookings(String managerUsername) {
        	
    		Map<String,List<DateRange>> mergedPropertyNamesBookings= new HashMap<>();
            
        	// Iterate over worker ports
        	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
        	    int port = 5000 + i; // Calculate port number
        	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
        	    ObjectInputStream objectInputStream = workerInputStreams.get(i);

        	        // Send "SHOW" request to worker
        	        objectOutputStream.writeObject("BOOKINGS");
        	        objectOutputStream.writeObject(managerUsername);
        	        
        	        // Receive ArrayList<Property> response from worker
        	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
        	        Map<String,List<DateRange>> propertyNamesBookings = (Map<String,List<DateRange>>) objectInputStream.readObject();
        	        
                    for (Map.Entry<String, List<DateRange>> entry : propertyNamesBookings.entrySet()) {
                        String propertyName = entry.getKey();
                        List<DateRange> bookings = entry.getValue();
                        
                        if (mergedPropertyNamesBookings.containsKey(propertyName)) {
                            // If the property already exists in the merged map, merge its bookings
                            mergedPropertyNamesBookings.get(propertyName).addAll(bookings);
                        } else {
                            // If the property doesn't exist in the merged map, add it with its bookings
                            mergedPropertyNamesBookings.put(propertyName, new ArrayList<>(bookings));
                        }
                    }

                    System.out.println("Received property bookings from worker on port: " + port);
        	        
        	        
        	    } catch (IOException | ClassNotFoundException e) {
        	        e.printStackTrace();
        	    }
        	}
    	
    	try (PrintWriter writer = new PrintWriter(clientSocket.getOutputStream(), true)) {
            // Send the string to the client
            writer.println("These are your properties:");
            System.out.println("Sent merged properties to the client");
        } catch (IOException e) {
            e.printStackTrace();
        }
    	
    }

    private void forwardPropertySearch(String propertyId, Map<String, Object> filters) {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyId.hashCode()) % workers.size();
        Worker worker = workers.get(workerIndex);

        // Search for properties on the chosen worker
        List<Property> searchResults = worker.searchProperties(filters);

        // Print search results to the console
        System.out.println("Search results for property ID " + propertyId + ":");
        for (Property property : searchResults) {
            System.out.println(property.toString()); // Assuming Property class overrides toString() method
        }
    }


    private void forwardPropertyBooking(String renterUsername, String propertyName, DateRange bookingRange) throws IOException {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new booking...");

       String book = "BOOK";
       objectOutputStream.writeObject(book);
       objectOutputStream.writeObject(renterUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(bookingRange);

           
    }
    
    private void forwardPropertyRating(String renterUsername, String propertyName, Integer stars) throws IOException {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new rating...");

       String rate = "RATE";
       objectOutputStream.writeObject(rate);
       objectOutputStream.writeObject(renterUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(stars);

    }
    
    private void forwardPropertyFiltering(String area, DateRange dateRange, Integer people, Integer price, Integer stars) {
    	
    	ArrayList<Property> mergedFilteredProperties= new ArrayList<Property>();
    	
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    try (
    	            ObjectOutputStream objectOutputStream = new ObjectOutputStream(workerSockets.get(i).getOutputStream());
    	            ObjectInputStream objectInputStream = new ObjectInputStream(workerSockets.get(i).getInputStream())) {

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("FILTER");
    	        objectOutputStream.writeObject(area);
    	        objectOutputStream.writeObject(dateRange);
    	        objectOutputStream.writeObject(people);
    	        objectOutputStream.writeObject(price);
    	        objectOutputStream.writeObject(stars);
    	        
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> filteredProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedFilteredProperties.addAll(filteredProperties);

    	        System.out.println("Received filtered properties from worker on port: " + port);
    	        
    	        
    	    } catch (IOException | ClassNotFoundException e) {
    	        e.printStackTrace();
    	    }
    	}
    }
    
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-04-12 19:09:59.126
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-04-12 19:09:59.130
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-12 19:09:59.234
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.UnknownHostException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.imageio.ImageIO;

public class Master {
	
	private int propertyCounter;
    private List<Worker> workers;
    private Socket clientSocket;
    private ArrayList<Socket> workerSockets;
    private ArrayList<ObjectInputStream> workerInputStreams;
    private ArrayList<ObjectOutputStream> workerOutputStreams;
    
    public Master(int[] workerPorts) {
    	Socket sock=null;
    	this.propertyCounter=0;
        this.workers = new ArrayList<>();
        workerSockets=new ArrayList<>();
        workerInputStreams = new ArrayList<>();
        workerOutputStreams = new ArrayList<>();
        
        for (int port : workerPorts) {
            Worker worker = new Worker(port); // Pass the port number to the Worker constructor
			worker.start(); // Start the worker thread
			workers.add(worker);
			System.out.println("Worker connected on port: " + port);
			try {
				sock=new Socket("localhost", port);
				workerInputStreams.add(new ObjectInputStream(sock.getInputStream()));
				workerOutputStreams.add(new ObjectOutputStream(sock.getOutputStream()));
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			workerSockets.add(sock);
			
        }
        
    }


    public void start() throws IOException, ParseException, ClassNotFoundException{
//        for (Worker worker : workers) {
//            worker.start();
//        }
        // Start listening for client requests
        try (ServerSocket serverSocket = new ServerSocket(5000)) {
            System.out.println("Master server started...");
            while (true) {
                clientSocket = serverSocket.accept();
                System.out.println("A");
                handleClientRequest(clientSocket);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void handleClientRequest(Socket clientSocket) throws IOException, ParseException, ClassNotFoundException {
    	
    	String managerUsername;
    	String renterUsername;
    	String propertyName;
    	Integer stars;
    	String area;
    	DateRange dateRange;
    	Integer people;
    	Integer price;
    	
    	 try (ObjectInputStream objectInputStream = new ObjectInputStream(clientSocket.getInputStream());
    			 ObjectOutputStream objectOutputStream = new ObjectOutputStream(clientSocket.getOutputStream());
    	        ) {
    		 
    		 while (true) {
    			 System.out.println("Awaiting action command from user");
	    	     String action = (String) objectInputStream.readObject();
	//            String[] tokens = request.split(":");
	//            String action = tokens[0];
	//            String propertyId = tokens[1];
	            switch (action) {
	                case "ADD":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	readPropertyFromStream(objectInputStream);
	                    break;
	                case "SHOW":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	managerUsername = (String) objectInputStream.readObject();
	                	System.out.println("Action at worker:"+action);
	                	System.out.println(managerUsername);
	                	objectOutputStream.writeObject(showManagerProperties(managerUsername));
	                    break;
	                case "AVAILABILITY":
	                	readAvailabilityFromStream(objectInputStream);
	                    break;
	                case "BOOKINGS":
	                	managerUsername = (String) objectInputStream.readObject();
	                	showManagerBookings(managerUsername);
	                    break;
	                case "BOOK":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	DateRange bookingRange = readDateRangeFromStream(objectInputStream);
	                    forwardPropertyBooking(renterUsername, propertyName, bookingRange);
	                    break;
	                case "RATE":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                    forwardPropertyRating(renterUsername, propertyName, stars);
	                    break;
	                case "FILTER":
	                	area = (String) objectInputStream.readObject();
	                	dateRange=readDateRangeFromStream(objectInputStream);
	                	people = (Integer) objectInputStream.readObject();
	                	price = (Integer) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                	forwardPropertyFiltering(area, dateRange, people, price, stars);
	                    break;
	                // Implement cases for other request types (UPDATE, etc.) as needed
	                default:
	                    // Unknown action, send error response
	                    break;
	               }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void readPropertyFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyInfo = (String) objectInputStream.readObject();

        // Read property info
        String[] keyValuePairs = propertyInfo.substring(1, propertyInfo.length() - 1).split(",");

        String roomName = "";
        int noOfPersons = 0;
        String area = "";
        int stars = 0;
        int noOfReviews = 0;
        String roomImage = "";

        // Iterate over key-value pairs and split them based on colons
        for (String pair : keyValuePairs) {
            System.out.println(pair);
            String[] keyValue = pair.split(":");
            String key = keyValue[0].trim().replaceAll("\"", "");
            String value = keyValue[1].trim().replaceAll("\"", ""); // Remove quotes

            // Assign values to appropriate variables based on keys
            switch (key) {
                case "roomName":
                    roomName = value;
                    break;
                case "noOfPersons":
                    noOfPersons = Integer.parseInt(value);
                    break;
                case "area":
                    area = value;
                    break;
                case "stars":
                    stars = Integer.parseInt(value);
                    break;
                case "noOfReviews":
                    noOfReviews = Integer.parseInt(value);
                    break;
                case "roomImage":
                    roomImage = value;
                    break;
            }
        }
        
     // Print the values to verify
        System.out.println("Room Name: " + roomName);
        System.out.println("Number of Persons: " + noOfPersons);
        System.out.println("Area: " + area);
        System.out.println("Stars: " + stars);
        System.out.println("Number of Reviews: " + noOfReviews);
        System.out.println("Room Image: " + roomImage);

        // Read image data
        byte[] imageData = (byte[]) objectInputStream.readObject();

        // Convert byte array to BufferedImage
        ByteArrayInputStream bis = new ByteArrayInputStream(imageData);
//        BufferedImage bufferedImage = ImageIO.read(bis);
        
        forwardPropertyAddition(roomName, managerUsername ,new Property(roomName, noOfPersons, area, stars, noOfReviews, roomImage,propertyCounter), imageData);
        propertyCounter=propertyCounter+1;
        // Return property object with image
    }
    
    private void readAvailabilityFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyName = (String) objectInputStream.readObject();
        
        String dateRangeAvailability = (String) objectInputStream.readObject();
        
        forwardPropertyAvailability(managerUsername, propertyName,dateRangeAvailability);

        // Return property object with image
    }

    private Map<String, Object> readFiltersFromStream(BufferedReader reader) throws IOException {
        Map<String, Object> filters = new HashMap<>();
        
        String line;
        while ((line = reader.readLine()) != null) {
            String[] tokens = line.split(":");
            String filterName = tokens[0];
            Object filterValue = tokens[1]; // Assuming filter value is string for simplicity, you may need to parse it accordingly
            filters.put(filterName, filterValue);
        }
        
        return filters;
    }

    private DateRange readDateRangeFromStream(ObjectInputStream objectInputStream) throws IOException, ParseException, ClassNotFoundException {
    	String startDateStr = (String) objectInputStream.readObject();
        String endDateStr = (String) objectInputStream.readObject();
        // Assuming date format is in "day/month/year"
        SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
        Date startDate = dateFormat.parse(startDateStr);
        Date endDate = dateFormat.parse(endDateStr);
        return new DateRange(startDate, endDate);
    }

    private void forwardPropertyAddition(String propertyName, String managerUsername,Property property, byte [] imageBytes) throws IOException {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new property...");

       String add = "ADD";
       objectOutputStream.writeObject(add);
       System.out.println("ADD SENT");
       objectOutputStream.writeObject(managerUsername);
       objectOutputStream.writeObject(property);
       objectOutputStream.writeObject(imageBytes);

          
    }
    
    private void forwardPropertyAvailability(String managerUsername,String propertyName,String dateRangeAvailability) throws IOException {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);
        

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new availability...");

       String availability = "AVAILABILITY";
       objectOutputStream.writeObject(availability);
       objectOutputStream.writeObject(managerUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(dateRangeAvailability);

    }

    private String showManagerProperties(String managerUsername) throws IOException, ClassNotFoundException {
    	
    	ArrayList<Property> mergedProperties = new ArrayList<>();
        
    	// Iterate over worker ports
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
    	    ObjectInputStream objectInputStream = workerInputStreams.get(i);

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("SHOW");
    	        objectOutputStream.writeObject(managerUsername);
    	        System.out.println("talked to worker");
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> workerProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedProperties.addAll(workerProperties);

    	        System.out.println("Received properties from worker on port: " + port);
    	        
    	        
    	        
    	 
    	}
    	
    	String returnedPropertiesAsString="";
    	
    	System.out.println(mergedProperties.get(0));
    	
    	for (int i=0;i<mergedProperties.size();i++) {
    		returnedPropertiesAsString=returnedPropertiesAsString+mergedProperties.get(i).toString();
    	}
    	
    	return returnedPropertiesAsString;
    	
    }
    	
    	private void showManagerBookings(String managerUsername) {
        	
    		Map<String,List<DateRange>> mergedPropertyNamesBookings= new HashMap<>();
            
        	// Iterate over worker ports
        	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
        	    int port = 5000 + i; // Calculate port number
        	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
        	    ObjectInputStream objectInputStream = workerInputStreams.get(i);

        	        // Send "SHOW" request to worker
        	        objectOutputStream.writeObject("BOOKINGS");
        	        objectOutputStream.writeObject(managerUsername);
        	        
        	        // Receive ArrayList<Property> response from worker
        	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
        	        Map<String,List<DateRange>> propertyNamesBookings = (Map<String,List<DateRange>>) objectInputStream.readObject();
        	        
                    for (Map.Entry<String, List<DateRange>> entry : propertyNamesBookings.entrySet()) {
                        String propertyName = entry.getKey();
                        List<DateRange> bookings = entry.getValue();
                        
                        if (mergedPropertyNamesBookings.containsKey(propertyName)) {
                            // If the property already exists in the merged map, merge its bookings
                            mergedPropertyNamesBookings.get(propertyName).addAll(bookings);
                        } else {
                            // If the property doesn't exist in the merged map, add it with its bookings
                            mergedPropertyNamesBookings.put(propertyName, new ArrayList<>(bookings));
                        }
                    }

                    System.out.println("Received property bookings from worker on port: " + port);
        	        
        	        
        	    } catch (IOException | ClassNotFoundException e) {
        	        e.printStackTrace();
        	    }
        	}
    	
    	try (PrintWriter writer = new PrintWriter(clientSocket.getOutputStream(), true)) {
            // Send the string to the client
            writer.println("These are your properties:");
            System.out.println("Sent merged properties to the client");
        } catch (IOException e) {
            e.printStackTrace();
        }
    	
    }

    private void forwardPropertySearch(String propertyId, Map<String, Object> filters) {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyId.hashCode()) % workers.size();
        Worker worker = workers.get(workerIndex);

        // Search for properties on the chosen worker
        List<Property> searchResults = worker.searchProperties(filters);

        // Print search results to the console
        System.out.println("Search results for property ID " + propertyId + ":");
        for (Property property : searchResults) {
            System.out.println(property.toString()); // Assuming Property class overrides toString() method
        }
    }


    private void forwardPropertyBooking(String renterUsername, String propertyName, DateRange bookingRange) throws IOException {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new booking...");

       String book = "BOOK";
       objectOutputStream.writeObject(book);
       objectOutputStream.writeObject(renterUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(bookingRange);

           
    }
    
    private void forwardPropertyRating(String renterUsername, String propertyName, Integer stars) throws IOException {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new rating...");

       String rate = "RATE";
       objectOutputStream.writeObject(rate);
       objectOutputStream.writeObject(renterUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(stars);

    }
    
    private void forwardPropertyFiltering(String area, DateRange dateRange, Integer people, Integer price, Integer stars) {
    	
    	ArrayList<Property> mergedFilteredProperties= new ArrayList<Property>();
    	
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    try (
    	            ObjectOutputStream objectOutputStream = new ObjectOutputStream(workerSockets.get(i).getOutputStream());
    	            ObjectInputStream objectInputStream = new ObjectInputStream(workerSockets.get(i).getInputStream())) {

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("FILTER");
    	        objectOutputStream.writeObject(area);
    	        objectOutputStream.writeObject(dateRange);
    	        objectOutputStream.writeObject(people);
    	        objectOutputStream.writeObject(price);
    	        objectOutputStream.writeObject(stars);
    	        
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> filteredProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedFilteredProperties.addAll(filteredProperties);

    	        System.out.println("Received filtered properties from worker on port: " + port);
    	        
    	        
    	    } catch (IOException | ClassNotFoundException e) {
    	        e.printStackTrace();
    	    }
    	}
    }
    
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-04-12 19:09:59.238
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-04-12 19:09:59.241
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-12 19:09:59.317
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.UnknownHostException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.imageio.ImageIO;

public class Master {
	
	private int propertyCounter;
    private List<Worker> workers;
    private Socket clientSocket;
    private ArrayList<Socket> workerSockets;
    private ArrayList<ObjectInputStream> workerInputStreams;
    private ArrayList<ObjectOutputStream> workerOutputStreams;
    
    public Master(int[] workerPorts) {
    	Socket sock=null;
    	this.propertyCounter=0;
        this.workers = new ArrayList<>();
        workerSockets=new ArrayList<>();
        workerInputStreams = new ArrayList<>();
        workerOutputStreams = new ArrayList<>();
        
        for (int port : workerPorts) {
            Worker worker = new Worker(port); // Pass the port number to the Worker constructor
			worker.start(); // Start the worker thread
			workers.add(worker);
			System.out.println("Worker connected on port: " + port);
			try {
				sock=new Socket("localhost", port);
				workerInputStreams.add(new ObjectInputStream(sock.getInputStream()));
				workerOutputStreams.add(new ObjectOutputStream(sock.getOutputStream()));
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			workerSockets.add(sock);
			
        }
        
    }


    public void start() throws IOException, ParseException, ClassNotFoundException{
//        for (Worker worker : workers) {
//            worker.start();
//        }
        // Start listening for client requests
        try (ServerSocket serverSocket = new ServerSocket(5000)) {
            System.out.println("Master server started...");
            while (true) {
                clientSocket = serverSocket.accept();
                System.out.println("A");
                handleClientRequest(clientSocket);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void handleClientRequest(Socket clientSocket) throws IOException, ParseException, ClassNotFoundException {
    	
    	String managerUsername;
    	String renterUsername;
    	String propertyName;
    	Integer stars;
    	String area;
    	DateRange dateRange;
    	Integer people;
    	Integer price;
    	
    	 try (ObjectInputStream objectInputStream = new ObjectInputStream(clientSocket.getInputStream());
    			 ObjectOutputStream objectOutputStream = new ObjectOutputStream(clientSocket.getOutputStream());
    	        ) {
    		 
    		 while (true) {
    			 System.out.println("Awaiting action command from user");
	    	     String action = (String) objectInputStream.readObject();
	//            String[] tokens = request.split(":");
	//            String action = tokens[0];
	//            String propertyId = tokens[1];
	            switch (action) {
	                case "ADD":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	readPropertyFromStream(objectInputStream);
	                    break;
	                case "SHOW":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	managerUsername = (String) objectInputStream.readObject();
	                	System.out.println("Action at worker:"+action);
	                	System.out.println(managerUsername);
	                	objectOutputStream.writeObject(showManagerProperties(managerUsername));
	                    break;
	                case "AVAILABILITY":
	                	readAvailabilityFromStream(objectInputStream);
	                    break;
	                case "BOOKINGS":
	                	managerUsername = (String) objectInputStream.readObject();
	                	showManagerBookings(managerUsername);
	                    break;
	                case "BOOK":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	DateRange bookingRange = readDateRangeFromStream(objectInputStream);
	                    forwardPropertyBooking(renterUsername, propertyName, bookingRange);
	                    break;
	                case "RATE":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                    forwardPropertyRating(renterUsername, propertyName, stars);
	                    break;
	                case "FILTER":
	                	area = (String) objectInputStream.readObject();
	                	dateRange=readDateRangeFromStream(objectInputStream);
	                	people = (Integer) objectInputStream.readObject();
	                	price = (Integer) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                	forwardPropertyFiltering(area, dateRange, people, price, stars);
	                    break;
	                // Implement cases for other request types (UPDATE, etc.) as needed
	                default:
	                    // Unknown action, send error response
	                    break;
	               }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void readPropertyFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyInfo = (String) objectInputStream.readObject();

        // Read property info
        String[] keyValuePairs = propertyInfo.substring(1, propertyInfo.length() - 1).split(",");

        String roomName = "";
        int noOfPersons = 0;
        String area = "";
        int stars = 0;
        int noOfReviews = 0;
        String roomImage = "";

        // Iterate over key-value pairs and split them based on colons
        for (String pair : keyValuePairs) {
            System.out.println(pair);
            String[] keyValue = pair.split(":");
            String key = keyValue[0].trim().replaceAll("\"", "");
            String value = keyValue[1].trim().replaceAll("\"", ""); // Remove quotes

            // Assign values to appropriate variables based on keys
            switch (key) {
                case "roomName":
                    roomName = value;
                    break;
                case "noOfPersons":
                    noOfPersons = Integer.parseInt(value);
                    break;
                case "area":
                    area = value;
                    break;
                case "stars":
                    stars = Integer.parseInt(value);
                    break;
                case "noOfReviews":
                    noOfReviews = Integer.parseInt(value);
                    break;
                case "roomImage":
                    roomImage = value;
                    break;
            }
        }
        
     // Print the values to verify
        System.out.println("Room Name: " + roomName);
        System.out.println("Number of Persons: " + noOfPersons);
        System.out.println("Area: " + area);
        System.out.println("Stars: " + stars);
        System.out.println("Number of Reviews: " + noOfReviews);
        System.out.println("Room Image: " + roomImage);

        // Read image data
        byte[] imageData = (byte[]) objectInputStream.readObject();

        // Convert byte array to BufferedImage
        ByteArrayInputStream bis = new ByteArrayInputStream(imageData);
//        BufferedImage bufferedImage = ImageIO.read(bis);
        
        forwardPropertyAddition(roomName, managerUsername ,new Property(roomName, noOfPersons, area, stars, noOfReviews, roomImage,propertyCounter), imageData);
        propertyCounter=propertyCounter+1;
        // Return property object with image
    }
    
    private void readAvailabilityFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyName = (String) objectInputStream.readObject();
        
        String dateRangeAvailability = (String) objectInputStream.readObject();
        
        forwardPropertyAvailability(managerUsername, propertyName,dateRangeAvailability);

        // Return property object with image
    }

    private Map<String, Object> readFiltersFromStream(BufferedReader reader) throws IOException {
        Map<String, Object> filters = new HashMap<>();
        
        String line;
        while ((line = reader.readLine()) != null) {
            String[] tokens = line.split(":");
            String filterName = tokens[0];
            Object filterValue = tokens[1]; // Assuming filter value is string for simplicity, you may need to parse it accordingly
            filters.put(filterName, filterValue);
        }
        
        return filters;
    }

    private DateRange readDateRangeFromStream(ObjectInputStream objectInputStream) throws IOException, ParseException, ClassNotFoundException {
    	String startDateStr = (String) objectInputStream.readObject();
        String endDateStr = (String) objectInputStream.readObject();
        // Assuming date format is in "day/month/year"
        SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
        Date startDate = dateFormat.parse(startDateStr);
        Date endDate = dateFormat.parse(endDateStr);
        return new DateRange(startDate, endDate);
    }

    private void forwardPropertyAddition(String propertyName, String managerUsername,Property property, byte [] imageBytes) throws IOException {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new property...");

       String add = "ADD";
       objectOutputStream.writeObject(add);
       System.out.println("ADD SENT");
       objectOutputStream.writeObject(managerUsername);
       objectOutputStream.writeObject(property);
       objectOutputStream.writeObject(imageBytes);

          
    }
    
    private void forwardPropertyAvailability(String managerUsername,String propertyName,String dateRangeAvailability) throws IOException {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);
        

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new availability...");

       String availability = "AVAILABILITY";
       objectOutputStream.writeObject(availability);
       objectOutputStream.writeObject(managerUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(dateRangeAvailability);

    }

    private String showManagerProperties(String managerUsername) throws IOException, ClassNotFoundException {
    	
    	ArrayList<Property> mergedProperties = new ArrayList<>();
        
    	// Iterate over worker ports
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
    	    ObjectInputStream objectInputStream = workerInputStreams.get(i);

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("SHOW");
    	        objectOutputStream.writeObject(managerUsername);
    	        System.out.println("talked to worker");
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> workerProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedProperties.addAll(workerProperties);

    	        System.out.println("Received properties from worker on port: " + port);
    	        
    	        
    	        
    	 
    	}
    	
    	String returnedPropertiesAsString="";
    	
    	System.out.println(mergedProperties.get(0));
    	
    	for (int i=0;i<mergedProperties.size();i++) {
    		returnedPropertiesAsString=returnedPropertiesAsString+mergedProperties.get(i).toString();
    	}
    	
    	return returnedPropertiesAsString;
    	
    }
    	
    	private void showManagerBookings(String managerUsername) {
        	
    		Map<String,List<DateRange>> mergedPropertyNamesBookings= new HashMap<>();
            
        	// Iterate over worker ports
        	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
        	    int port = 5000 + i; // Calculate port number
        	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
        	    ObjectInputStream objectInputStream = workerInputStreams.get(i);

        	        // Send "SHOW" request to worker
        	        objectOutputStream.writeObject("BOOKINGS");
        	        objectOutputStream.writeObject(managerUsername);
        	        
        	        // Receive ArrayList<Property> response from worker
        	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
        	        Map<String,List<DateRange>> propertyNamesBookings = (Map<String,List<DateRange>>) objectInputStream.readObject();
        	        
                    for (Map.Entry<String, List<DateRange>> entry : propertyNamesBookings.entrySet()) {
                        String propertyName = entry.getKey();
                        List<DateRange> bookings = entry.getValue();
                        
                        if (mergedPropertyNamesBookings.containsKey(propertyName)) {
                            // If the property already exists in the merged map, merge its bookings
                            mergedPropertyNamesBookings.get(propertyName).addAll(bookings);
                        } else {
                            // If the property doesn't exist in the merged map, add it with its bookings
                            mergedPropertyNamesBookings.put(propertyName, new ArrayList<>(bookings));
                        }
                    }

                    System.out.println("Received property bookings from worker on port: " + port);
        	        
        	        
        	    } catch (IOException | ClassNotFoundException e) {
        	        e.printStackTrace();
        	    }
        	}
    	
    	try (PrintWriter writer = new PrintWriter(clientSocket.getOutputStream(), true)) {
            // Send the string to the client
            writer.println("These are your properties:");
            System.out.println("Sent merged properties to the client");
        } catch (IOException e) {
            e.printStackTrace();
        }
    	
    }

    private void forwardPropertySearch(String propertyId, Map<String, Object> filters) {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyId.hashCode()) % workers.size();
        Worker worker = workers.get(workerIndex);

        // Search for properties on the chosen worker
        List<Property> searchResults = worker.searchProperties(filters);

        // Print search results to the console
        System.out.println("Search results for property ID " + propertyId + ":");
        for (Property property : searchResults) {
            System.out.println(property.toString()); // Assuming Property class overrides toString() method
        }
    }


    private void forwardPropertyBooking(String renterUsername, String propertyName, DateRange bookingRange) throws IOException {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new booking...");

       String book = "BOOK";
       objectOutputStream.writeObject(book);
       objectOutputStream.writeObject(renterUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(bookingRange);

           
    }
    
    private void forwardPropertyRating(String renterUsername, String propertyName, Integer stars) throws IOException {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new rating...");

       String rate = "RATE";
       objectOutputStream.writeObject(rate);
       objectOutputStream.writeObject(renterUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(stars);

    }
    
    private void forwardPropertyFiltering(String area, DateRange dateRange, Integer people, Integer price, Integer stars) {
    	
    	ArrayList<Property> mergedFilteredProperties= new ArrayList<Property>();
    	
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    try (
    	            ObjectOutputStream objectOutputStream = new ObjectOutputStream(workerSockets.get(i).getOutputStream());
    	            ObjectInputStream objectInputStream = new ObjectInputStream(workerSockets.get(i).getInputStream())) {

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("FILTER");
    	        objectOutputStream.writeObject(area);
    	        objectOutputStream.writeObject(dateRange);
    	        objectOutputStream.writeObject(people);
    	        objectOutputStream.writeObject(price);
    	        objectOutputStream.writeObject(stars);
    	        
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> filteredProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedFilteredProperties.addAll(filteredProperties);

    	        System.out.println("Received filtered properties from worker on port: " + port);
    	        
    	        
    	    } catch (IOException | ClassNotFoundException e) {
    	        e.printStackTrace();
    	    }
    	}
    }
    
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-04-12 19:09:59.322
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-04-12 19:09:59.324
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-12 19:09:59.727
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.UnknownHostException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.imageio.ImageIO;

public class Master {
	
	private int propertyCounter;
    private List<Worker> workers;
    private Socket clientSocket;
    private ArrayList<Socket> workerSockets;
    private ArrayList<ObjectInputStream> workerInputStreams;
    private ArrayList<ObjectOutputStream> workerOutputStreams;
    
    public Master(int[] workerPorts) {
    	Socket sock=null;
    	this.propertyCounter=0;
        this.workers = new ArrayList<>();
        workerSockets=new ArrayList<>();
        workerInputStreams = new ArrayList<>();
        workerOutputStreams = new ArrayList<>();
        
        for (int port : workerPorts) {
            Worker worker = new Worker(port); // Pass the port number to the Worker constructor
			worker.start(); // Start the worker thread
			workers.add(worker);
			System.out.println("Worker connected on port: " + port);
			try {
				sock=new Socket("localhost", port);
				workerInputStreams.add(new ObjectInputStream(sock.getInputStream()));
				workerOutputStreams.add(new ObjectOutputStream(sock.getOutputStream()));
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			workerSockets.add(sock);
			
        }
        
    }


    public void start() throws IOException, ParseException, ClassNotFoundException{
//        for (Worker worker : workers) {
//            worker.start();
//        }
        // Start listening for client requests
        try (ServerSocket serverSocket = new ServerSocket(5000)) {
            System.out.println("Master server started...");
            while (true) {
                clientSocket = serverSocket.accept();
                System.out.println("A");
                handleClientRequest(clientSocket);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void handleClientRequest(Socket clientSocket) throws IOException, ParseException, ClassNotFoundException {
    	
    	String managerUsername;
    	String renterUsername;
    	String propertyName;
    	Integer stars;
    	String area;
    	DateRange dateRange;
    	Integer people;
    	Integer price;
    	
    	 try (ObjectInputStream objectInputStream = new ObjectInputStream(clientSocket.getInputStream());
    			 ObjectOutputStream objectOutputStream = new ObjectOutputStream(clientSocket.getOutputStream());
    	        ) {
    		 
    		 while (true) {
    			 System.out.println("Awaiting action command from user");
	    	     String action = (String) objectInputStream.readObject();
	//            String[] tokens = request.split(":");
	//            String action = tokens[0];
	//            String propertyId = tokens[1];
	            switch (action) {
	                case "ADD":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	readPropertyFromStream(objectInputStream);
	                    break;
	                case "SHOW":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	managerUsername = (String) objectInputStream.readObject();
	                	System.out.println("Action at worker:"+action);
	                	System.out.println(managerUsername);
	                	objectOutputStream.writeObject(showManagerProperties(managerUsername));
	                    break;
	                case "AVAILABILITY":
	                	readAvailabilityFromStream(objectInputStream);
	                    break;
	                case "BOOKINGS":
	                	managerUsername = (String) objectInputStream.readObject();
	                	showManagerBookings(managerUsername);
	                    break;
	                case "BOOK":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	DateRange bookingRange = readDateRangeFromStream(objectInputStream);
	                    forwardPropertyBooking(renterUsername, propertyName, bookingRange);
	                    break;
	                case "RATE":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                    forwardPropertyRating(renterUsername, propertyName, stars);
	                    break;
	                case "FILTER":
	                	area = (String) objectInputStream.readObject();
	                	dateRange=readDateRangeFromStream(objectInputStream);
	                	people = (Integer) objectInputStream.readObject();
	                	price = (Integer) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                	forwardPropertyFiltering(area, dateRange, people, price, stars);
	                    break;
	                // Implement cases for other request types (UPDATE, etc.) as needed
	                default:
	                    // Unknown action, send error response
	                    break;
	               }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void readPropertyFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyInfo = (String) objectInputStream.readObject();

        // Read property info
        String[] keyValuePairs = propertyInfo.substring(1, propertyInfo.length() - 1).split(",");

        String roomName = "";
        int noOfPersons = 0;
        String area = "";
        int stars = 0;
        int noOfReviews = 0;
        String roomImage = "";

        // Iterate over key-value pairs and split them based on colons
        for (String pair : keyValuePairs) {
            System.out.println(pair);
            String[] keyValue = pair.split(":");
            String key = keyValue[0].trim().replaceAll("\"", "");
            String value = keyValue[1].trim().replaceAll("\"", ""); // Remove quotes

            // Assign values to appropriate variables based on keys
            switch (key) {
                case "roomName":
                    roomName = value;
                    break;
                case "noOfPersons":
                    noOfPersons = Integer.parseInt(value);
                    break;
                case "area":
                    area = value;
                    break;
                case "stars":
                    stars = Integer.parseInt(value);
                    break;
                case "noOfReviews":
                    noOfReviews = Integer.parseInt(value);
                    break;
                case "roomImage":
                    roomImage = value;
                    break;
            }
        }
        
     // Print the values to verify
        System.out.println("Room Name: " + roomName);
        System.out.println("Number of Persons: " + noOfPersons);
        System.out.println("Area: " + area);
        System.out.println("Stars: " + stars);
        System.out.println("Number of Reviews: " + noOfReviews);
        System.out.println("Room Image: " + roomImage);

        // Read image data
        byte[] imageData = (byte[]) objectInputStream.readObject();

        // Convert byte array to BufferedImage
        ByteArrayInputStream bis = new ByteArrayInputStream(imageData);
//        BufferedImage bufferedImage = ImageIO.read(bis);
        
        forwardPropertyAddition(roomName, managerUsername ,new Property(roomName, noOfPersons, area, stars, noOfReviews, roomImage,propertyCounter), imageData);
        propertyCounter=propertyCounter+1;
        // Return property object with image
    }
    
    private void readAvailabilityFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyName = (String) objectInputStream.readObject();
        
        String dateRangeAvailability = (String) objectInputStream.readObject();
        
        forwardPropertyAvailability(managerUsername, propertyName,dateRangeAvailability);

        // Return property object with image
    }

    private Map<String, Object> readFiltersFromStream(BufferedReader reader) throws IOException {
        Map<String, Object> filters = new HashMap<>();
        
        String line;
        while ((line = reader.readLine()) != null) {
            String[] tokens = line.split(":");
            String filterName = tokens[0];
            Object filterValue = tokens[1]; // Assuming filter value is string for simplicity, you may need to parse it accordingly
            filters.put(filterName, filterValue);
        }
        
        return filters;
    }

    private DateRange readDateRangeFromStream(ObjectInputStream objectInputStream) throws IOException, ParseException, ClassNotFoundException {
    	String startDateStr = (String) objectInputStream.readObject();
        String endDateStr = (String) objectInputStream.readObject();
        // Assuming date format is in "day/month/year"
        SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
        Date startDate = dateFormat.parse(startDateStr);
        Date endDate = dateFormat.parse(endDateStr);
        return new DateRange(startDate, endDate);
    }

    private void forwardPropertyAddition(String propertyName, String managerUsername,Property property, byte [] imageBytes) throws IOException {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new property...");

       String add = "ADD";
       objectOutputStream.writeObject(add);
       System.out.println("ADD SENT");
       objectOutputStream.writeObject(managerUsername);
       objectOutputStream.writeObject(property);
       objectOutputStream.writeObject(imageBytes);

          
    }
    
    private void forwardPropertyAvailability(String managerUsername,String propertyName,String dateRangeAvailability) throws IOException {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);
        

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new availability...");

       String availability = "AVAILABILITY";
       objectOutputStream.writeObject(availability);
       objectOutputStream.writeObject(managerUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(dateRangeAvailability);

    }

    private String showManagerProperties(String managerUsername) throws IOException, ClassNotFoundException {
    	
    	ArrayList<Property> mergedProperties = new ArrayList<>();
        
    	// Iterate over worker ports
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
    	    ObjectInputStream objectInputStream = workerInputStreams.get(i);

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("SHOW");
    	        objectOutputStream.writeObject(managerUsername);
    	        System.out.println("talked to worker");
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> workerProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedProperties.addAll(workerProperties);

    	        System.out.println("Received properties from worker on port: " + port);
    	        
    	        
    	        
    	 
    	}
    	
    	String returnedPropertiesAsString="";
    	
    	System.out.println(mergedProperties.get(0));
    	
    	for (int i=0;i<mergedProperties.size();i++) {
    		returnedPropertiesAsString=returnedPropertiesAsString+mergedProperties.get(i).toString();
    	}
    	
    	return returnedPropertiesAsString;
    	
    }
    	
    	private void showManagerBookings(String managerUsername) {
        	
    		Map<String,List<DateRange>> mergedPropertyNamesBookings= new HashMap<>();
            
        	// Iterate over worker ports
        	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
        	    int port = 5000 + i; // Calculate port number
        	    
        	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
        	    ObjectInputStream objectInputStream = workerInputStreams.get(i);

        	        // Send "SHOW" request to worker
        	        objectOutputStream.writeObject("BOOKINGS");
        	        objectOutputStream.writeObject(managerUsername);
        	        
        	        // Receive ArrayList<Property> response from worker
        	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
        	        Map<String,List<DateRange>> propertyNamesBookings = (Map<String,List<DateRange>>) objectInputStream.readObject();
        	        
                    for (Map.Entry<String, List<DateRange>> entry : propertyNamesBookings.entrySet()) {
                        String propertyName = entry.getKey();
                        List<DateRange> bookings = entry.getValue();
                        
                        if (mergedPropertyNamesBookings.containsKey(propertyName)) {
                            // If the property already exists in the merged map, merge its bookings
                            mergedPropertyNamesBookings.get(propertyName).addAll(bookings);
                        } else {
                            // If the property doesn't exist in the merged map, add it with its bookings
                            mergedPropertyNamesBookings.put(propertyName, new ArrayList<>(bookings));
                        }
                    }

                    System.out.println("Received property bookings from worker on port: " + port);
        	        
        	        
        	    } catch (IOException | ClassNotFoundException e) {
        	        e.printStackTrace();
        	    }
        	}
    	
    	try (PrintWriter writer = new PrintWriter(clientSocket.getOutputStream(), true)) {
            // Send the string to the client
            writer.println("These are your properties:");
            System.out.println("Sent merged properties to the client");
        } catch (IOException e) {
            e.printStackTrace();
        }
    	
    }

    private void forwardPropertySearch(String propertyId, Map<String, Object> filters) {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyId.hashCode()) % workers.size();
        Worker worker = workers.get(workerIndex);

        // Search for properties on the chosen worker
        List<Property> searchResults = worker.searchProperties(filters);

        // Print search results to the console
        System.out.println("Search results for property ID " + propertyId + ":");
        for (Property property : searchResults) {
            System.out.println(property.toString()); // Assuming Property class overrides toString() method
        }
    }


    private void forwardPropertyBooking(String renterUsername, String propertyName, DateRange bookingRange) throws IOException {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new booking...");

       String book = "BOOK";
       objectOutputStream.writeObject(book);
       objectOutputStream.writeObject(renterUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(bookingRange);

           
    }
    
    private void forwardPropertyRating(String renterUsername, String propertyName, Integer stars) throws IOException {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new rating...");

       String rate = "RATE";
       objectOutputStream.writeObject(rate);
       objectOutputStream.writeObject(renterUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(stars);

    }
    
    private void forwardPropertyFiltering(String area, DateRange dateRange, Integer people, Integer price, Integer stars) {
    	
    	ArrayList<Property> mergedFilteredProperties= new ArrayList<Property>();
    	
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    try (
    	            ObjectOutputStream objectOutputStream = new ObjectOutputStream(workerSockets.get(i).getOutputStream());
    	            ObjectInputStream objectInputStream = new ObjectInputStream(workerSockets.get(i).getInputStream())) {

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("FILTER");
    	        objectOutputStream.writeObject(area);
    	        objectOutputStream.writeObject(dateRange);
    	        objectOutputStream.writeObject(people);
    	        objectOutputStream.writeObject(price);
    	        objectOutputStream.writeObject(stars);
    	        
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> filteredProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedFilteredProperties.addAll(filteredProperties);

    	        System.out.println("Received filtered properties from worker on port: " + port);
    	        
    	        
    	    } catch (IOException | ClassNotFoundException e) {
    	        e.printStackTrace();
    	    }
    	}
    }
    
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-04-12 19:09:59.731
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-04-12 19:09:59.732
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-12 19:09:59.808
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.UnknownHostException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.imageio.ImageIO;

public class Master {
	
	private int propertyCounter;
    private List<Worker> workers;
    private Socket clientSocket;
    private ArrayList<Socket> workerSockets;
    private ArrayList<ObjectInputStream> workerInputStreams;
    private ArrayList<ObjectOutputStream> workerOutputStreams;
    
    public Master(int[] workerPorts) {
    	Socket sock=null;
    	this.propertyCounter=0;
        this.workers = new ArrayList<>();
        workerSockets=new ArrayList<>();
        workerInputStreams = new ArrayList<>();
        workerOutputStreams = new ArrayList<>();
        
        for (int port : workerPorts) {
            Worker worker = new Worker(port); // Pass the port number to the Worker constructor
			worker.start(); // Start the worker thread
			workers.add(worker);
			System.out.println("Worker connected on port: " + port);
			try {
				sock=new Socket("localhost", port);
				workerInputStreams.add(new ObjectInputStream(sock.getInputStream()));
				workerOutputStreams.add(new ObjectOutputStream(sock.getOutputStream()));
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			workerSockets.add(sock);
			
        }
        
    }


    public void start() throws IOException, ParseException, ClassNotFoundException{
//        for (Worker worker : workers) {
//            worker.start();
//        }
        // Start listening for client requests
        try (ServerSocket serverSocket = new ServerSocket(5000)) {
            System.out.println("Master server started...");
            while (true) {
                clientSocket = serverSocket.accept();
                System.out.println("A");
                handleClientRequest(clientSocket);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void handleClientRequest(Socket clientSocket) throws IOException, ParseException, ClassNotFoundException {
    	
    	String managerUsername;
    	String renterUsername;
    	String propertyName;
    	Integer stars;
    	String area;
    	DateRange dateRange;
    	Integer people;
    	Integer price;
    	
    	 try (ObjectInputStream objectInputStream = new ObjectInputStream(clientSocket.getInputStream());
    			 ObjectOutputStream objectOutputStream = new ObjectOutputStream(clientSocket.getOutputStream());
    	        ) {
    		 
    		 while (true) {
    			 System.out.println("Awaiting action command from user");
	    	     String action = (String) objectInputStream.readObject();
	//            String[] tokens = request.split(":");
	//            String action = tokens[0];
	//            String propertyId = tokens[1];
	            switch (action) {
	                case "ADD":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	readPropertyFromStream(objectInputStream);
	                    break;
	                case "SHOW":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	managerUsername = (String) objectInputStream.readObject();
	                	System.out.println("Action at worker:"+action);
	                	System.out.println(managerUsername);
	                	objectOutputStream.writeObject(showManagerProperties(managerUsername));
	                    break;
	                case "AVAILABILITY":
	                	readAvailabilityFromStream(objectInputStream);
	                    break;
	                case "BOOKINGS":
	                	managerUsername = (String) objectInputStream.readObject();
	                	showManagerBookings(managerUsername);
	                    break;
	                case "BOOK":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	DateRange bookingRange = readDateRangeFromStream(objectInputStream);
	                    forwardPropertyBooking(renterUsername, propertyName, bookingRange);
	                    break;
	                case "RATE":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                    forwardPropertyRating(renterUsername, propertyName, stars);
	                    break;
	                case "FILTER":
	                	area = (String) objectInputStream.readObject();
	                	dateRange=readDateRangeFromStream(objectInputStream);
	                	people = (Integer) objectInputStream.readObject();
	                	price = (Integer) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                	forwardPropertyFiltering(area, dateRange, people, price, stars);
	                    break;
	                // Implement cases for other request types (UPDATE, etc.) as needed
	                default:
	                    // Unknown action, send error response
	                    break;
	               }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void readPropertyFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyInfo = (String) objectInputStream.readObject();

        // Read property info
        String[] keyValuePairs = propertyInfo.substring(1, propertyInfo.length() - 1).split(",");

        String roomName = "";
        int noOfPersons = 0;
        String area = "";
        int stars = 0;
        int noOfReviews = 0;
        String roomImage = "";

        // Iterate over key-value pairs and split them based on colons
        for (String pair : keyValuePairs) {
            System.out.println(pair);
            String[] keyValue = pair.split(":");
            String key = keyValue[0].trim().replaceAll("\"", "");
            String value = keyValue[1].trim().replaceAll("\"", ""); // Remove quotes

            // Assign values to appropriate variables based on keys
            switch (key) {
                case "roomName":
                    roomName = value;
                    break;
                case "noOfPersons":
                    noOfPersons = Integer.parseInt(value);
                    break;
                case "area":
                    area = value;
                    break;
                case "stars":
                    stars = Integer.parseInt(value);
                    break;
                case "noOfReviews":
                    noOfReviews = Integer.parseInt(value);
                    break;
                case "roomImage":
                    roomImage = value;
                    break;
            }
        }
        
     // Print the values to verify
        System.out.println("Room Name: " + roomName);
        System.out.println("Number of Persons: " + noOfPersons);
        System.out.println("Area: " + area);
        System.out.println("Stars: " + stars);
        System.out.println("Number of Reviews: " + noOfReviews);
        System.out.println("Room Image: " + roomImage);

        // Read image data
        byte[] imageData = (byte[]) objectInputStream.readObject();

        // Convert byte array to BufferedImage
        ByteArrayInputStream bis = new ByteArrayInputStream(imageData);
//        BufferedImage bufferedImage = ImageIO.read(bis);
        
        forwardPropertyAddition(roomName, managerUsername ,new Property(roomName, noOfPersons, area, stars, noOfReviews, roomImage,propertyCounter), imageData);
        propertyCounter=propertyCounter+1;
        // Return property object with image
    }
    
    private void readAvailabilityFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyName = (String) objectInputStream.readObject();
        
        String dateRangeAvailability = (String) objectInputStream.readObject();
        
        forwardPropertyAvailability(managerUsername, propertyName,dateRangeAvailability);

        // Return property object with image
    }

    private Map<String, Object> readFiltersFromStream(BufferedReader reader) throws IOException {
        Map<String, Object> filters = new HashMap<>();
        
        String line;
        while ((line = reader.readLine()) != null) {
            String[] tokens = line.split(":");
            String filterName = tokens[0];
            Object filterValue = tokens[1]; // Assuming filter value is string for simplicity, you may need to parse it accordingly
            filters.put(filterName, filterValue);
        }
        
        return filters;
    }

    private DateRange readDateRangeFromStream(ObjectInputStream objectInputStream) throws IOException, ParseException, ClassNotFoundException {
    	String startDateStr = (String) objectInputStream.readObject();
        String endDateStr = (String) objectInputStream.readObject();
        // Assuming date format is in "day/month/year"
        SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
        Date startDate = dateFormat.parse(startDateStr);
        Date endDate = dateFormat.parse(endDateStr);
        return new DateRange(startDate, endDate);
    }

    private void forwardPropertyAddition(String propertyName, String managerUsername,Property property, byte [] imageBytes) throws IOException {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new property...");

       String add = "ADD";
       objectOutputStream.writeObject(add);
       System.out.println("ADD SENT");
       objectOutputStream.writeObject(managerUsername);
       objectOutputStream.writeObject(property);
       objectOutputStream.writeObject(imageBytes);

          
    }
    
    private void forwardPropertyAvailability(String managerUsername,String propertyName,String dateRangeAvailability) throws IOException {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);
        

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new availability...");

       String availability = "AVAILABILITY";
       objectOutputStream.writeObject(availability);
       objectOutputStream.writeObject(managerUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(dateRangeAvailability);

    }

    private String showManagerProperties(String managerUsername) throws IOException, ClassNotFoundException {
    	
    	ArrayList<Property> mergedProperties = new ArrayList<>();
        
    	// Iterate over worker ports
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
    	    ObjectInputStream objectInputStream = workerInputStreams.get(i);

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("SHOW");
    	        objectOutputStream.writeObject(managerUsername);
    	        System.out.println("talked to worker");
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> workerProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedProperties.addAll(workerProperties);

    	        System.out.println("Received properties from worker on port: " + port);
    	        
    	        
    	        
    	 
    	}
    	
    	String returnedPropertiesAsString="";
    	
    	System.out.println(mergedProperties.get(0));
    	
    	for (int i=0;i<mergedProperties.size();i++) {
    		returnedPropertiesAsString=returnedPropertiesAsString+mergedProperties.get(i).toString();
    	}
    	
    	return returnedPropertiesAsString;
    	
    }
    	
    	private void showManagerBookings(String managerUsername) {
        	
    		Map<String,List<DateRange>> mergedPropertyNamesBookings= new HashMap<>();
            
        	// Iterate over worker ports
        	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
        	    int port = 5000 + i; // Calculate port number
        	    
        	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
        	    ObjectInputStream objectInputStream = workerInputStreams.get(i);

        	        // Send "SHOW" request to worker
        	        objectOutputStream.writeObject("BOOKINGS");
        	        objectOutputStream.writeObject(managerUsername);
        	        
        	        // Receive ArrayList<Property> response from worker
        	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
        	        Map<String,List<DateRange>> propertyNamesBookings = (Map<String,List<DateRange>>) objectInputStream.readObject();
        	        
                    for (Map.Entry<String, List<DateRange>> entry : propertyNamesBookings.entrySet()) {
                        String propertyName = entry.getKey();
                        List<DateRange> bookings = entry.getValue();
                        
                        if (mergedPropertyNamesBookings.containsKey(propertyName)) {
                            // If the property already exists in the merged map, merge its bookings
                            mergedPropertyNamesBookings.get(propertyName).addAll(bookings);
                        } else {
                            // If the property doesn't exist in the merged map, add it with its bookings
                            mergedPropertyNamesBookings.put(propertyName, new ArrayList<>(bookings));
                        }
                    }

                    System.out.println("Received property bookings from worker on port: " + port);
        	        
        	        
        	    } catch (IOException | ClassNotFoundException e) {
        	        e.printStackTrace();
        	    }
        	}
    	
    	try (PrintWriter writer = new PrintWriter(clientSocket.getOutputStream(), true)) {
            // Send the string to the client
            writer.println("These are your properties:");
            System.out.println("Sent merged properties to the client");
        } catch (IOException e) {
            e.printStackTrace();
        }
    	
    }

    private void forwardPropertySearch(String propertyId, Map<String, Object> filters) {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyId.hashCode()) % workers.size();
        Worker worker = workers.get(workerIndex);

        // Search for properties on the chosen worker
        List<Property> searchResults = worker.searchProperties(filters);

        // Print search results to the console
        System.out.println("Search results for property ID " + propertyId + ":");
        for (Property property : searchResults) {
            System.out.println(property.toString()); // Assuming Property class overrides toString() method
        }
    }


    private void forwardPropertyBooking(String renterUsername, String propertyName, DateRange bookingRange) throws IOException {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new booking...");

       String book = "BOOK";
       objectOutputStream.writeObject(book);
       objectOutputStream.writeObject(renterUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(bookingRange);

           
    }
    
    private void forwardPropertyRating(String renterUsername, String propertyName, Integer stars) throws IOException {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new rating...");

       String rate = "RATE";
       objectOutputStream.writeObject(rate);
       objectOutputStream.writeObject(renterUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(stars);

    }
    
    private void forwardPropertyFiltering(String area, DateRange dateRange, Integer people, Integer price, Integer stars) {
    	
    	ArrayList<Property> mergedFilteredProperties= new ArrayList<Property>();
    	
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    try (
    	            ObjectOutputStream objectOutputStream = new ObjectOutputStream(workerSockets.get(i).getOutputStream());
    	            ObjectInputStream objectInputStream = new ObjectInputStream(workerSockets.get(i).getInputStream())) {

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("FILTER");
    	        objectOutputStream.writeObject(area);
    	        objectOutputStream.writeObject(dateRange);
    	        objectOutputStream.writeObject(people);
    	        objectOutputStream.writeObject(price);
    	        objectOutputStream.writeObject(stars);
    	        
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> filteredProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedFilteredProperties.addAll(filteredProperties);

    	        System.out.println("Received filtered properties from worker on port: " + port);
    	        
    	        
    	    } catch (IOException | ClassNotFoundException e) {
    	        e.printStackTrace();
    	    }
    	}
    }
    
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-04-12 19:09:59.811
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-04-12 19:09:59.812
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-12 19:10:00.460
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.UnknownHostException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.imageio.ImageIO;

public class Master {
	
	private int propertyCounter;
    private List<Worker> workers;
    private Socket clientSocket;
    private ArrayList<Socket> workerSockets;
    private ArrayList<ObjectInputStream> workerInputStreams;
    private ArrayList<ObjectOutputStream> workerOutputStreams;
    
    public Master(int[] workerPorts) {
    	Socket sock=null;
    	this.propertyCounter=0;
        this.workers = new ArrayList<>();
        workerSockets=new ArrayList<>();
        workerInputStreams = new ArrayList<>();
        workerOutputStreams = new ArrayList<>();
        
        for (int port : workerPorts) {
            Worker worker = new Worker(port); // Pass the port number to the Worker constructor
			worker.start(); // Start the worker thread
			workers.add(worker);
			System.out.println("Worker connected on port: " + port);
			try {
				sock=new Socket("localhost", port);
				workerInputStreams.add(new ObjectInputStream(sock.getInputStream()));
				workerOutputStreams.add(new ObjectOutputStream(sock.getOutputStream()));
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			workerSockets.add(sock);
			
        }
        
    }


    public void start() throws IOException, ParseException, ClassNotFoundException{
//        for (Worker worker : workers) {
//            worker.start();
//        }
        // Start listening for client requests
        try (ServerSocket serverSocket = new ServerSocket(5000)) {
            System.out.println("Master server started...");
            while (true) {
                clientSocket = serverSocket.accept();
                System.out.println("A");
                handleClientRequest(clientSocket);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void handleClientRequest(Socket clientSocket) throws IOException, ParseException, ClassNotFoundException {
    	
    	String managerUsername;
    	String renterUsername;
    	String propertyName;
    	Integer stars;
    	String area;
    	DateRange dateRange;
    	Integer people;
    	Integer price;
    	
    	 try (ObjectInputStream objectInputStream = new ObjectInputStream(clientSocket.getInputStream());
    			 ObjectOutputStream objectOutputStream = new ObjectOutputStream(clientSocket.getOutputStream());
    	        ) {
    		 
    		 while (true) {
    			 System.out.println("Awaiting action command from user");
	    	     String action = (String) objectInputStream.readObject();
	//            String[] tokens = request.split(":");
	//            String action = tokens[0];
	//            String propertyId = tokens[1];
	            switch (action) {
	                case "ADD":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	readPropertyFromStream(objectInputStream);
	                    break;
	                case "SHOW":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	managerUsername = (String) objectInputStream.readObject();
	                	System.out.println("Action at worker:"+action);
	                	System.out.println(managerUsername);
	                	objectOutputStream.writeObject(showManagerProperties(managerUsername));
	                    break;
	                case "AVAILABILITY":
	                	readAvailabilityFromStream(objectInputStream);
	                    break;
	                case "BOOKINGS":
	                	managerUsername = (String) objectInputStream.readObject();
	                	showManagerBookings(managerUsername);
	                    break;
	                case "BOOK":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	DateRange bookingRange = readDateRangeFromStream(objectInputStream);
	                    forwardPropertyBooking(renterUsername, propertyName, bookingRange);
	                    break;
	                case "RATE":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                    forwardPropertyRating(renterUsername, propertyName, stars);
	                    break;
	                case "FILTER":
	                	area = (String) objectInputStream.readObject();
	                	dateRange=readDateRangeFromStream(objectInputStream);
	                	people = (Integer) objectInputStream.readObject();
	                	price = (Integer) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                	forwardPropertyFiltering(area, dateRange, people, price, stars);
	                    break;
	                // Implement cases for other request types (UPDATE, etc.) as needed
	                default:
	                    // Unknown action, send error response
	                    break;
	               }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void readPropertyFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyInfo = (String) objectInputStream.readObject();

        // Read property info
        String[] keyValuePairs = propertyInfo.substring(1, propertyInfo.length() - 1).split(",");

        String roomName = "";
        int noOfPersons = 0;
        String area = "";
        int stars = 0;
        int noOfReviews = 0;
        String roomImage = "";

        // Iterate over key-value pairs and split them based on colons
        for (String pair : keyValuePairs) {
            System.out.println(pair);
            String[] keyValue = pair.split(":");
            String key = keyValue[0].trim().replaceAll("\"", "");
            String value = keyValue[1].trim().replaceAll("\"", ""); // Remove quotes

            // Assign values to appropriate variables based on keys
            switch (key) {
                case "roomName":
                    roomName = value;
                    break;
                case "noOfPersons":
                    noOfPersons = Integer.parseInt(value);
                    break;
                case "area":
                    area = value;
                    break;
                case "stars":
                    stars = Integer.parseInt(value);
                    break;
                case "noOfReviews":
                    noOfReviews = Integer.parseInt(value);
                    break;
                case "roomImage":
                    roomImage = value;
                    break;
            }
        }
        
     // Print the values to verify
        System.out.println("Room Name: " + roomName);
        System.out.println("Number of Persons: " + noOfPersons);
        System.out.println("Area: " + area);
        System.out.println("Stars: " + stars);
        System.out.println("Number of Reviews: " + noOfReviews);
        System.out.println("Room Image: " + roomImage);

        // Read image data
        byte[] imageData = (byte[]) objectInputStream.readObject();

        // Convert byte array to BufferedImage
        ByteArrayInputStream bis = new ByteArrayInputStream(imageData);
//        BufferedImage bufferedImage = ImageIO.read(bis);
        
        forwardPropertyAddition(roomName, managerUsername ,new Property(roomName, noOfPersons, area, stars, noOfReviews, roomImage,propertyCounter), imageData);
        propertyCounter=propertyCounter+1;
        // Return property object with image
    }
    
    private void readAvailabilityFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyName = (String) objectInputStream.readObject();
        
        String dateRangeAvailability = (String) objectInputStream.readObject();
        
        forwardPropertyAvailability(managerUsername, propertyName,dateRangeAvailability);

        // Return property object with image
    }

    private Map<String, Object> readFiltersFromStream(BufferedReader reader) throws IOException {
        Map<String, Object> filters = new HashMap<>();
        
        String line;
        while ((line = reader.readLine()) != null) {
            String[] tokens = line.split(":");
            String filterName = tokens[0];
            Object filterValue = tokens[1]; // Assuming filter value is string for simplicity, you may need to parse it accordingly
            filters.put(filterName, filterValue);
        }
        
        return filters;
    }

    private DateRange readDateRangeFromStream(ObjectInputStream objectInputStream) throws IOException, ParseException, ClassNotFoundException {
    	String startDateStr = (String) objectInputStream.readObject();
        String endDateStr = (String) objectInputStream.readObject();
        // Assuming date format is in "day/month/year"
        SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
        Date startDate = dateFormat.parse(startDateStr);
        Date endDate = dateFormat.parse(endDateStr);
        return new DateRange(startDate, endDate);
    }

    private void forwardPropertyAddition(String propertyName, String managerUsername,Property property, byte [] imageBytes) throws IOException {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new property...");

       String add = "ADD";
       objectOutputStream.writeObject(add);
       System.out.println("ADD SENT");
       objectOutputStream.writeObject(managerUsername);
       objectOutputStream.writeObject(property);
       objectOutputStream.writeObject(imageBytes);

          
    }
    
    private void forwardPropertyAvailability(String managerUsername,String propertyName,String dateRangeAvailability) throws IOException {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);
        

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new availability...");

       String availability = "AVAILABILITY";
       objectOutputStream.writeObject(availability);
       objectOutputStream.writeObject(managerUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(dateRangeAvailability);

    }

    private String showManagerProperties(String managerUsername) throws IOException, ClassNotFoundException {
    	
    	ArrayList<Property> mergedProperties = new ArrayList<>();
        
    	// Iterate over worker ports
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
    	    ObjectInputStream objectInputStream = workerInputStreams.get(i);

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("SHOW");
    	        objectOutputStream.writeObject(managerUsername);
    	        System.out.println("talked to worker");
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> workerProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedProperties.addAll(workerProperties);

    	        System.out.println("Received properties from worker on port: " + port);
    	        
    	        
    	        
    	 
    	}
    	
    	String returnedPropertiesAsString="";
    	
    	System.out.println(mergedProperties.get(0));
    	
    	for (int i=0;i<mergedProperties.size();i++) {
    		returnedPropertiesAsString=returnedPropertiesAsString+mergedProperties.get(i).toString();
    	}
    	
    	return returnedPropertiesAsString;
    	
    }
    	
    	private void showManagerBookings(String managerUsername) {
        	
    		Map<String,List<DateRange>> mergedPropertyNamesBookings= new HashMap<>();
            
        	// Iterate over worker ports
        	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
        	    int port = 5000 + i; // Calculate port number
        	    
        	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
        	    ObjectInputStream objectInputStream = workerInputStreams.get(i);

        	        // Send "SHOW" request to worker
        	        objectOutputStream.writeObject("BOOKINGS");
        	        objectOutputStream.writeObject(managerUsername);
        	        
        	        // Receive ArrayList<Property> response from worker
        	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
        	        Map<String,List<DateRange>> propertyNamesBookings = (Map<String,List<DateRange>>) objectInputStream.readObject();
        	        
                    for (Map.Entry<String, List<DateRange>> entry : propertyNamesBookings.entrySet()) {
                        String propertyName = entry.getKey();
                        List<DateRange> bookings = entry.getValue();
                        
                        if (mergedPropertyNamesBookings.containsKey(propertyName)) {
                            // If the property already exists in the merged map, merge its bookings
                            mergedPropertyNamesBookings.get(propertyName).addAll(bookings);
                        } else {
                            // If the property doesn't exist in the merged map, add it with its bookings
                            mergedPropertyNamesBookings.put(propertyName, new ArrayList<>(bookings));
                        }
                    }

                    System.out.println("Received property bookings from worker on port: " + port);
        	        
        	        
        	    } catch (IOException | ClassNotFoundException e) {
        	        e.printStackTrace();
        	    }
        	}
    	
    	try (PrintWriter writer = new PrintWriter(clientSocket.getOutputStream(), true)) {
            // Send the string to the client
            writer.println("These are your properties:");
            System.out.println("Sent merged properties to the client");
        } catch (IOException e) {
            e.printStackTrace();
        }
    	
    }

    private void forwardPropertySearch(String propertyId, Map<String, Object> filters) {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyId.hashCode()) % workers.size();
        Worker worker = workers.get(workerIndex);

        // Search for properties on the chosen worker
        List<Property> searchResults = worker.searchProperties(filters);

        // Print search results to the console
        System.out.println("Search results for property ID " + propertyId + ":");
        for (Property property : searchResults) {
            System.out.println(property.toString()); // Assuming Property class overrides toString() method
        }
    }


    private void forwardPropertyBooking(String renterUsername, String propertyName, DateRange bookingRange) throws IOException {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new booking...");

       String book = "BOOK";
       objectOutputStream.writeObject(book);
       objectOutputStream.writeObject(renterUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(bookingRange);

           
    }
    
    private void forwardPropertyRating(String renterUsername, String propertyName, Integer stars) throws IOException {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new rating...");

       String rate = "RATE";
       objectOutputStream.writeObject(rate);
       objectOutputStream.writeObject(renterUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(stars);

    }
    
    private void forwardPropertyFiltering(String area, DateRange dateRange, Integer people, Integer price, Integer stars) {
    	
    	ArrayList<Property> mergedFilteredProperties= new ArrayList<Property>();
    	
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    try (
    	            ObjectOutputStream objectOutputStream = new ObjectOutputStream(workerSockets.get(i).getOutputStream());
    	            ObjectInputStream objectInputStream = new ObjectInputStream(workerSockets.get(i).getInputStream())) {

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("FILTER");
    	        objectOutputStream.writeObject(area);
    	        objectOutputStream.writeObject(dateRange);
    	        objectOutputStream.writeObject(people);
    	        objectOutputStream.writeObject(price);
    	        objectOutputStream.writeObject(stars);
    	        
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> filteredProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedFilteredProperties.addAll(filteredProperties);

    	        System.out.println("Received filtered properties from worker on port: " + port);
    	        
    	        
    	    } catch (IOException | ClassNotFoundException e) {
    	        e.printStackTrace();
    	    }
    	}
    }
    
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-04-12 19:10:00.466
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-04-12 19:10:00.467
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-12 19:10:01.003
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.UnknownHostException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.imageio.ImageIO;

public class Master {
	
	private int propertyCounter;
    private List<Worker> workers;
    private Socket clientSocket;
    private ArrayList<Socket> workerSockets;
    private ArrayList<ObjectInputStream> workerInputStreams;
    private ArrayList<ObjectOutputStream> workerOutputStreams;
    
    public Master(int[] workerPorts) {
    	Socket sock=null;
    	this.propertyCounter=0;
        this.workers = new ArrayList<>();
        workerSockets=new ArrayList<>();
        workerInputStreams = new ArrayList<>();
        workerOutputStreams = new ArrayList<>();
        
        for (int port : workerPorts) {
            Worker worker = new Worker(port); // Pass the port number to the Worker constructor
			worker.start(); // Start the worker thread
			workers.add(worker);
			System.out.println("Worker connected on port: " + port);
			try {
				sock=new Socket("localhost", port);
				workerInputStreams.add(new ObjectInputStream(sock.getInputStream()));
				workerOutputStreams.add(new ObjectOutputStream(sock.getOutputStream()));
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			workerSockets.add(sock);
			
        }
        
    }


    public void start() throws IOException, ParseException, ClassNotFoundException{
//        for (Worker worker : workers) {
//            worker.start();
//        }
        // Start listening for client requests
        try (ServerSocket serverSocket = new ServerSocket(5000)) {
            System.out.println("Master server started...");
            while (true) {
                clientSocket = serverSocket.accept();
                System.out.println("A");
                handleClientRequest(clientSocket);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void handleClientRequest(Socket clientSocket) throws IOException, ParseException, ClassNotFoundException {
    	
    	String managerUsername;
    	String renterUsername;
    	String propertyName;
    	Integer stars;
    	String area;
    	DateRange dateRange;
    	Integer people;
    	Integer price;
    	
    	 try (ObjectInputStream objectInputStream = new ObjectInputStream(clientSocket.getInputStream());
    			 ObjectOutputStream objectOutputStream = new ObjectOutputStream(clientSocket.getOutputStream());
    	        ) {
    		 
    		 while (true) {
    			 System.out.println("Awaiting action command from user");
	    	     String action = (String) objectInputStream.readObject();
	//            String[] tokens = request.split(":");
	//            String action = tokens[0];
	//            String propertyId = tokens[1];
	            switch (action) {
	                case "ADD":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	readPropertyFromStream(objectInputStream);
	                    break;
	                case "SHOW":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	managerUsername = (String) objectInputStream.readObject();
	                	System.out.println("Action at worker:"+action);
	                	System.out.println(managerUsername);
	                	objectOutputStream.writeObject(showManagerProperties(managerUsername));
	                    break;
	                case "AVAILABILITY":
	                	readAvailabilityFromStream(objectInputStream);
	                    break;
	                case "BOOKINGS":
	                	managerUsername = (String) objectInputStream.readObject();
	                	showManagerBookings(managerUsername);
	                    break;
	                case "BOOK":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	DateRange bookingRange = readDateRangeFromStream(objectInputStream);
	                    forwardPropertyBooking(renterUsername, propertyName, bookingRange);
	                    break;
	                case "RATE":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                    forwardPropertyRating(renterUsername, propertyName, stars);
	                    break;
	                case "FILTER":
	                	area = (String) objectInputStream.readObject();
	                	dateRange=readDateRangeFromStream(objectInputStream);
	                	people = (Integer) objectInputStream.readObject();
	                	price = (Integer) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                	forwardPropertyFiltering(area, dateRange, people, price, stars);
	                    break;
	                // Implement cases for other request types (UPDATE, etc.) as needed
	                default:
	                    // Unknown action, send error response
	                    break;
	               }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void readPropertyFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyInfo = (String) objectInputStream.readObject();

        // Read property info
        String[] keyValuePairs = propertyInfo.substring(1, propertyInfo.length() - 1).split(",");

        String roomName = "";
        int noOfPersons = 0;
        String area = "";
        int stars = 0;
        int noOfReviews = 0;
        String roomImage = "";

        // Iterate over key-value pairs and split them based on colons
        for (String pair : keyValuePairs) {
            System.out.println(pair);
            String[] keyValue = pair.split(":");
            String key = keyValue[0].trim().replaceAll("\"", "");
            String value = keyValue[1].trim().replaceAll("\"", ""); // Remove quotes

            // Assign values to appropriate variables based on keys
            switch (key) {
                case "roomName":
                    roomName = value;
                    break;
                case "noOfPersons":
                    noOfPersons = Integer.parseInt(value);
                    break;
                case "area":
                    area = value;
                    break;
                case "stars":
                    stars = Integer.parseInt(value);
                    break;
                case "noOfReviews":
                    noOfReviews = Integer.parseInt(value);
                    break;
                case "roomImage":
                    roomImage = value;
                    break;
            }
        }
        
     // Print the values to verify
        System.out.println("Room Name: " + roomName);
        System.out.println("Number of Persons: " + noOfPersons);
        System.out.println("Area: " + area);
        System.out.println("Stars: " + stars);
        System.out.println("Number of Reviews: " + noOfReviews);
        System.out.println("Room Image: " + roomImage);

        // Read image data
        byte[] imageData = (byte[]) objectInputStream.readObject();

        // Convert byte array to BufferedImage
        ByteArrayInputStream bis = new ByteArrayInputStream(imageData);
//        BufferedImage bufferedImage = ImageIO.read(bis);
        
        forwardPropertyAddition(roomName, managerUsername ,new Property(roomName, noOfPersons, area, stars, noOfReviews, roomImage,propertyCounter), imageData);
        propertyCounter=propertyCounter+1;
        // Return property object with image
    }
    
    private void readAvailabilityFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyName = (String) objectInputStream.readObject();
        
        String dateRangeAvailability = (String) objectInputStream.readObject();
        
        forwardPropertyAvailability(managerUsername, propertyName,dateRangeAvailability);

        // Return property object with image
    }

    private Map<String, Object> readFiltersFromStream(BufferedReader reader) throws IOException {
        Map<String, Object> filters = new HashMap<>();
        
        String line;
        while ((line = reader.readLine()) != null) {
            String[] tokens = line.split(":");
            String filterName = tokens[0];
            Object filterValue = tokens[1]; // Assuming filter value is string for simplicity, you may need to parse it accordingly
            filters.put(filterName, filterValue);
        }
        
        return filters;
    }

    private DateRange readDateRangeFromStream(ObjectInputStream objectInputStream) throws IOException, ParseException, ClassNotFoundException {
    	String startDateStr = (String) objectInputStream.readObject();
        String endDateStr = (String) objectInputStream.readObject();
        // Assuming date format is in "day/month/year"
        SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
        Date startDate = dateFormat.parse(startDateStr);
        Date endDate = dateFormat.parse(endDateStr);
        return new DateRange(startDate, endDate);
    }

    private void forwardPropertyAddition(String propertyName, String managerUsername,Property property, byte [] imageBytes) throws IOException {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new property...");

       String add = "ADD";
       objectOutputStream.writeObject(add);
       System.out.println("ADD SENT");
       objectOutputStream.writeObject(managerUsername);
       objectOutputStream.writeObject(property);
       objectOutputStream.writeObject(imageBytes);

          
    }
    
    private void forwardPropertyAvailability(String managerUsername,String propertyName,String dateRangeAvailability) throws IOException {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);
        

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new availability...");

       String availability = "AVAILABILITY";
       objectOutputStream.writeObject(availability);
       objectOutputStream.writeObject(managerUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(dateRangeAvailability);

    }

    private String showManagerProperties(String managerUsername) throws IOException, ClassNotFoundException {
    	
    	ArrayList<Property> mergedProperties = new ArrayList<>();
        
    	// Iterate over worker ports
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
    	    ObjectInputStream objectInputStream = workerInputStreams.get(i);

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("SHOW");
    	        objectOutputStream.writeObject(managerUsername);
    	        System.out.println("talked to worker");
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> workerProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedProperties.addAll(workerProperties);

    	        System.out.println("Received properties from worker on port: " + port);
    	        
    	        
    	        
    	 
    	}
    	
    	String returnedPropertiesAsString="";
    	
    	System.out.println(mergedProperties.get(0));
    	
    	for (int i=0;i<mergedProperties.size();i++) {
    		returnedPropertiesAsString=returnedPropertiesAsString+mergedProperties.get(i).toString();
    	}
    	
    	return returnedPropertiesAsString;
    	
    }
    	
    	private void showManagerBookings(String managerUsername) {
        	
    		Map<String,List<DateRange>> mergedPropertyNamesBookings= new HashMap<>();
            
        	// Iterate over worker ports
        	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
        	    int port = 5000 + i; // Calculate port number
        	    
        	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
        	    ObjectInputStream objectInputStream = workerInputStreams.get(i);

        	        // Send "SHOW" request to worker
        	        objectOutputStream.writeObject("BOOKINGS");
        	        objectOutputStream.writeObject(managerUsername);
        	        
        	        // Receive ArrayList<Property> response from worker
        	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
        	        Map<String,List<DateRange>> propertyNamesBookings = (Map<String,List<DateRange>>) objectInputStream.readObject();
        	        
                    for (Map.Entry<String, List<DateRange>> entry : propertyNamesBookings.entrySet()) {
                        String propertyName = entry.getKey();
                        List<DateRange> bookings = entry.getValue();
                        
                        if (mergedPropertyNamesBookings.containsKey(propertyName)) {
                            // If the property already exists in the merged map, merge its bookings
                            mergedPropertyNamesBookings.get(propertyName).addAll(bookings);
                        } else {
                            // If the property doesn't exist in the merged map, add it with its bookings
                            mergedPropertyNamesBookings.put(propertyName, new ArrayList<>(bookings));
                        }
                    }

                    System.out.println("Received property bookings from worker on port: " + port);
        	        
        	        
        	    } catch (IOException | ClassNotFoundException e) {
        	        e.printStackTrace();
        	    }
        	}
    	
    	try (PrintWriter writer = new PrintWriter(clientSocket.getOutputStream(), true)) {
            // Send the string to the client
            writer.println("These are your properties:");
            System.out.println("Sent merged properties to the client");
        } catch (IOException e) {
            e.printStackTrace();
        }
    	
    }

    private void forwardPropertySearch(String propertyId, Map<String, Object> filters) {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyId.hashCode()) % workers.size();
        Worker worker = workers.get(workerIndex);

        // Search for properties on the chosen worker
        List<Property> searchResults = worker.searchProperties(filters);

        // Print search results to the console
        System.out.println("Search results for property ID " + propertyId + ":");
        for (Property property : searchResults) {
            System.out.println(property.toString()); // Assuming Property class overrides toString() method
        }
    }


    private void forwardPropertyBooking(String renterUsername, String propertyName, DateRange bookingRange) throws IOException {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new booking...");

       String book = "BOOK";
       objectOutputStream.writeObject(book);
       objectOutputStream.writeObject(renterUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(bookingRange);

           
    }
    
    private void forwardPropertyRating(String renterUsername, String propertyName, Integer stars) throws IOException {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new rating...");

       String rate = "RATE";
       objectOutputStream.writeObject(rate);
       objectOutputStream.writeObject(renterUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(stars);

    }
    
    private void forwardPropertyFiltering(String area, DateRange dateRange, Integer people, Integer price, Integer stars) {
    	
    	ArrayList<Property> mergedFilteredProperties= new ArrayList<Property>();
    	
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    try (
    	            ObjectOutputStream objectOutputStream = new ObjectOutputStream(workerSockets.get(i).getOutputStream());
    	            ObjectInputStream objectInputStream = new ObjectInputStream(workerSockets.get(i).getInputStream())) {

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("FILTER");
    	        objectOutputStream.writeObject(area);
    	        objectOutputStream.writeObject(dateRange);
    	        objectOutputStream.writeObject(people);
    	        objectOutputStream.writeObject(price);
    	        objectOutputStream.writeObject(stars);
    	        
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> filteredProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedFilteredProperties.addAll(filteredProperties);

    	        System.out.println("Received filtered properties from worker on port: " + port);
    	        
    	        
    	    } catch (IOException | ClassNotFoundException e) {
    	        e.printStackTrace();
    	    }
    	}
    }
    
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2024-04-12 19:10:01.007
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2024-04-12 19:10:01.008
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-12 19:10:01.038
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.UnknownHostException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.imageio.ImageIO;

public class Master {
	
	private int propertyCounter;
    private List<Worker> workers;
    private Socket clientSocket;
    private ArrayList<Socket> workerSockets;
    private ArrayList<ObjectInputStream> workerInputStreams;
    private ArrayList<ObjectOutputStream> workerOutputStreams;
    
    public Master(int[] workerPorts) {
    	Socket sock=null;
    	this.propertyCounter=0;
        this.workers = new ArrayList<>();
        workerSockets=new ArrayList<>();
        workerInputStreams = new ArrayList<>();
        workerOutputStreams = new ArrayList<>();
        
        for (int port : workerPorts) {
            Worker worker = new Worker(port); // Pass the port number to the Worker constructor
			worker.start(); // Start the worker thread
			workers.add(worker);
			System.out.println("Worker connected on port: " + port);
			try {
				sock=new Socket("localhost", port);
				workerInputStreams.add(new ObjectInputStream(sock.getInputStream()));
				workerOutputStreams.add(new ObjectOutputStream(sock.getOutputStream()));
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			workerSockets.add(sock);
			
        }
        
    }


    public void start() throws IOException, ParseException, ClassNotFoundException{
//        for (Worker worker : workers) {
//            worker.start();
//        }
        // Start listening for client requests
        try (ServerSocket serverSocket = new ServerSocket(5000)) {
            System.out.println("Master server started...");
            while (true) {
                clientSocket = serverSocket.accept();
                System.out.println("A");
                handleClientRequest(clientSocket);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void handleClientRequest(Socket clientSocket) throws IOException, ParseException, ClassNotFoundException {
    	
    	String managerUsername;
    	String renterUsername;
    	String propertyName;
    	Integer stars;
    	String area;
    	DateRange dateRange;
    	Integer people;
    	Integer price;
    	
    	 try (ObjectInputStream objectInputStream = new ObjectInputStream(clientSocket.getInputStream());
    			 ObjectOutputStream objectOutputStream = new ObjectOutputStream(clientSocket.getOutputStream());
    	        ) {
    		 
    		 while (true) {
    			 System.out.println("Awaiting action command from user");
	    	     String action = (String) objectInputStream.readObject();
	//            String[] tokens = request.split(":");
	//            String action = tokens[0];
	//            String propertyId = tokens[1];
	            switch (action) {
	                case "ADD":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	readPropertyFromStream(objectInputStream);
	                    break;
	                case "SHOW":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	managerUsername = (String) objectInputStream.readObject();
	                	System.out.println("Action at worker:"+action);
	                	System.out.println(managerUsername);
	                	objectOutputStream.writeObject(showManagerProperties(managerUsername));
	                    break;
	                case "AVAILABILITY":
	                	readAvailabilityFromStream(objectInputStream);
	                    break;
	                case "BOOKINGS":
	                	managerUsername = (String) objectInputStream.readObject();
	                	showManagerBookings(managerUsername);
	                    break;
	                case "BOOK":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	DateRange bookingRange = readDateRangeFromStream(objectInputStream);
	                    forwardPropertyBooking(renterUsername, propertyName, bookingRange);
	                    break;
	                case "RATE":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                    forwardPropertyRating(renterUsername, propertyName, stars);
	                    break;
	                case "FILTER":
	                	area = (String) objectInputStream.readObject();
	                	dateRange=readDateRangeFromStream(objectInputStream);
	                	people = (Integer) objectInputStream.readObject();
	                	price = (Integer) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                	forwardPropertyFiltering(area, dateRange, people, price, stars);
	                    break;
	                // Implement cases for other request types (UPDATE, etc.) as needed
	                default:
	                    // Unknown action, send error response
	                    break;
	               }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void readPropertyFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyInfo = (String) objectInputStream.readObject();

        // Read property info
        String[] keyValuePairs = propertyInfo.substring(1, propertyInfo.length() - 1).split(",");

        String roomName = "";
        int noOfPersons = 0;
        String area = "";
        int stars = 0;
        int noOfReviews = 0;
        String roomImage = "";

        // Iterate over key-value pairs and split them based on colons
        for (String pair : keyValuePairs) {
            System.out.println(pair);
            String[] keyValue = pair.split(":");
            String key = keyValue[0].trim().replaceAll("\"", "");
            String value = keyValue[1].trim().replaceAll("\"", ""); // Remove quotes

            // Assign values to appropriate variables based on keys
            switch (key) {
                case "roomName":
                    roomName = value;
                    break;
                case "noOfPersons":
                    noOfPersons = Integer.parseInt(value);
                    break;
                case "area":
                    area = value;
                    break;
                case "stars":
                    stars = Integer.parseInt(value);
                    break;
                case "noOfReviews":
                    noOfReviews = Integer.parseInt(value);
                    break;
                case "roomImage":
                    roomImage = value;
                    break;
            }
        }
        
     // Print the values to verify
        System.out.println("Room Name: " + roomName);
        System.out.println("Number of Persons: " + noOfPersons);
        System.out.println("Area: " + area);
        System.out.println("Stars: " + stars);
        System.out.println("Number of Reviews: " + noOfReviews);
        System.out.println("Room Image: " + roomImage);

        // Read image data
        byte[] imageData = (byte[]) objectInputStream.readObject();

        // Convert byte array to BufferedImage
        ByteArrayInputStream bis = new ByteArrayInputStream(imageData);
//        BufferedImage bufferedImage = ImageIO.read(bis);
        
        forwardPropertyAddition(roomName, managerUsername ,new Property(roomName, noOfPersons, area, stars, noOfReviews, roomImage,propertyCounter), imageData);
        propertyCounter=propertyCounter+1;
        // Return property object with image
    }
    
    private void readAvailabilityFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyName = (String) objectInputStream.readObject();
        
        String dateRangeAvailability = (String) objectInputStream.readObject();
        
        forwardPropertyAvailability(managerUsername, propertyName,dateRangeAvailability);

        // Return property object with image
    }

    private Map<String, Object> readFiltersFromStream(BufferedReader reader) throws IOException {
        Map<String, Object> filters = new HashMap<>();
        
        String line;
        while ((line = reader.readLine()) != null) {
            String[] tokens = line.split(":");
            String filterName = tokens[0];
            Object filterValue = tokens[1]; // Assuming filter value is string for simplicity, you may need to parse it accordingly
            filters.put(filterName, filterValue);
        }
        
        return filters;
    }

    private DateRange readDateRangeFromStream(ObjectInputStream objectInputStream) throws IOException, ParseException, ClassNotFoundException {
    	String startDateStr = (String) objectInputStream.readObject();
        String endDateStr = (String) objectInputStream.readObject();
        // Assuming date format is in "day/month/year"
        SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
        Date startDate = dateFormat.parse(startDateStr);
        Date endDate = dateFormat.parse(endDateStr);
        return new DateRange(startDate, endDate);
    }

    private void forwardPropertyAddition(String propertyName, String managerUsername,Property property, byte [] imageBytes) throws IOException {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new property...");

       String add = "ADD";
       objectOutputStream.writeObject(add);
       System.out.println("ADD SENT");
       objectOutputStream.writeObject(managerUsername);
       objectOutputStream.writeObject(property);
       objectOutputStream.writeObject(imageBytes);

          
    }
    
    private void forwardPropertyAvailability(String managerUsername,String propertyName,String dateRangeAvailability) throws IOException {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);
        

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new availability...");

       String availability = "AVAILABILITY";
       objectOutputStream.writeObject(availability);
       objectOutputStream.writeObject(managerUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(dateRangeAvailability);

    }

    private String showManagerProperties(String managerUsername) throws IOException, ClassNotFoundException {
    	
    	ArrayList<Property> mergedProperties = new ArrayList<>();
        
    	// Iterate over worker ports
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
    	    ObjectInputStream objectInputStream = workerInputStreams.get(i);

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("SHOW");
    	        objectOutputStream.writeObject(managerUsername);
    	        System.out.println("talked to worker");
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> workerProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedProperties.addAll(workerProperties);

    	        System.out.println("Received properties from worker on port: " + port);
    	        
    	        
    	        
    	 
    	}
    	
    	String returnedPropertiesAsString="";
    	
    	System.out.println(mergedProperties.get(0));
    	
    	for (int i=0;i<mergedProperties.size();i++) {
    		returnedPropertiesAsString=returnedPropertiesAsString+mergedProperties.get(i).toString();
    	}
    	
    	return returnedPropertiesAsString;
    	
    }
    	
    	private void showManagerBookings(String managerUsername) {
        	
    		Map<String,List<DateRange>> mergedPropertyNamesBookings= new HashMap<>();
            
        	// Iterate over worker ports
        	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
        	    int port = 5000 + i; // Calculate port number
        	    
        	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
        	    ObjectInputStream objectInputStream = workerInputStreams.get(i);

        	        // Send "SHOW" request to worker
        	        objectOutputStream.writeObject("BOOKINGS");
        	        objectOutputStream.writeObject(managerUsername);
        	        
        	        // Receive ArrayList<Property> response from worker
        	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
        	        Map<String,List<DateRange>> propertyNamesBookings = (Map<String,List<DateRange>>) objectInputStream.readObject();
        	        
                    for (Map.Entry<String, List<DateRange>> entry : propertyNamesBookings.entrySet()) {
                        String propertyName = entry.getKey();
                        List<DateRange> bookings = entry.getValue();
                        
                        if (mergedPropertyNamesBookings.containsKey(propertyName)) {
                            // If the property already exists in the merged map, merge its bookings
                            mergedPropertyNamesBookings.get(propertyName).addAll(bookings);
                        } else {
                            // If the property doesn't exist in the merged map, add it with its bookings
                            mergedPropertyNamesBookings.put(propertyName, new ArrayList<>(bookings));
                        }
                    }

                    System.out.println("Received property bookings from worker on port: " + port);
        	        
        	        
        	    } catch (IOException | ClassNotFoundException e) {
        	        e.printStackTrace();
        	    }
        	}
    	
    	try (PrintWriter writer = new PrintWriter(clientSocket.getOutputStream(), true)) {
            // Send the string to the client
            writer.println("These are your properties:");
            System.out.println("Sent merged properties to the client");
        } catch (IOException e) {
            e.printStackTrace();
        }
    	
    }

    private void forwardPropertySearch(String propertyId, Map<String, Object> filters) {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyId.hashCode()) % workers.size();
        Worker worker = workers.get(workerIndex);

        // Search for properties on the chosen worker
        List<Property> searchResults = worker.searchProperties(filters);

        // Print search results to the console
        System.out.println("Search results for property ID " + propertyId + ":");
        for (Property property : searchResults) {
            System.out.println(property.toString()); // Assuming Property class overrides toString() method
        }
    }


    private void forwardPropertyBooking(String renterUsername, String propertyName, DateRange bookingRange) throws IOException {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new booking...");

       String book = "BOOK";
       objectOutputStream.writeObject(book);
       objectOutputStream.writeObject(renterUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(bookingRange);

           
    }
    
    private void forwardPropertyRating(String renterUsername, String propertyName, Integer stars) throws IOException {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new rating...");

       String rate = "RATE";
       objectOutputStream.writeObject(rate);
       objectOutputStream.writeObject(renterUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(stars);

    }
    
    private void forwardPropertyFiltering(String area, DateRange dateRange, Integer people, Integer price, Integer stars) {
    	
    	ArrayList<Property> mergedFilteredProperties= new ArrayList<Property>();
    	
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    try (
    	            ObjectOutputStream objectOutputStream = new ObjectOutputStream(workerSockets.get(i).getOutputStream());
    	            ObjectInputStream objectInputStream = new ObjectInputStream(workerSockets.get(i).getInputStream())) {

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("FILTER");
    	        objectOutputStream.writeObject(area);
    	        objectOutputStream.writeObject(dateRange);
    	        objectOutputStream.writeObject(people);
    	        objectOutputStream.writeObject(price);
    	        objectOutputStream.writeObject(stars);
    	        
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> filteredProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedFilteredProperties.addAll(filteredProperties);

    	        System.out.println("Received filtered properties from worker on port: " + port);
    	        
    	        
    	    } catch (IOException | ClassNotFoundException e) {
    	        e.printStackTrace();
    	    }
    	}
    }
    
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-04-12 19:10:01.042
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-04-12 19:10:01.043
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-12 19:10:06.596
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.UnknownHostException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.imageio.ImageIO;

public class Master {
	
	private int propertyCounter;
    private List<Worker> workers;
    private Socket clientSocket;
    private ArrayList<Socket> workerSockets;
    private ArrayList<ObjectInputStream> workerInputStreams;
    private ArrayList<ObjectOutputStream> workerOutputStreams;
    
    public Master(int[] workerPorts) {
    	Socket sock=null;
    	this.propertyCounter=0;
        this.workers = new ArrayList<>();
        workerSockets=new ArrayList<>();
        workerInputStreams = new ArrayList<>();
        workerOutputStreams = new ArrayList<>();
        
        for (int port : workerPorts) {
            Worker worker = new Worker(port); // Pass the port number to the Worker constructor
			worker.start(); // Start the worker thread
			workers.add(worker);
			System.out.println("Worker connected on port: " + port);
			try {
				sock=new Socket("localhost", port);
				workerInputStreams.add(new ObjectInputStream(sock.getInputStream()));
				workerOutputStreams.add(new ObjectOutputStream(sock.getOutputStream()));
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			workerSockets.add(sock);
			
        }
        
    }


    public void start() throws IOException, ParseException, ClassNotFoundException{
//        for (Worker worker : workers) {
//            worker.start();
//        }
        // Start listening for client requests
        try (ServerSocket serverSocket = new ServerSocket(5000)) {
            System.out.println("Master server started...");
            while (true) {
                clientSocket = serverSocket.accept();
                System.out.println("A");
                handleClientRequest(clientSocket);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void handleClientRequest(Socket clientSocket) throws IOException, ParseException, ClassNotFoundException {
    	
    	String managerUsername;
    	String renterUsername;
    	String propertyName;
    	Integer stars;
    	String area;
    	DateRange dateRange;
    	Integer people;
    	Integer price;
    	
    	 try (ObjectInputStream objectInputStream = new ObjectInputStream(clientSocket.getInputStream());
    			 ObjectOutputStream objectOutputStream = new ObjectOutputStream(clientSocket.getOutputStream());
    	        ) {
    		 
    		 while (true) {
    			 System.out.println("Awaiting action command from user");
	    	     String action = (String) objectInputStream.readObject();
	//            String[] tokens = request.split(":");
	//            String action = tokens[0];
	//            String propertyId = tokens[1];
	            switch (action) {
	                case "ADD":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	readPropertyFromStream(objectInputStream);
	                    break;
	                case "SHOW":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	managerUsername = (String) objectInputStream.readObject();
	                	System.out.println("Action at worker:"+action);
	                	System.out.println(managerUsername);
	                	objectOutputStream.writeObject(showManagerProperties(managerUsername));
	                    break;
	                case "AVAILABILITY":
	                	readAvailabilityFromStream(objectInputStream);
	                    break;
	                case "BOOKINGS":
	                	managerUsername = (String) objectInputStream.readObject();
	                	showManagerBookings(managerUsername);
	                    break;
	                case "BOOK":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	DateRange bookingRange = readDateRangeFromStream(objectInputStream);
	                    forwardPropertyBooking(renterUsername, propertyName, bookingRange);
	                    break;
	                case "RATE":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                    forwardPropertyRating(renterUsername, propertyName, stars);
	                    break;
	                case "FILTER":
	                	area = (String) objectInputStream.readObject();
	                	dateRange=readDateRangeFromStream(objectInputStream);
	                	people = (Integer) objectInputStream.readObject();
	                	price = (Integer) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                	forwardPropertyFiltering(area, dateRange, people, price, stars);
	                    break;
	                // Implement cases for other request types (UPDATE, etc.) as needed
	                default:
	                    // Unknown action, send error response
	                    break;
	               }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void readPropertyFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyInfo = (String) objectInputStream.readObject();

        // Read property info
        String[] keyValuePairs = propertyInfo.substring(1, propertyInfo.length() - 1).split(",");

        String roomName = "";
        int noOfPersons = 0;
        String area = "";
        int stars = 0;
        int noOfReviews = 0;
        String roomImage = "";

        // Iterate over key-value pairs and split them based on colons
        for (String pair : keyValuePairs) {
            System.out.println(pair);
            String[] keyValue = pair.split(":");
            String key = keyValue[0].trim().replaceAll("\"", "");
            String value = keyValue[1].trim().replaceAll("\"", ""); // Remove quotes

            // Assign values to appropriate variables based on keys
            switch (key) {
                case "roomName":
                    roomName = value;
                    break;
                case "noOfPersons":
                    noOfPersons = Integer.parseInt(value);
                    break;
                case "area":
                    area = value;
                    break;
                case "stars":
                    stars = Integer.parseInt(value);
                    break;
                case "noOfReviews":
                    noOfReviews = Integer.parseInt(value);
                    break;
                case "roomImage":
                    roomImage = value;
                    break;
            }
        }
        
     // Print the values to verify
        System.out.println("Room Name: " + roomName);
        System.out.println("Number of Persons: " + noOfPersons);
        System.out.println("Area: " + area);
        System.out.println("Stars: " + stars);
        System.out.println("Number of Reviews: " + noOfReviews);
        System.out.println("Room Image: " + roomImage);

        // Read image data
        byte[] imageData = (byte[]) objectInputStream.readObject();

        // Convert byte array to BufferedImage
        ByteArrayInputStream bis = new ByteArrayInputStream(imageData);
//        BufferedImage bufferedImage = ImageIO.read(bis);
        
        forwardPropertyAddition(roomName, managerUsername ,new Property(roomName, noOfPersons, area, stars, noOfReviews, roomImage,propertyCounter), imageData);
        propertyCounter=propertyCounter+1;
        // Return property object with image
    }
    
    private void readAvailabilityFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyName = (String) objectInputStream.readObject();
        
        String dateRangeAvailability = (String) objectInputStream.readObject();
        
        forwardPropertyAvailability(managerUsername, propertyName,dateRangeAvailability);

        // Return property object with image
    }

    private Map<String, Object> readFiltersFromStream(BufferedReader reader) throws IOException {
        Map<String, Object> filters = new HashMap<>();
        
        String line;
        while ((line = reader.readLine()) != null) {
            String[] tokens = line.split(":");
            String filterName = tokens[0];
            Object filterValue = tokens[1]; // Assuming filter value is string for simplicity, you may need to parse it accordingly
            filters.put(filterName, filterValue);
        }
        
        return filters;
    }

    private DateRange readDateRangeFromStream(ObjectInputStream objectInputStream) throws IOException, ParseException, ClassNotFoundException {
    	String startDateStr = (String) objectInputStream.readObject();
        String endDateStr = (String) objectInputStream.readObject();
        // Assuming date format is in "day/month/year"
        SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
        Date startDate = dateFormat.parse(startDateStr);
        Date endDate = dateFormat.parse(endDateStr);
        return new DateRange(startDate, endDate);
    }

    private void forwardPropertyAddition(String propertyName, String managerUsername,Property property, byte [] imageBytes) throws IOException {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new property...");

       String add = "ADD";
       objectOutputStream.writeObject(add);
       System.out.println("ADD SENT");
       objectOutputStream.writeObject(managerUsername);
       objectOutputStream.writeObject(property);
       objectOutputStream.writeObject(imageBytes);

          
    }
    
    private void forwardPropertyAvailability(String managerUsername,String propertyName,String dateRangeAvailability) throws IOException {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);
        

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new availability...");

       String availability = "AVAILABILITY";
       objectOutputStream.writeObject(availability);
       objectOutputStream.writeObject(managerUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(dateRangeAvailability);

    }

    private String showManagerProperties(String managerUsername) throws IOException, ClassNotFoundException {
    	
    	ArrayList<Property> mergedProperties = new ArrayList<>();
        
    	// Iterate over worker ports
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
    	    ObjectInputStream objectInputStream = workerInputStreams.get(i);

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("SHOW");
    	        objectOutputStream.writeObject(managerUsername);
    	        System.out.println("talked to worker");
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> workerProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedProperties.addAll(workerProperties);

    	        System.out.println("Received properties from worker on port: " + port);
    	        
    	        
    	        
    	 
    	}
    	
    	String returnedPropertiesAsString="";
    	
    	System.out.println(mergedProperties.get(0));
    	
    	for (int i=0;i<mergedProperties.size();i++) {
    		returnedPropertiesAsString=returnedPropertiesAsString+mergedProperties.get(i).toString();
    	}
    	
    	return returnedPropertiesAsString;
    	
    }
    	
    	private void showManagerBookings(String managerUsername) {
        	
    		Map<String,List<DateRange>> mergedPropertyNamesBookings= new HashMap<>();
            
        	// Iterate over worker ports
        	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
        	    int port = 5000 + i; // Calculate port number
        	    
        	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
        	    ObjectInputStream objectInputStream = workerInputStreams.get(i);

        	        // Send "SHOW" request to worker
        	        objectOutputStream.writeObject("BOOKINGS");
        	        objectOutputStream.writeObject(managerUsername);
        	        
        	        // Receive ArrayList<Property> response from worker
        	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
        	        Map<String,List<DateRange>> propertyNamesBookings = (Map<String,List<DateRange>>) objectInputStream.readObject();
        	        
                    for (Map.Entry<String, List<DateRange>> entry : propertyNamesBookings.entrySet()) {
                        String propertyName = entry.getKey();
                        List<DateRange> bookings = entry.getValue();
                        
                        if (mergedPropertyNamesBookings.containsKey(propertyName)) {
                            // If the property already exists in the merged map, merge its bookings
                            mergedPropertyNamesBookings.get(propertyName).addAll(bookings);
                        } else {
                            // If the property doesn't exist in the merged map, add it with its bookings
                            mergedPropertyNamesBookings.put(propertyName, new ArrayList<>(bookings));
                        }
                    }

                    System.out.println("Received property bookings from worker on port: " + port);
        	        
        	        
        	    } catch (IOException | ClassNotFoundException e) {
        	        e.printStackTrace();
        	    }
        	}
    	
    	try (PrintWriter writer = new PrintWriter(clientSocket.getOutputStream(), true)) {
            // Send the string to the client
            writer.println("These are your properties:");
            System.out.println("Sent merged properties to the client");
        } catch (IOException e) {
            e.printStackTrace();
        }
    	
    }

    private void forwardPropertySearch(String propertyId, Map<String, Object> filters) {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyId.hashCode()) % workers.size();
        Worker worker = workers.get(workerIndex);

        // Search for properties on the chosen worker
        List<Property> searchResults = worker.searchProperties(filters);

        // Print search results to the console
        System.out.println("Search results for property ID " + propertyId + ":");
        for (Property property : searchResults) {
            System.out.println(property.toString()); // Assuming Property class overrides toString() method
        }
    }


    private void forwardPropertyBooking(String renterUsername, String propertyName, DateRange bookingRange) throws IOException {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new booking...");

       String book = "BOOK";
       objectOutputStream.writeObject(book);
       objectOutputStream.writeObject(renterUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(bookingRange);

           
    }
    
    private void forwardPropertyRating(String renterUsername, String propertyName, Integer stars) throws IOException {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new rating...");

       String rate = "RATE";
       objectOutputStream.writeObject(rate);
       objectOutputStream.writeObject(renterUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(stars);

    }
    
    private void forwardPropertyFiltering(String area, DateRange dateRange, Integer people, Integer price, Integer stars) {
    	
    	ArrayList<Property> mergedFilteredProperties= new ArrayList<Property>();
    	
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    try (
    	            ObjectOutputStream objectOutputStream = new ObjectOutputStream(workerSockets.get(i).getOutputStream());
    	            ObjectInputStream objectInputStream = new ObjectInputStream(workerSockets.get(i).getInputStream())) {

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("FILTER");
    	        objectOutputStream.writeObject(area);
    	        objectOutputStream.writeObject(dateRange);
    	        objectOutputStream.writeObject(people);
    	        objectOutputStream.writeObject(price);
    	        objectOutputStream.writeObject(stars);
    	        
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> filteredProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedFilteredProperties.addAll(filteredProperties);

    	        System.out.println("Received filtered properties from worker on port: " + port);
    	        
    	        
    	    } catch (IOException | ClassNotFoundException e) {
    	        e.printStackTrace();
    	    }
    	}
    }
    
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-04-12 19:10:06.600
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-04-12 19:10:06.601
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY de.yatta.platform.marketplace.licensing.client 2 0 2024-04-12 22:10:32.884
!MESSAGE Could not receive a valid response for solution feature de.yatta.feature.roundtrip from the license server.
!STACK 0
java.net.SocketException: Connection reset
	at java.base/java.net.SocketInputStream.read(SocketInputStream.java:186)
	at java.base/java.net.SocketInputStream.read(SocketInputStream.java:140)
	at java.base/sun.security.ssl.SSLSocketInputRecord.read(SSLSocketInputRecord.java:484)
	at java.base/sun.security.ssl.SSLSocketInputRecord.readHeader(SSLSocketInputRecord.java:478)
	at java.base/sun.security.ssl.SSLSocketInputRecord.bytesInCompletePacket(SSLSocketInputRecord.java:70)
	at java.base/sun.security.ssl.SSLSocketImpl.readApplicationRecord(SSLSocketImpl.java:1459)
	at java.base/sun.security.ssl.SSLSocketImpl$AppInputStream.read(SSLSocketImpl.java:1070)
	at org.apache.http.impl.conn.LoggingInputStream.read(LoggingInputStream.java:84)
	at org.apache.http.impl.io.SessionInputBufferImpl.streamRead(SessionInputBufferImpl.java:137)
	at org.apache.http.impl.io.SessionInputBufferImpl.fillBuffer(SessionInputBufferImpl.java:153)
	at org.apache.http.impl.io.SessionInputBufferImpl.readLine(SessionInputBufferImpl.java:280)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:138)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:56)
	at org.apache.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:259)
	at org.apache.http.impl.DefaultBHttpClientConnection.receiveResponseHeader(DefaultBHttpClientConnection.java:163)
	at org.apache.http.impl.conn.CPoolProxy.receiveResponseHeader(CPoolProxy.java:157)
	at org.apache.http.protocol.HttpRequestExecutor.doReceiveResponse(HttpRequestExecutor.java:273)
	at de.yatta.eclipse.launcher.communication.utils.HttpRequestContext$RequestTemplateExecutor.doReceiveResponse(HttpRequestContext.java:707)
	at org.apache.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:125)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:272)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)
	at org.apache.http.client.fluent.Request.internalExecute(Request.java:173)
	at org.apache.http.client.fluent.Executor.execute(Executor.java:262)
	at de.yatta.eclipse.launcher.communication.utils.RequestTemplate.execute(RequestTemplate.java:200)
	at de.yatta.platform.marketplace.licensing.client.LicensingClient$1.run(LicensingClient.java:500)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY de.yatta.platform.marketplace.licensing.client 2 0 2024-04-12 22:10:32.885
!MESSAGE Could not receive a valid response for solution feature de.yatta.feature.emf from the license server.
!STACK 0
java.net.SocketException: Connection reset
	at java.base/java.net.SocketInputStream.read(SocketInputStream.java:186)
	at java.base/java.net.SocketInputStream.read(SocketInputStream.java:140)
	at java.base/sun.security.ssl.SSLSocketInputRecord.read(SSLSocketInputRecord.java:484)
	at java.base/sun.security.ssl.SSLSocketInputRecord.readHeader(SSLSocketInputRecord.java:478)
	at java.base/sun.security.ssl.SSLSocketInputRecord.bytesInCompletePacket(SSLSocketInputRecord.java:70)
	at java.base/sun.security.ssl.SSLSocketImpl.readApplicationRecord(SSLSocketImpl.java:1459)
	at java.base/sun.security.ssl.SSLSocketImpl$AppInputStream.read(SSLSocketImpl.java:1070)
	at org.apache.http.impl.conn.LoggingInputStream.read(LoggingInputStream.java:84)
	at org.apache.http.impl.io.SessionInputBufferImpl.streamRead(SessionInputBufferImpl.java:137)
	at org.apache.http.impl.io.SessionInputBufferImpl.fillBuffer(SessionInputBufferImpl.java:153)
	at org.apache.http.impl.io.SessionInputBufferImpl.readLine(SessionInputBufferImpl.java:280)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:138)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:56)
	at org.apache.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:259)
	at org.apache.http.impl.DefaultBHttpClientConnection.receiveResponseHeader(DefaultBHttpClientConnection.java:163)
	at org.apache.http.impl.conn.CPoolProxy.receiveResponseHeader(CPoolProxy.java:157)
	at org.apache.http.protocol.HttpRequestExecutor.doReceiveResponse(HttpRequestExecutor.java:273)
	at de.yatta.eclipse.launcher.communication.utils.HttpRequestContext$RequestTemplateExecutor.doReceiveResponse(HttpRequestContext.java:707)
	at org.apache.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:125)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:272)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)
	at org.apache.http.client.fluent.Request.internalExecute(Request.java:173)
	at org.apache.http.client.fluent.Executor.execute(Executor.java:262)
	at de.yatta.eclipse.launcher.communication.utils.RequestTemplate.execute(RequestTemplate.java:200)
	at de.yatta.platform.marketplace.licensing.client.LicensingClient$1.run(LicensingClient.java:500)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-12 22:12:04.196
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.UnknownHostException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.imageio.ImageIO;

public class Master {
	
	private int propertyCounter;
    private List<Worker> workers;
    private Socket clientSocket;
    private Socket reducerSocket;
    private ArrayList<Socket> workerSockets;
    private ArrayList<ObjectInputStream> workerInputStreams;
    private ArrayList<ObjectOutputStream> workerOutputStreams;
    
    public Master(int[] workerPorts) {
    	Socket sock=null;
    	this.propertyCounter=0;
        this.workers = new ArrayList<>();
        workerSockets=new ArrayList<>();
        workerInputStreams = new ArrayList<>();
        workerOutputStreams = new ArrayList<>();
        
        for (int port : workerPorts) {
            Worker worker = new Worker(port); // Pass the port number to the Worker constructor
			worker.start(); // Start the worker thread
			workers.add(worker);
			System.out.println("Worker connected on port: " + port);
			try {
				sock=new Socket("localhost", port);
				workerInputStreams.add(new ObjectInputStream(sock.getInputStream()));
				workerOutputStreams.add(new ObjectOutputStream(sock.getOutputStream()));
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			workerSockets.add(sock);
			
        }
        
    }


    public void start() throws IOException, ParseException, ClassNotFoundException{
//        for (Worker worker : workers) {
//            worker.start();
//        }
        // Start listening for client requests
        try (ServerSocket serverSocket = new ServerSocket(5000)) {
            System.out.println("Master server started...");
            while (true) {
                clientSocket = serverSocket.accept();
                System.out.println("A");
                handleClientRequest(clientSocket);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void handleClientRequest(Socket clientSocket) throws IOException, ParseException, ClassNotFoundException {
    	
    	String managerUsername;
    	String renterUsername;
    	String propertyName;
    	Integer stars;
    	String area;
    	DateRange dateRange;
    	Integer people;
    	Integer price;
    	
    	 try (ObjectInputStream objectInputStream = new ObjectInputStream(clientSocket.getInputStream());
    			 ObjectOutputStream objectOutputStream = new ObjectOutputStream(clientSocket.getOutputStream());
    	        ) {
    		 
    		 while (true) {
    			 System.out.println("Awaiting action command from user");
	    	     String action = (String) objectInputStream.readObject();
	//            String[] tokens = request.split(":");
	//            String action = tokens[0];
	//            String propertyId = tokens[1];
	            switch (action) {
	                case "ADD":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	readPropertyFromStream(objectInputStream);
	                    break;
	                case "SHOW":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	managerUsername = (String) objectInputStream.readObject();
	                	System.out.println("Action at worker:"+action);
	                	System.out.println(managerUsername);
	                	objectOutputStream.writeObject(showManagerProperties(managerUsername));
	                    break;
	                case "AVAILABILITY":
	                	readAvailabilityFromStream(objectInputStream);
	                    break;
	                case "BOOKINGS":
	                	managerUsername = (String) objectInputStream.readObject();
	                	showManagerBookings(managerUsername);
	                    break;
	                case "BOOK":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	DateRange bookingRange = readDateRangeFromStream(objectInputStream);
	                    forwardPropertyBooking(renterUsername, propertyName, bookingRange);
	                    break;
	                case "RATE":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                    forwardPropertyRating(renterUsername, propertyName, stars);
	                    break;
	                case "FILTER":
	                	area = (String) objectInputStream.readObject();
	                	dateRange=readDateRangeFromStream(objectInputStream);
	                	people = (Integer) objectInputStream.readObject();
	                	price = (Integer) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                	forwardPropertyFiltering(area, dateRange, people, price, stars);
	                    break;
	                // Implement cases for other request types (UPDATE, etc.) as needed
	                default:
	                    // Unknown action, send error response
	                    break;
	               }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void readPropertyFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyInfo = (String) objectInputStream.readObject();

        // Read property info
        String[] keyValuePairs = propertyInfo.substring(1, propertyInfo.length() - 1).split(",");

        String roomName = "";
        int noOfPersons = 0;
        String area = "";
        int stars = 0;
        int noOfReviews = 0;
        String roomImage = "";

        // Iterate over key-value pairs and split them based on colons
        for (String pair : keyValuePairs) {
            System.out.println(pair);
            String[] keyValue = pair.split(":");
            String key = keyValue[0].trim().replaceAll("\"", "");
            String value = keyValue[1].trim().replaceAll("\"", ""); // Remove quotes

            // Assign values to appropriate variables based on keys
            switch (key) {
                case "roomName":
                    roomName = value;
                    break;
                case "noOfPersons":
                    noOfPersons = Integer.parseInt(value);
                    break;
                case "area":
                    area = value;
                    break;
                case "stars":
                    stars = Integer.parseInt(value);
                    break;
                case "noOfReviews":
                    noOfReviews = Integer.parseInt(value);
                    break;
                case "roomImage":
                    roomImage = value;
                    break;
            }
        }
        
     // Print the values to verify
        System.out.println("Room Name: " + roomName);
        System.out.println("Number of Persons: " + noOfPersons);
        System.out.println("Area: " + area);
        System.out.println("Stars: " + stars);
        System.out.println("Number of Reviews: " + noOfReviews);
        System.out.println("Room Image: " + roomImage);

        // Read image data
        byte[] imageData = (byte[]) objectInputStream.readObject();

        // Convert byte array to BufferedImage
        ByteArrayInputStream bis = new ByteArrayInputStream(imageData);
//        BufferedImage bufferedImage = ImageIO.read(bis);
        
        forwardPropertyAddition(roomName, managerUsername ,new Property(roomName, noOfPersons, area, stars, noOfReviews, roomImage,propertyCounter), imageData);
        propertyCounter=propertyCounter+1;
        // Return property object with image
    }
    
    private void readAvailabilityFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyName = (String) objectInputStream.readObject();
        
        String dateRangeAvailability = (String) objectInputStream.readObject();
        
        forwardPropertyAvailability(managerUsername, propertyName,dateRangeAvailability);

        // Return property object with image
    }

    private Map<String, Object> readFiltersFromStream(BufferedReader reader) throws IOException {
        Map<String, Object> filters = new HashMap<>();
        
        String line;
        while ((line = reader.readLine()) != null) {
            String[] tokens = line.split(":");
            String filterName = tokens[0];
            Object filterValue = tokens[1]; // Assuming filter value is string for simplicity, you may need to parse it accordingly
            filters.put(filterName, filterValue);
        }
        
        return filters;
    }

    private DateRange readDateRangeFromStream(ObjectInputStream objectInputStream) throws IOException, ParseException, ClassNotFoundException {
    	String startDateStr = (String) objectInputStream.readObject();
        String endDateStr = (String) objectInputStream.readObject();
        // Assuming date format is in "day/month/year"
        SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
        Date startDate = dateFormat.parse(startDateStr);
        Date endDate = dateFormat.parse(endDateStr);
        return new DateRange(startDate, endDate);
    }

    private void forwardPropertyAddition(String propertyName, String managerUsername,Property property, byte [] imageBytes) throws IOException {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new property...");

       String add = "ADD";
       objectOutputStream.writeObject(add);
       System.out.println("ADD SENT");
       objectOutputStream.writeObject(managerUsername);
       objectOutputStream.writeObject(property);
       objectOutputStream.writeObject(imageBytes);

          
    }
    
    private void forwardPropertyAvailability(String managerUsername,String propertyName,String dateRangeAvailability) throws IOException {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);
        

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new availability...");

       String availability = "AVAILABILITY";
       objectOutputStream.writeObject(availability);
       objectOutputStream.writeObject(managerUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(dateRangeAvailability);

    }

    private String showManagerProperties(String managerUsername) throws IOException, ClassNotFoundException {
    	
    	ArrayList<Property> mergedProperties = new ArrayList<>();
        
    	// Iterate over worker ports
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
    	    ObjectInputStream objectInputStream = workerInputStreams.get(i);

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("SHOW");
    	        objectOutputStream.writeObject(managerUsername);
    	        System.out.println("talked to worker");
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> workerProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedProperties.addAll(workerProperties);

    	        System.out.println("Received properties from worker on port: " + port);
    	        
    	        
    	        
    	 
    	}
    	
    	String returnedPropertiesAsString="";
    	
    	System.out.println(mergedProperties.get(0));
    	
    	for (int i=0;i<mergedProperties.size();i++) {
    		returnedPropertiesAsString=returnedPropertiesAsString+mergedProperties.get(i).toString();
    	}
    	
    	return returnedPropertiesAsString;
    	
    }
    	
    	private void showManagerBookings(String managerUsername) throws IOException, ClassNotFoundException {
        	
    		Map<String,List<DateRange>> mergedPropertyNamesBookings= new HashMap<>();
            
        	// Iterate over worker ports
        	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
        	    int port = 5000 + i; // Calculate port number
        	    
        	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
        	    ObjectInputStream objectInputStream = workerInputStreams.get(i);

        	        // Send "SHOW" request to worker
        	        objectOutputStream.writeObject("BOOKINGS");
        	        objectOutputStream.writeObject(managerUsername);
        	        
        	        // Receive ArrayList<Property> response from worker
        	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
        	        Map<String,List<DateRange>> propertyNamesBookings = (Map<String,List<DateRange>>) objectInputStream.readObject();
        	        
                    for (Map.Entry<String, List<DateRange>> entry : propertyNamesBookings.entrySet()) {
                        String propertyName = entry.getKey();
                        List<DateRange> bookings = entry.getValue();
                        
                        if (mergedPropertyNamesBookings.containsKey(propertyName)) {
                            // If the property already exists in the merged map, merge its bookings
                            mergedPropertyNamesBookings.get(propertyName).addAll(bookings);
                        } else {
                            // If the property doesn't exist in the merged map, add it with its bookings
                            mergedPropertyNamesBookings.put(propertyName, new ArrayList<>(bookings));
                        }
                    }
                    
                    for (Map.Entry<String, List<DateRange>> entry : mergedPropertyNamesBookings.entrySet()) {
                        String propertyName = entry.getKey();
                        List<DateRange> bookings = entry.getValue();
                        
                        // Print the property name
                        System.out.println("Property Name: " + propertyName);
                        
                        // Iterate over the list of date ranges for the current property
                        for (DateRange dateRange : bookings) {
                            // Print each date range
                            System.out.println("Date Range: " + dateRange);
                        }
                        
                        // Add a separator for better readability
                        System.out.println("------------------------------------");
                    }
                    
                    System.out.println("Received property bookings from worker on port: " + port);
        	        
        	}
    	
    	try (PrintWriter writer = new PrintWriter(clientSocket.getOutputStream(), true)) {
            // Send the string to the client
            writer.println("These are your properties:");
            System.out.println("Sent merged properties to the client");
        } catch (IOException e) {
            e.printStackTrace();
        }
    	
    }

    private void forwardPropertySearch(String propertyId, Map<String, Object> filters) {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyId.hashCode()) % workers.size();
        Worker worker = workers.get(workerIndex);

        // Search for properties on the chosen worker
        List<Property> searchResults = worker.searchProperties(filters);

        // Print search results to the console
        System.out.println("Search results for property ID " + propertyId + ":");
        for (Property property : searchResults) {
            System.out.println(property.toString()); // Assuming Property class overrides toString() method
        }
    }


    private void forwardPropertyBooking(String renterUsername, String propertyName, DateRange bookingRange) throws IOException {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new booking...");

       String book = "BOOK";
       objectOutputStream.writeObject(book);
       objectOutputStream.writeObject(renterUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(bookingRange);

           
    }
    
    private void forwardPropertyRating(String renterUsername, String propertyName, Integer stars) throws IOException {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new rating...");

       String rate = "RATE";
       objectOutputStream.writeObject(rate);
       objectOutputStream.writeObject(renterUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(stars);

    }
    
    private void forwardPropertyFiltering(String area, DateRange dateRange, Integer people, Integer price, Integer stars) {
    	
    	ArrayList<Property> mergedFilteredProperties= new ArrayList<Property>();
    	
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
    	    ObjectInputStream objectInputStream = workerInputStreams.get(i); {

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("FILTER");
    	        objectOutputStream.writeObject(area);
    	        objectOutputStream.writeObject(dateRange);
    	        objectOutputStream.writeObject(people);
    	        objectOutputStream.writeObject(price);
    	        objectOutputStream.writeObject(stars);
    	        
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> filteredProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedFilteredProperties.addAll(filteredProperties);

    	        System.out.println("Received filtered properties from worker on port: " + port);
    	        
    	        
    	    } catch (IOException | ClassNotFoundException e) {
    	        e.printStackTrace();
    	    }
    	}
    }
    
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2024-04-12 22:12:04.198
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2024-04-12 22:12:04.200
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-12 22:12:04.308
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.UnknownHostException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.imageio.ImageIO;

public class Master {
	
	private int propertyCounter;
    private List<Worker> workers;
    private Socket clientSocket;
    private Socket reducerSocket;
    private ArrayList<Socket> workerSockets;
    private ArrayList<ObjectInputStream> workerInputStreams;
    private ArrayList<ObjectOutputStream> workerOutputStreams;
    
    public Master(int[] workerPorts) {
    	Socket sock=null;
    	this.propertyCounter=0;
        this.workers = new ArrayList<>();
        workerSockets=new ArrayList<>();
        workerInputStreams = new ArrayList<>();
        workerOutputStreams = new ArrayList<>();
        
        for (int port : workerPorts) {
            Worker worker = new Worker(port); // Pass the port number to the Worker constructor
			worker.start(); // Start the worker thread
			workers.add(worker);
			System.out.println("Worker connected on port: " + port);
			try {
				sock=new Socket("localhost", port);
				workerInputStreams.add(new ObjectInputStream(sock.getInputStream()));
				workerOutputStreams.add(new ObjectOutputStream(sock.getOutputStream()));
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			workerSockets.add(sock);
			
        }
        
    }


    public void start() throws IOException, ParseException, ClassNotFoundException{
//        for (Worker worker : workers) {
//            worker.start();
//        }
        // Start listening for client requests
        try (ServerSocket serverSocket = new ServerSocket(5000)) {
            System.out.println("Master server started...");
            while (true) {
                clientSocket = serverSocket.accept();
                System.out.println("A");
                handleClientRequest(clientSocket);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void handleClientRequest(Socket clientSocket) throws IOException, ParseException, ClassNotFoundException {
    	
    	String managerUsername;
    	String renterUsername;
    	String propertyName;
    	Integer stars;
    	String area;
    	DateRange dateRange;
    	Integer people;
    	Integer price;
    	
    	 try (ObjectInputStream objectInputStream = new ObjectInputStream(clientSocket.getInputStream());
    			 ObjectOutputStream objectOutputStream = new ObjectOutputStream(clientSocket.getOutputStream());
    	        ) {
    		 
    		 while (true) {
    			 System.out.println("Awaiting action command from user");
	    	     String action = (String) objectInputStream.readObject();
	//            String[] tokens = request.split(":");
	//            String action = tokens[0];
	//            String propertyId = tokens[1];
	            switch (action) {
	                case "ADD":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	readPropertyFromStream(objectInputStream);
	                    break;
	                case "SHOW":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	managerUsername = (String) objectInputStream.readObject();
	                	System.out.println("Action at worker:"+action);
	                	System.out.println(managerUsername);
	                	objectOutputStream.writeObject(showManagerProperties(managerUsername));
	                    break;
	                case "AVAILABILITY":
	                	readAvailabilityFromStream(objectInputStream);
	                    break;
	                case "BOOKINGS":
	                	managerUsername = (String) objectInputStream.readObject();
	                	showManagerBookings(managerUsername);
	                    break;
	                case "BOOK":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	DateRange bookingRange = readDateRangeFromStream(objectInputStream);
	                    forwardPropertyBooking(renterUsername, propertyName, bookingRange);
	                    break;
	                case "RATE":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                    forwardPropertyRating(renterUsername, propertyName, stars);
	                    break;
	                case "FILTER":
	                	area = (String) objectInputStream.readObject();
	                	dateRange=readDateRangeFromStream(objectInputStream);
	                	people = (Integer) objectInputStream.readObject();
	                	price = (Integer) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                	forwardPropertyFiltering(area, dateRange, people, price, stars);
	                    break;
	                // Implement cases for other request types (UPDATE, etc.) as needed
	                default:
	                    // Unknown action, send error response
	                    break;
	               }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void readPropertyFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyInfo = (String) objectInputStream.readObject();

        // Read property info
        String[] keyValuePairs = propertyInfo.substring(1, propertyInfo.length() - 1).split(",");

        String roomName = "";
        int noOfPersons = 0;
        String area = "";
        int stars = 0;
        int noOfReviews = 0;
        String roomImage = "";

        // Iterate over key-value pairs and split them based on colons
        for (String pair : keyValuePairs) {
            System.out.println(pair);
            String[] keyValue = pair.split(":");
            String key = keyValue[0].trim().replaceAll("\"", "");
            String value = keyValue[1].trim().replaceAll("\"", ""); // Remove quotes

            // Assign values to appropriate variables based on keys
            switch (key) {
                case "roomName":
                    roomName = value;
                    break;
                case "noOfPersons":
                    noOfPersons = Integer.parseInt(value);
                    break;
                case "area":
                    area = value;
                    break;
                case "stars":
                    stars = Integer.parseInt(value);
                    break;
                case "noOfReviews":
                    noOfReviews = Integer.parseInt(value);
                    break;
                case "roomImage":
                    roomImage = value;
                    break;
            }
        }
        
     // Print the values to verify
        System.out.println("Room Name: " + roomName);
        System.out.println("Number of Persons: " + noOfPersons);
        System.out.println("Area: " + area);
        System.out.println("Stars: " + stars);
        System.out.println("Number of Reviews: " + noOfReviews);
        System.out.println("Room Image: " + roomImage);

        // Read image data
        byte[] imageData = (byte[]) objectInputStream.readObject();

        // Convert byte array to BufferedImage
        ByteArrayInputStream bis = new ByteArrayInputStream(imageData);
//        BufferedImage bufferedImage = ImageIO.read(bis);
        
        forwardPropertyAddition(roomName, managerUsername ,new Property(roomName, noOfPersons, area, stars, noOfReviews, roomImage,propertyCounter), imageData);
        propertyCounter=propertyCounter+1;
        // Return property object with image
    }
    
    private void readAvailabilityFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyName = (String) objectInputStream.readObject();
        
        String dateRangeAvailability = (String) objectInputStream.readObject();
        
        forwardPropertyAvailability(managerUsername, propertyName,dateRangeAvailability);

        // Return property object with image
    }

    private Map<String, Object> readFiltersFromStream(BufferedReader reader) throws IOException {
        Map<String, Object> filters = new HashMap<>();
        
        String line;
        while ((line = reader.readLine()) != null) {
            String[] tokens = line.split(":");
            String filterName = tokens[0];
            Object filterValue = tokens[1]; // Assuming filter value is string for simplicity, you may need to parse it accordingly
            filters.put(filterName, filterValue);
        }
        
        return filters;
    }

    private DateRange readDateRangeFromStream(ObjectInputStream objectInputStream) throws IOException, ParseException, ClassNotFoundException {
    	String startDateStr = (String) objectInputStream.readObject();
        String endDateStr = (String) objectInputStream.readObject();
        // Assuming date format is in "day/month/year"
        SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
        Date startDate = dateFormat.parse(startDateStr);
        Date endDate = dateFormat.parse(endDateStr);
        return new DateRange(startDate, endDate);
    }

    private void forwardPropertyAddition(String propertyName, String managerUsername,Property property, byte [] imageBytes) throws IOException {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new property...");

       String add = "ADD";
       objectOutputStream.writeObject(add);
       System.out.println("ADD SENT");
       objectOutputStream.writeObject(managerUsername);
       objectOutputStream.writeObject(property);
       objectOutputStream.writeObject(imageBytes);

          
    }
    
    private void forwardPropertyAvailability(String managerUsername,String propertyName,String dateRangeAvailability) throws IOException {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);
        

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new availability...");

       String availability = "AVAILABILITY";
       objectOutputStream.writeObject(availability);
       objectOutputStream.writeObject(managerUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(dateRangeAvailability);

    }

    private String showManagerProperties(String managerUsername) throws IOException, ClassNotFoundException {
    	
    	ArrayList<Property> mergedProperties = new ArrayList<>();
        
    	// Iterate over worker ports
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
    	    ObjectInputStream objectInputStream = workerInputStreams.get(i);

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("SHOW");
    	        objectOutputStream.writeObject(managerUsername);
    	        System.out.println("talked to worker");
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> workerProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedProperties.addAll(workerProperties);

    	        System.out.println("Received properties from worker on port: " + port);
    	        
    	        
    	        
    	 
    	}
    	
    	String returnedPropertiesAsString="";
    	
    	System.out.println(mergedProperties.get(0));
    	
    	for (int i=0;i<mergedProperties.size();i++) {
    		returnedPropertiesAsString=returnedPropertiesAsString+mergedProperties.get(i).toString();
    	}
    	
    	return returnedPropertiesAsString;
    	
    }
    	
    	private void showManagerBookings(String managerUsername) throws IOException, ClassNotFoundException {
        	
    		Map<String,List<DateRange>> mergedPropertyNamesBookings= new HashMap<>();
            
        	// Iterate over worker ports
        	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
        	    int port = 5000 + i; // Calculate port number
        	    
        	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
        	    ObjectInputStream objectInputStream = workerInputStreams.get(i);

        	        // Send "SHOW" request to worker
        	        objectOutputStream.writeObject("BOOKINGS");
        	        objectOutputStream.writeObject(managerUsername);
        	        
        	        // Receive ArrayList<Property> response from worker
        	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
        	        Map<String,List<DateRange>> propertyNamesBookings = (Map<String,List<DateRange>>) objectInputStream.readObject();
        	        
                    for (Map.Entry<String, List<DateRange>> entry : propertyNamesBookings.entrySet()) {
                        String propertyName = entry.getKey();
                        List<DateRange> bookings = entry.getValue();
                        
                        if (mergedPropertyNamesBookings.containsKey(propertyName)) {
                            // If the property already exists in the merged map, merge its bookings
                            mergedPropertyNamesBookings.get(propertyName).addAll(bookings);
                        } else {
                            // If the property doesn't exist in the merged map, add it with its bookings
                            mergedPropertyNamesBookings.put(propertyName, new ArrayList<>(bookings));
                        }
                    }
                    
                    for (Map.Entry<String, List<DateRange>> entry : mergedPropertyNamesBookings.entrySet()) {
                        String propertyName = entry.getKey();
                        List<DateRange> bookings = entry.getValue();
                        
                        // Print the property name
                        System.out.println("Property Name: " + propertyName);
                        
                        // Iterate over the list of date ranges for the current property
                        for (DateRange dateRange : bookings) {
                            // Print each date range
                            System.out.println("Date Range: " + dateRange);
                        }
                        
                        // Add a separator for better readability
                        System.out.println("------------------------------------");
                    }
                    
                    System.out.println("Received property bookings from worker on port: " + port);
        	        
        	}
    	
    	try (PrintWriter writer = new PrintWriter(clientSocket.getOutputStream(), true)) {
            // Send the string to the client
            writer.println("These are your properties:");
            System.out.println("Sent merged properties to the client");
        } catch (IOException e) {
            e.printStackTrace();
        }
    	
    }

    private void forwardPropertySearch(String propertyId, Map<String, Object> filters) {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyId.hashCode()) % workers.size();
        Worker worker = workers.get(workerIndex);

        // Search for properties on the chosen worker
        List<Property> searchResults = worker.searchProperties(filters);

        // Print search results to the console
        System.out.println("Search results for property ID " + propertyId + ":");
        for (Property property : searchResults) {
            System.out.println(property.toString()); // Assuming Property class overrides toString() method
        }
    }


    private void forwardPropertyBooking(String renterUsername, String propertyName, DateRange bookingRange) throws IOException {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new booking...");

       String book = "BOOK";
       objectOutputStream.writeObject(book);
       objectOutputStream.writeObject(renterUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(bookingRange);

           
    }
    
    private void forwardPropertyRating(String renterUsername, String propertyName, Integer stars) throws IOException {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new rating...");

       String rate = "RATE";
       objectOutputStream.writeObject(rate);
       objectOutputStream.writeObject(renterUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(stars);

    }
    
    private void forwardPropertyFiltering(String area, DateRange dateRange, Integer people, Integer price, Integer stars) {
    	
    	ArrayList<Property> mergedFilteredProperties= new ArrayList<Property>();
    	
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
    	    ObjectInputStream objectInputStream = workerInputStreams.get(i); {

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("FILTER");
    	        objectOutputStream.writeObject(area);
    	        objectOutputStream.writeObject(dateRange);
    	        objectOutputStream.writeObject(people);
    	        objectOutputStream.writeObject(price);
    	        objectOutputStream.writeObject(stars);
    	        
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> filteredProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedFilteredProperties.addAll(filteredProperties);

    	        System.out.println("Received filtered properties from worker on port: " + port);
    	        
    	        
    	    } catch (IOException | ClassNotFoundException e) {
    	        e.printStackTrace();
    	    }
    	}
    }
    
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-04-12 22:12:04.309
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-04-12 22:12:04.310
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-12 22:12:05.228
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.UnknownHostException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.imageio.ImageIO;

public class Master {
	
	private int propertyCounter;
    private List<Worker> workers;
    private Socket clientSocket;
    private Socket reducerSocket;
    private ArrayList<Socket> workerSockets;
    private ArrayList<ObjectInputStream> workerInputStreams;
    private ArrayList<ObjectOutputStream> workerOutputStreams;
    
    public Master(int[] workerPorts) {
    	Socket sock=null;
    	this.propertyCounter=0;
        this.workers = new ArrayList<>();
        workerSockets=new ArrayList<>();
        workerInputStreams = new ArrayList<>();
        workerOutputStreams = new ArrayList<>();
        
        for (int port : workerPorts) {
            Worker worker = new Worker(port); // Pass the port number to the Worker constructor
			worker.start(); // Start the worker thread
			workers.add(worker);
			System.out.println("Worker connected on port: " + port);
			try {
				sock=new Socket("localhost", port);
				workerInputStreams.add(new ObjectInputStream(sock.getInputStream()));
				workerOutputStreams.add(new ObjectOutputStream(sock.getOutputStream()));
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			workerSockets.add(sock);
			
        }
        
    }


    public void start() throws IOException, ParseException, ClassNotFoundException{
//        for (Worker worker : workers) {
//            worker.start();
//        }
        // Start listening for client requests
        try (ServerSocket serverSocket = new ServerSocket(5000)) {
            System.out.println("Master server started...");
            while (true) {
                clientSocket = serverSocket.accept();
                System.out.println("A");
                handleClientRequest(clientSocket);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void handleClientRequest(Socket clientSocket) throws IOException, ParseException, ClassNotFoundException {
    	
    	String managerUsername;
    	String renterUsername;
    	String propertyName;
    	Integer stars;
    	String area;
    	DateRange dateRange;
    	Integer people;
    	Integer price;
    	
    	 try (ObjectInputStream objectInputStream = new ObjectInputStream(clientSocket.getInputStream());
    			 ObjectOutputStream objectOutputStream = new ObjectOutputStream(clientSocket.getOutputStream());
    	        ) {
    		 
    		 while (true) {
    			 System.out.println("Awaiting action command from user");
	    	     String action = (String) objectInputStream.readObject();
	//            String[] tokens = request.split(":");
	//            String action = tokens[0];
	//            String propertyId = tokens[1];
	            switch (action) {
	                case "ADD":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	readPropertyFromStream(objectInputStream);
	                    break;
	                case "SHOW":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	managerUsername = (String) objectInputStream.readObject();
	                	System.out.println("Action at worker:"+action);
	                	System.out.println(managerUsername);
	                	objectOutputStream.writeObject(showManagerProperties(managerUsername));
	                    break;
	                case "AVAILABILITY":
	                	readAvailabilityFromStream(objectInputStream);
	                    break;
	                case "BOOKINGS":
	                	managerUsername = (String) objectInputStream.readObject();
	                	showManagerBookings(managerUsername);
	                    break;
	                case "BOOK":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	DateRange bookingRange = readDateRangeFromStream(objectInputStream);
	                    forwardPropertyBooking(renterUsername, propertyName, bookingRange);
	                    break;
	                case "RATE":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                    forwardPropertyRating(renterUsername, propertyName, stars);
	                    break;
	                case "FILTER":
	                	area = (String) objectInputStream.readObject();
	                	dateRange=readDateRangeFromStream(objectInputStream);
	                	people = (Integer) objectInputStream.readObject();
	                	price = (Integer) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                	forwardPropertyFiltering(area, dateRange, people, price, stars);
	                    break;
	                // Implement cases for other request types (UPDATE, etc.) as needed
	                default:
	                    // Unknown action, send error response
	                    break;
	               }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void readPropertyFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyInfo = (String) objectInputStream.readObject();

        // Read property info
        String[] keyValuePairs = propertyInfo.substring(1, propertyInfo.length() - 1).split(",");

        String roomName = "";
        int noOfPersons = 0;
        String area = "";
        int stars = 0;
        int noOfReviews = 0;
        String roomImage = "";

        // Iterate over key-value pairs and split them based on colons
        for (String pair : keyValuePairs) {
            System.out.println(pair);
            String[] keyValue = pair.split(":");
            String key = keyValue[0].trim().replaceAll("\"", "");
            String value = keyValue[1].trim().replaceAll("\"", ""); // Remove quotes

            // Assign values to appropriate variables based on keys
            switch (key) {
                case "roomName":
                    roomName = value;
                    break;
                case "noOfPersons":
                    noOfPersons = Integer.parseInt(value);
                    break;
                case "area":
                    area = value;
                    break;
                case "stars":
                    stars = Integer.parseInt(value);
                    break;
                case "noOfReviews":
                    noOfReviews = Integer.parseInt(value);
                    break;
                case "roomImage":
                    roomImage = value;
                    break;
            }
        }
        
     // Print the values to verify
        System.out.println("Room Name: " + roomName);
        System.out.println("Number of Persons: " + noOfPersons);
        System.out.println("Area: " + area);
        System.out.println("Stars: " + stars);
        System.out.println("Number of Reviews: " + noOfReviews);
        System.out.println("Room Image: " + roomImage);

        // Read image data
        byte[] imageData = (byte[]) objectInputStream.readObject();

        // Convert byte array to BufferedImage
        ByteArrayInputStream bis = new ByteArrayInputStream(imageData);
//        BufferedImage bufferedImage = ImageIO.read(bis);
        
        forwardPropertyAddition(roomName, managerUsername ,new Property(roomName, noOfPersons, area, stars, noOfReviews, roomImage,propertyCounter), imageData);
        propertyCounter=propertyCounter+1;
        // Return property object with image
    }
    
    private void readAvailabilityFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyName = (String) objectInputStream.readObject();
        
        String dateRangeAvailability = (String) objectInputStream.readObject();
        
        forwardPropertyAvailability(managerUsername, propertyName,dateRangeAvailability);

        // Return property object with image
    }

    private Map<String, Object> readFiltersFromStream(BufferedReader reader) throws IOException {
        Map<String, Object> filters = new HashMap<>();
        
        String line;
        while ((line = reader.readLine()) != null) {
            String[] tokens = line.split(":");
            String filterName = tokens[0];
            Object filterValue = tokens[1]; // Assuming filter value is string for simplicity, you may need to parse it accordingly
            filters.put(filterName, filterValue);
        }
        
        return filters;
    }

    private DateRange readDateRangeFromStream(ObjectInputStream objectInputStream) throws IOException, ParseException, ClassNotFoundException {
    	String startDateStr = (String) objectInputStream.readObject();
        String endDateStr = (String) objectInputStream.readObject();
        // Assuming date format is in "day/month/year"
        SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
        Date startDate = dateFormat.parse(startDateStr);
        Date endDate = dateFormat.parse(endDateStr);
        return new DateRange(startDate, endDate);
    }

    private void forwardPropertyAddition(String propertyName, String managerUsername,Property property, byte [] imageBytes) throws IOException {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new property...");

       String add = "ADD";
       objectOutputStream.writeObject(add);
       System.out.println("ADD SENT");
       objectOutputStream.writeObject(managerUsername);
       objectOutputStream.writeObject(property);
       objectOutputStream.writeObject(imageBytes);

          
    }
    
    private void forwardPropertyAvailability(String managerUsername,String propertyName,String dateRangeAvailability) throws IOException {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);
        

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new availability...");

       String availability = "AVAILABILITY";
       objectOutputStream.writeObject(availability);
       objectOutputStream.writeObject(managerUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(dateRangeAvailability);

    }

    private String showManagerProperties(String managerUsername) throws IOException, ClassNotFoundException {
    	
    	ArrayList<Property> mergedProperties = new ArrayList<>();
        
    	// Iterate over worker ports
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
    	    ObjectInputStream objectInputStream = workerInputStreams.get(i);

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("SHOW");
    	        objectOutputStream.writeObject(managerUsername);
    	        System.out.println("talked to worker");
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> workerProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedProperties.addAll(workerProperties);

    	        System.out.println("Received properties from worker on port: " + port);
    	        
    	        
    	        
    	 
    	}
    	
    	String returnedPropertiesAsString="";
    	
    	System.out.println(mergedProperties.get(0));
    	
    	for (int i=0;i<mergedProperties.size();i++) {
    		returnedPropertiesAsString=returnedPropertiesAsString+mergedProperties.get(i).toString();
    	}
    	
    	return returnedPropertiesAsString;
    	
    }
    	
    	private void showManagerBookings(String managerUsername) throws IOException, ClassNotFoundException {
        	
    		Map<String,List<DateRange>> mergedPropertyNamesBookings= new HashMap<>();
            
        	// Iterate over worker ports
        	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
        	    int port = 5000 + i; // Calculate port number
        	    
        	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
        	    ObjectInputStream objectInputStream = workerInputStreams.get(i);

        	        // Send "SHOW" request to worker
        	        objectOutputStream.writeObject("BOOKINGS");
        	        objectOutputStream.writeObject(managerUsername);
        	        
        	        // Receive ArrayList<Property> response from worker
        	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
        	        Map<String,List<DateRange>> propertyNamesBookings = (Map<String,List<DateRange>>) objectInputStream.readObject();
        	        
                    for (Map.Entry<String, List<DateRange>> entry : propertyNamesBookings.entrySet()) {
                        String propertyName = entry.getKey();
                        List<DateRange> bookings = entry.getValue();
                        
                        if (mergedPropertyNamesBookings.containsKey(propertyName)) {
                            // If the property already exists in the merged map, merge its bookings
                            mergedPropertyNamesBookings.get(propertyName).addAll(bookings);
                        } else {
                            // If the property doesn't exist in the merged map, add it with its bookings
                            mergedPropertyNamesBookings.put(propertyName, new ArrayList<>(bookings));
                        }
                    }
                    
                    for (Map.Entry<String, List<DateRange>> entry : mergedPropertyNamesBookings.entrySet()) {
                        String propertyName = entry.getKey();
                        List<DateRange> bookings = entry.getValue();
                        
                        // Print the property name
                        System.out.println("Property Name: " + propertyName);
                        
                        // Iterate over the list of date ranges for the current property
                        for (DateRange dateRange : bookings) {
                            // Print each date range
                            System.out.println("Date Range: " + dateRange);
                        }
                        
                        // Add a separator for better readability
                        System.out.println("------------------------------------");
                    }
                    
                    System.out.println("Received property bookings from worker on port: " + port);
        	        
        	}
    	
    	try (PrintWriter writer = new PrintWriter(clientSocket.getOutputStream(), true)) {
            // Send the string to the client
            writer.println("These are your properties:");
            System.out.println("Sent merged properties to the client");
        } catch (IOException e) {
            e.printStackTrace();
        }
    	
    }

    private void forwardPropertySearch(String propertyId, Map<String, Object> filters) {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyId.hashCode()) % workers.size();
        Worker worker = workers.get(workerIndex);

        // Search for properties on the chosen worker
        List<Property> searchResults = worker.searchProperties(filters);

        // Print search results to the console
        System.out.println("Search results for property ID " + propertyId + ":");
        for (Property property : searchResults) {
            System.out.println(property.toString()); // Assuming Property class overrides toString() method
        }
    }


    private void forwardPropertyBooking(String renterUsername, String propertyName, DateRange bookingRange) throws IOException {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new booking...");

       String book = "BOOK";
       objectOutputStream.writeObject(book);
       objectOutputStream.writeObject(renterUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(bookingRange);

           
    }
    
    private void forwardPropertyRating(String renterUsername, String propertyName, Integer stars) throws IOException {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new rating...");

       String rate = "RATE";
       objectOutputStream.writeObject(rate);
       objectOutputStream.writeObject(renterUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(stars);

    }
    
    private void forwardPropertyFiltering(String area, DateRange dateRange, Integer people, Integer price, Integer stars) {
    	
    	ArrayList<Property> mergedFilteredProperties= new ArrayList<Property>();
    	
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
    	    ObjectInputStream objectInputStream = workerInputStreams.get(i); {

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("FILTER");
    	        objectOutputStream.writeObject(area);
    	        objectOutputStream.writeObject(dateRange);
    	        objectOutputStream.writeObject(people);
    	        objectOutputStream.writeObject(price);
    	        objectOutputStream.writeObject(stars);
    	        
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> filteredProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedFilteredProperties.addAll(filteredProperties);

    	        System.out.println("Received filtered properties from worker on port: " + port);
    	        
    	        
    	    } catch (IOException | ClassNotFoundException e) {
    	        e.printStackTrace();
    	    }
    	}
    }
    
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2024-04-12 22:12:05.230
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2024-04-12 22:12:05.231
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-12 22:12:05.264
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.UnknownHostException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.imageio.ImageIO;

public class Master {
	
	private int propertyCounter;
    private List<Worker> workers;
    private Socket clientSocket;
    private Socket reducerSocket;
    private ArrayList<Socket> workerSockets;
    private ArrayList<ObjectInputStream> workerInputStreams;
    private ArrayList<ObjectOutputStream> workerOutputStreams;
    
    public Master(int[] workerPorts) {
    	Socket sock=null;
    	this.propertyCounter=0;
        this.workers = new ArrayList<>();
        workerSockets=new ArrayList<>();
        workerInputStreams = new ArrayList<>();
        workerOutputStreams = new ArrayList<>();
        
        for (int port : workerPorts) {
            Worker worker = new Worker(port); // Pass the port number to the Worker constructor
			worker.start(); // Start the worker thread
			workers.add(worker);
			System.out.println("Worker connected on port: " + port);
			try {
				sock=new Socket("localhost", port);
				workerInputStreams.add(new ObjectInputStream(sock.getInputStream()));
				workerOutputStreams.add(new ObjectOutputStream(sock.getOutputStream()));
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			workerSockets.add(sock);
			
        }
        
    }


    public void start() throws IOException, ParseException, ClassNotFoundException{
//        for (Worker worker : workers) {
//            worker.start();
//        }
        // Start listening for client requests
        try (ServerSocket serverSocket = new ServerSocket(5000)) {
            System.out.println("Master server started...");
            while (true) {
                clientSocket = serverSocket.accept();
                System.out.println("A");
                handleClientRequest(clientSocket);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void handleClientRequest(Socket clientSocket) throws IOException, ParseException, ClassNotFoundException {
    	
    	String managerUsername;
    	String renterUsername;
    	String propertyName;
    	Integer stars;
    	String area;
    	DateRange dateRange;
    	Integer people;
    	Integer price;
    	
    	 try (ObjectInputStream objectInputStream = new ObjectInputStream(clientSocket.getInputStream());
    			 ObjectOutputStream objectOutputStream = new ObjectOutputStream(clientSocket.getOutputStream());
    	        ) {
    		 
    		 while (true) {
    			 System.out.println("Awaiting action command from user");
	    	     String action = (String) objectInputStream.readObject();
	//            String[] tokens = request.split(":");
	//            String action = tokens[0];
	//            String propertyId = tokens[1];
	            switch (action) {
	                case "ADD":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	readPropertyFromStream(objectInputStream);
	                    break;
	                case "SHOW":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	managerUsername = (String) objectInputStream.readObject();
	                	System.out.println("Action at worker:"+action);
	                	System.out.println(managerUsername);
	                	objectOutputStream.writeObject(showManagerProperties(managerUsername));
	                    break;
	                case "AVAILABILITY":
	                	readAvailabilityFromStream(objectInputStream);
	                    break;
	                case "BOOKINGS":
	                	managerUsername = (String) objectInputStream.readObject();
	                	showManagerBookings(managerUsername);
	                    break;
	                case "BOOK":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	DateRange bookingRange = readDateRangeFromStream(objectInputStream);
	                    forwardPropertyBooking(renterUsername, propertyName, bookingRange);
	                    break;
	                case "RATE":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                    forwardPropertyRating(renterUsername, propertyName, stars);
	                    break;
	                case "FILTER":
	                	area = (String) objectInputStream.readObject();
	                	dateRange=readDateRangeFromStream(objectInputStream);
	                	people = (Integer) objectInputStream.readObject();
	                	price = (Integer) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                	forwardPropertyFiltering(area, dateRange, people, price, stars);
	                    break;
	                // Implement cases for other request types (UPDATE, etc.) as needed
	                default:
	                    // Unknown action, send error response
	                    break;
	               }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void readPropertyFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyInfo = (String) objectInputStream.readObject();

        // Read property info
        String[] keyValuePairs = propertyInfo.substring(1, propertyInfo.length() - 1).split(",");

        String roomName = "";
        int noOfPersons = 0;
        String area = "";
        int stars = 0;
        int noOfReviews = 0;
        String roomImage = "";

        // Iterate over key-value pairs and split them based on colons
        for (String pair : keyValuePairs) {
            System.out.println(pair);
            String[] keyValue = pair.split(":");
            String key = keyValue[0].trim().replaceAll("\"", "");
            String value = keyValue[1].trim().replaceAll("\"", ""); // Remove quotes

            // Assign values to appropriate variables based on keys
            switch (key) {
                case "roomName":
                    roomName = value;
                    break;
                case "noOfPersons":
                    noOfPersons = Integer.parseInt(value);
                    break;
                case "area":
                    area = value;
                    break;
                case "stars":
                    stars = Integer.parseInt(value);
                    break;
                case "noOfReviews":
                    noOfReviews = Integer.parseInt(value);
                    break;
                case "roomImage":
                    roomImage = value;
                    break;
            }
        }
        
     // Print the values to verify
        System.out.println("Room Name: " + roomName);
        System.out.println("Number of Persons: " + noOfPersons);
        System.out.println("Area: " + area);
        System.out.println("Stars: " + stars);
        System.out.println("Number of Reviews: " + noOfReviews);
        System.out.println("Room Image: " + roomImage);

        // Read image data
        byte[] imageData = (byte[]) objectInputStream.readObject();

        // Convert byte array to BufferedImage
        ByteArrayInputStream bis = new ByteArrayInputStream(imageData);
//        BufferedImage bufferedImage = ImageIO.read(bis);
        
        forwardPropertyAddition(roomName, managerUsername ,new Property(roomName, noOfPersons, area, stars, noOfReviews, roomImage,propertyCounter), imageData);
        propertyCounter=propertyCounter+1;
        // Return property object with image
    }
    
    private void readAvailabilityFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyName = (String) objectInputStream.readObject();
        
        String dateRangeAvailability = (String) objectInputStream.readObject();
        
        forwardPropertyAvailability(managerUsername, propertyName,dateRangeAvailability);

        // Return property object with image
    }

    private Map<String, Object> readFiltersFromStream(BufferedReader reader) throws IOException {
        Map<String, Object> filters = new HashMap<>();
        
        String line;
        while ((line = reader.readLine()) != null) {
            String[] tokens = line.split(":");
            String filterName = tokens[0];
            Object filterValue = tokens[1]; // Assuming filter value is string for simplicity, you may need to parse it accordingly
            filters.put(filterName, filterValue);
        }
        
        return filters;
    }

    private DateRange readDateRangeFromStream(ObjectInputStream objectInputStream) throws IOException, ParseException, ClassNotFoundException {
    	String startDateStr = (String) objectInputStream.readObject();
        String endDateStr = (String) objectInputStream.readObject();
        // Assuming date format is in "day/month/year"
        SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
        Date startDate = dateFormat.parse(startDateStr);
        Date endDate = dateFormat.parse(endDateStr);
        return new DateRange(startDate, endDate);
    }

    private void forwardPropertyAddition(String propertyName, String managerUsername,Property property, byte [] imageBytes) throws IOException {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new property...");

       String add = "ADD";
       objectOutputStream.writeObject(add);
       System.out.println("ADD SENT");
       objectOutputStream.writeObject(managerUsername);
       objectOutputStream.writeObject(property);
       objectOutputStream.writeObject(imageBytes);

          
    }
    
    private void forwardPropertyAvailability(String managerUsername,String propertyName,String dateRangeAvailability) throws IOException {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);
        

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new availability...");

       String availability = "AVAILABILITY";
       objectOutputStream.writeObject(availability);
       objectOutputStream.writeObject(managerUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(dateRangeAvailability);

    }

    private String showManagerProperties(String managerUsername) throws IOException, ClassNotFoundException {
    	
    	ArrayList<Property> mergedProperties = new ArrayList<>();
        
    	// Iterate over worker ports
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
    	    ObjectInputStream objectInputStream = workerInputStreams.get(i);

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("SHOW");
    	        objectOutputStream.writeObject(managerUsername);
    	        System.out.println("talked to worker");
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> workerProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedProperties.addAll(workerProperties);

    	        System.out.println("Received properties from worker on port: " + port);
    	        
    	        
    	        
    	 
    	}
    	
    	String returnedPropertiesAsString="";
    	
    	System.out.println(mergedProperties.get(0));
    	
    	for (int i=0;i<mergedProperties.size();i++) {
    		returnedPropertiesAsString=returnedPropertiesAsString+mergedProperties.get(i).toString();
    	}
    	
    	return returnedPropertiesAsString;
    	
    }
    	
    	private void showManagerBookings(String managerUsername) throws IOException, ClassNotFoundException {
        	
    		Map<String,List<DateRange>> mergedPropertyNamesBookings= new HashMap<>();
            
        	// Iterate over worker ports
        	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
        	    int port = 5000 + i; // Calculate port number
        	    
        	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
        	    ObjectInputStream objectInputStream = workerInputStreams.get(i);

        	        // Send "SHOW" request to worker
        	        objectOutputStream.writeObject("BOOKINGS");
        	        objectOutputStream.writeObject(managerUsername);
        	        
        	        // Receive ArrayList<Property> response from worker
        	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
        	        Map<String,List<DateRange>> propertyNamesBookings = (Map<String,List<DateRange>>) objectInputStream.readObject();
        	        
                    for (Map.Entry<String, List<DateRange>> entry : propertyNamesBookings.entrySet()) {
                        String propertyName = entry.getKey();
                        List<DateRange> bookings = entry.getValue();
                        
                        if (mergedPropertyNamesBookings.containsKey(propertyName)) {
                            // If the property already exists in the merged map, merge its bookings
                            mergedPropertyNamesBookings.get(propertyName).addAll(bookings);
                        } else {
                            // If the property doesn't exist in the merged map, add it with its bookings
                            mergedPropertyNamesBookings.put(propertyName, new ArrayList<>(bookings));
                        }
                    }
                    
                    for (Map.Entry<String, List<DateRange>> entry : mergedPropertyNamesBookings.entrySet()) {
                        String propertyName = entry.getKey();
                        List<DateRange> bookings = entry.getValue();
                        
                        // Print the property name
                        System.out.println("Property Name: " + propertyName);
                        
                        // Iterate over the list of date ranges for the current property
                        for (DateRange dateRange : bookings) {
                            // Print each date range
                            System.out.println("Date Range: " + dateRange);
                        }
                        
                        // Add a separator for better readability
                        System.out.println("------------------------------------");
                    }
                    
                    System.out.println("Received property bookings from worker on port: " + port);
        	        
        	}
    	
    	try (PrintWriter writer = new PrintWriter(clientSocket.getOutputStream(), true)) {
            // Send the string to the client
            writer.println("These are your properties:");
            System.out.println("Sent merged properties to the client");
        } catch (IOException e) {
            e.printStackTrace();
        }
    	
    }

    private void forwardPropertySearch(String propertyId, Map<String, Object> filters) {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyId.hashCode()) % workers.size();
        Worker worker = workers.get(workerIndex);

        // Search for properties on the chosen worker
        List<Property> searchResults = worker.searchProperties(filters);

        // Print search results to the console
        System.out.println("Search results for property ID " + propertyId + ":");
        for (Property property : searchResults) {
            System.out.println(property.toString()); // Assuming Property class overrides toString() method
        }
    }


    private void forwardPropertyBooking(String renterUsername, String propertyName, DateRange bookingRange) throws IOException {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new booking...");

       String book = "BOOK";
       objectOutputStream.writeObject(book);
       objectOutputStream.writeObject(renterUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(bookingRange);

           
    }
    
    private void forwardPropertyRating(String renterUsername, String propertyName, Integer stars) throws IOException {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new rating...");

       String rate = "RATE";
       objectOutputStream.writeObject(rate);
       objectOutputStream.writeObject(renterUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(stars);

    }
    
    private void forwardPropertyFiltering(String area, DateRange dateRange, Integer people, Integer price, Integer stars) {
    	
    	ArrayList<Property> mergedFilteredProperties= new ArrayList<Property>();
    	
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
    	    ObjectInputStream objectInputStream = workerInputStreams.get(i); {

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("FILTER");
    	        objectOutputStream.writeObject(area);
    	        objectOutputStream.writeObject(dateRange);
    	        objectOutputStream.writeObject(people);
    	        objectOutputStream.writeObject(price);
    	        objectOutputStream.writeObject(stars);
    	        
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> filteredProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedFilteredProperties.addAll(filteredProperties);

    	        System.out.println("Received filtered properties from worker on port: " + port);
    	        
    	        
    	    } catch (IOException | ClassNotFoundException e) {
    	        e.printStackTrace();
    	    }
    	}
    }
    
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-04-12 22:12:05.267
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-04-12 22:12:05.268
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:251)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:386)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:362)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-12 22:12:06.760
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.UnknownHostException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.imageio.ImageIO;

public class Master {
	
	private int propertyCounter;
    private List<Worker> workers;
    private Socket clientSocket;
    private Socket reducerSocket;
    private ArrayList<Socket> workerSockets;
    private ArrayList<ObjectInputStream> workerInputStreams;
    private ArrayList<ObjectOutputStream> workerOutputStreams;
    
    public Master(int[] workerPorts) {
    	Socket sock=null;
    	this.propertyCounter=0;
        this.workers = new ArrayList<>();
        workerSockets=new ArrayList<>();
        workerInputStreams = new ArrayList<>();
        workerOutputStreams = new ArrayList<>();
        
        for (int port : workerPorts) {
            Worker worker = new Worker(port); // Pass the port number to the Worker constructor
			worker.start(); // Start the worker thread
			workers.add(worker);
			System.out.println("Worker connected on port: " + port);
			try {
				sock=new Socket("localhost", port);
				workerInputStreams.add(new ObjectInputStream(sock.getInputStream()));
				workerOutputStreams.add(new ObjectOutputStream(sock.getOutputStream()));
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			workerSockets.add(sock);
			
        }
        
    }


    public void start() throws IOException, ParseException, ClassNotFoundException{
//        for (Worker worker : workers) {
//            worker.start();
//        }
        // Start listening for client requests
        try (ServerSocket serverSocket = new ServerSocket(5000)) {
            System.out.println("Master server started...");
            while (true) {
                clientSocket = serverSocket.accept();
                System.out.println("A");
                handleClientRequest(clientSocket);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void handleClientRequest(Socket clientSocket) throws IOException, ParseException, ClassNotFoundException {
    	
    	String managerUsername;
    	String renterUsername;
    	String propertyName;
    	Integer stars;
    	String area;
    	DateRange dateRange;
    	Integer people;
    	Integer price;
    	
    	 try (ObjectInputStream objectInputStream = new ObjectInputStream(clientSocket.getInputStream());
    			 ObjectOutputStream objectOutputStream = new ObjectOutputStream(clientSocket.getOutputStream());
    	        ) {
    		 
    		 while (true) {
    			 System.out.println("Awaiting action command from user");
	    	     String action = (String) objectInputStream.readObject();
	//            String[] tokens = request.split(":");
	//            String action = tokens[0];
	//            String propertyId = tokens[1];
	            switch (action) {
	                case "ADD":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	readPropertyFromStream(objectInputStream);
	                    break;
	                case "SHOW":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	managerUsername = (String) objectInputStream.readObject();
	                	System.out.println("Action at worker:"+action);
	                	System.out.println(managerUsername);
	                	objectOutputStream.writeObject(showManagerProperties(managerUsername));
	                    break;
	                case "AVAILABILITY":
	                	readAvailabilityFromStream(objectInputStream);
	                    break;
	                case "BOOKINGS":
	                	managerUsername = (String) objectInputStream.readObject();
	                	showManagerBookings(managerUsername);
	                    break;
	                case "BOOK":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	DateRange bookingRange = readDateRangeFromStream(objectInputStream);
	                    forwardPropertyBooking(renterUsername, propertyName, bookingRange);
	                    break;
	                case "RATE":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                    forwardPropertyRating(renterUsername, propertyName, stars);
	                    break;
	                case "FILTER":
	                	area = (String) objectInputStream.readObject();
	                	dateRange=readDateRangeFromStream(objectInputStream);
	                	people = (Integer) objectInputStream.readObject();
	                	price = (Integer) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                	forwardPropertyFiltering(area, dateRange, people, price, stars);
	                    break;
	                // Implement cases for other request types (UPDATE, etc.) as needed
	                default:
	                    // Unknown action, send error response
	                    break;
	               }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void readPropertyFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyInfo = (String) objectInputStream.readObject();

        // Read property info
        String[] keyValuePairs = propertyInfo.substring(1, propertyInfo.length() - 1).split(",");

        String roomName = "";
        int noOfPersons = 0;
        String area = "";
        int stars = 0;
        int noOfReviews = 0;
        String roomImage = "";

        // Iterate over key-value pairs and split them based on colons
        for (String pair : keyValuePairs) {
            System.out.println(pair);
            String[] keyValue = pair.split(":");
            String key = keyValue[0].trim().replaceAll("\"", "");
            String value = keyValue[1].trim().replaceAll("\"", ""); // Remove quotes

            // Assign values to appropriate variables based on keys
            switch (key) {
                case "roomName":
                    roomName = value;
                    break;
                case "noOfPersons":
                    noOfPersons = Integer.parseInt(value);
                    break;
                case "area":
                    area = value;
                    break;
                case "stars":
                    stars = Integer.parseInt(value);
                    break;
                case "noOfReviews":
                    noOfReviews = Integer.parseInt(value);
                    break;
                case "roomImage":
                    roomImage = value;
                    break;
            }
        }
        
     // Print the values to verify
        System.out.println("Room Name: " + roomName);
        System.out.println("Number of Persons: " + noOfPersons);
        System.out.println("Area: " + area);
        System.out.println("Stars: " + stars);
        System.out.println("Number of Reviews: " + noOfReviews);
        System.out.println("Room Image: " + roomImage);

        // Read image data
        byte[] imageData = (byte[]) objectInputStream.readObject();

        // Convert byte array to BufferedImage
        ByteArrayInputStream bis = new ByteArrayInputStream(imageData);
//        BufferedImage bufferedImage = ImageIO.read(bis);
        
        forwardPropertyAddition(roomName, managerUsername ,new Property(roomName, noOfPersons, area, stars, noOfReviews, roomImage,propertyCounter), imageData);
        propertyCounter=propertyCounter+1;
        // Return property object with image
    }
    
    private void readAvailabilityFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyName = (String) objectInputStream.readObject();
        
        String dateRangeAvailability = (String) objectInputStream.readObject();
        
        forwardPropertyAvailability(managerUsername, propertyName,dateRangeAvailability);

        // Return property object with image
    }

    private Map<String, Object> readFiltersFromStream(BufferedReader reader) throws IOException {
        Map<String, Object> filters = new HashMap<>();
        
        String line;
        while ((line = reader.readLine()) != null) {
            String[] tokens = line.split(":");
            String filterName = tokens[0];
            Object filterValue = tokens[1]; // Assuming filter value is string for simplicity, you may need to parse it accordingly
            filters.put(filterName, filterValue);
        }
        
        return filters;
    }

    private DateRange readDateRangeFromStream(ObjectInputStream objectInputStream) throws IOException, ParseException, ClassNotFoundException {
    	String startDateStr = (String) objectInputStream.readObject();
        String endDateStr = (String) objectInputStream.readObject();
        // Assuming date format is in "day/month/year"
        SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
        Date startDate = dateFormat.parse(startDateStr);
        Date endDate = dateFormat.parse(endDateStr);
        return new DateRange(startDate, endDate);
    }

    private void forwardPropertyAddition(String propertyName, String managerUsername,Property property, byte [] imageBytes) throws IOException {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new property...");

       String add = "ADD";
       objectOutputStream.writeObject(add);
       System.out.println("ADD SENT");
       objectOutputStream.writeObject(managerUsername);
       objectOutputStream.writeObject(property);
       objectOutputStream.writeObject(imageBytes);

          
    }
    
    private void forwardPropertyAvailability(String managerUsername,String propertyName,String dateRangeAvailability) throws IOException {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);
        

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new availability...");

       String availability = "AVAILABILITY";
       objectOutputStream.writeObject(availability);
       objectOutputStream.writeObject(managerUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(dateRangeAvailability);

    }

    private String showManagerProperties(String managerUsername) throws IOException, ClassNotFoundException {
    	
    	ArrayList<Property> mergedProperties = new ArrayList<>();
        
    	// Iterate over worker ports
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
    	    ObjectInputStream objectInputStream = workerInputStreams.get(i);

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("SHOW");
    	        objectOutputStream.writeObject(managerUsername);
    	        System.out.println("talked to worker");
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> workerProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedProperties.addAll(workerProperties);

    	        System.out.println("Received properties from worker on port: " + port);
    	        
    	        
    	        
    	 
    	}
    	
    	String returnedPropertiesAsString="";
    	
    	System.out.println(mergedProperties.get(0));
    	
    	for (int i=0;i<mergedProperties.size();i++) {
    		returnedPropertiesAsString=returnedPropertiesAsString+mergedProperties.get(i).toString();
    	}
    	
    	return returnedPropertiesAsString;
    	
    }
    	
    	private void showManagerBookings(String managerUsername) throws IOException, ClassNotFoundException {
        	
    		Map<String,List<DateRange>> mergedPropertyNamesBookings= new HashMap<>();
            
        	// Iterate over worker ports
        	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
        	    int port = 5000 + i; // Calculate port number
        	    
        	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
        	    ObjectInputStream objectInputStream = workerInputStreams.get(i);

        	        // Send "SHOW" request to worker
        	        objectOutputStream.writeObject("BOOKINGS");
        	        objectOutputStream.writeObject(managerUsername);
        	        
        	        // Receive ArrayList<Property> response from worker
        	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
        	        Map<String,List<DateRange>> propertyNamesBookings = (Map<String,List<DateRange>>) objectInputStream.readObject();
        	        
                    for (Map.Entry<String, List<DateRange>> entry : propertyNamesBookings.entrySet()) {
                        String propertyName = entry.getKey();
                        List<DateRange> bookings = entry.getValue();
                        
                        if (mergedPropertyNamesBookings.containsKey(propertyName)) {
                            // If the property already exists in the merged map, merge its bookings
                            mergedPropertyNamesBookings.get(propertyName).addAll(bookings);
                        } else {
                            // If the property doesn't exist in the merged map, add it with its bookings
                            mergedPropertyNamesBookings.put(propertyName, new ArrayList<>(bookings));
                        }
                    }
                    
                    for (Map.Entry<String, List<DateRange>> entry : mergedPropertyNamesBookings.entrySet()) {
                        String propertyName = entry.getKey();
                        List<DateRange> bookings = entry.getValue();
                        
                        // Print the property name
                        System.out.println("Property Name: " + propertyName);
                        
                        // Iterate over the list of date ranges for the current property
                        for (DateRange dateRange : bookings) {
                            // Print each date range
                            System.out.println("Date Range: " + dateRange);
                        }
                        
                        // Add a separator for better readability
                        System.out.println("------------------------------------");
                    }
                    
                    System.out.println("Received property bookings from worker on port: " + port);
        	        
        	}
    	
    	try (PrintWriter writer = new PrintWriter(clientSocket.getOutputStream(), true)) {
            // Send the string to the client
            writer.println("These are your properties:");
            System.out.println("Sent merged properties to the client");
        } catch (IOException e) {
            e.printStackTrace();
        }
    	
    }

    private void forwardPropertySearch(String propertyId, Map<String, Object> filters) {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyId.hashCode()) % workers.size();
        Worker worker = workers.get(workerIndex);

        // Search for properties on the chosen worker
        List<Property> searchResults = worker.searchProperties(filters);

        // Print search results to the console
        System.out.println("Search results for property ID " + propertyId + ":");
        for (Property property : searchResults) {
            System.out.println(property.toString()); // Assuming Property class overrides toString() method
        }
    }


    private void forwardPropertyBooking(String renterUsername, String propertyName, DateRange bookingRange) throws IOException {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new booking...");

       String book = "BOOK";
       objectOutputStream.writeObject(book);
       objectOutputStream.writeObject(renterUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(bookingRange);

           
    }
    
    private void forwardPropertyRating(String renterUsername, String propertyName, Integer stars) throws IOException {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new rating...");

       String rate = "RATE";
       objectOutputStream.writeObject(rate);
       objectOutputStream.writeObject(renterUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(stars);

    }
    
    private void forwardPropertyFiltering(String area, DateRange dateRange, Integer people, Integer price, Integer stars) {
    	
    	ArrayList<Property> mergedFilteredProperties= new ArrayList<Property>();
    	
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
    	    ObjectInputStream objectInputStream = workerInputStreams.get(i); 

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("FILTER");
    	        objectOutputStream.writeObject(area);
    	        objectOutputStream.writeObject(dateRange);
    	        objectOutputStream.writeObject(people);
    	        objectOutputStream.writeObject(price);
    	        objectOutputStream.writeObject(stars);
    	        
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> filteredProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedFilteredProperties.addAll(filteredProperties);

    	        System.out.println("Received filtered properties from worker on port: " + port);
    	        
    	        
    	    } catch (IOException | ClassNotFoundException e) {
    	        e.printStackTrace();
    	    }
    	}
    }
    
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2024-04-12 22:12:06.762
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2024-04-12 22:12:06.763
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2024-04-12 22:12:06.791
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.UnknownHostException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.imageio.ImageIO;

public class Master {
	
	private int propertyCounter;
    private List<Worker> workers;
    private Socket clientSocket;
    private Socket reducerSocket;
    private ArrayList<Socket> workerSockets;
    private ArrayList<ObjectInputStream> workerInputStreams;
    private ArrayList<ObjectOutputStream> workerOutputStreams;
    
    public Master(int[] workerPorts) {
    	Socket sock=null;
    	this.propertyCounter=0;
        this.workers = new ArrayList<>();
        workerSockets=new ArrayList<>();
        workerInputStreams = new ArrayList<>();
        workerOutputStreams = new ArrayList<>();
        
        for (int port : workerPorts) {
            Worker worker = new Worker(port); // Pass the port number to the Worker constructor
			worker.start(); // Start the worker thread
			workers.add(worker);
			System.out.println("Worker connected on port: " + port);
			try {
				sock=new Socket("localhost", port);
				workerInputStreams.add(new ObjectInputStream(sock.getInputStream()));
				workerOutputStreams.add(new ObjectOutputStream(sock.getOutputStream()));
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			workerSockets.add(sock);
			
        }
        
    }


    public void start() throws IOException, ParseException, ClassNotFoundException{
//        for (Worker worker : workers) {
//            worker.start();
//        }
        // Start listening for client requests
        try (ServerSocket serverSocket = new ServerSocket(5000)) {
            System.out.println("Master server started...");
            while (true) {
                clientSocket = serverSocket.accept();
                System.out.println("A");
                handleClientRequest(clientSocket);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void handleClientRequest(Socket clientSocket) throws IOException, ParseException, ClassNotFoundException {
    	
    	String managerUsername;
    	String renterUsername;
    	String propertyName;
    	Integer stars;
    	String area;
    	DateRange dateRange;
    	Integer people;
    	Integer price;
    	
    	 try (ObjectInputStream objectInputStream = new ObjectInputStream(clientSocket.getInputStream());
    			 ObjectOutputStream objectOutputStream = new ObjectOutputStream(clientSocket.getOutputStream());
    	        ) {
    		 
    		 while (true) {
    			 System.out.println("Awaiting action command from user");
	    	     String action = (String) objectInputStream.readObject();
	//            String[] tokens = request.split(":");
	//            String action = tokens[0];
	//            String propertyId = tokens[1];
	            switch (action) {
	                case "ADD":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	readPropertyFromStream(objectInputStream);
	                    break;
	                case "SHOW":
	                    // Handle property addition request
	                    // Forward request to the appropriate worker
	//                	String jsonPath = tokens[1];
	                	managerUsername = (String) objectInputStream.readObject();
	                	System.out.println("Action at worker:"+action);
	                	System.out.println(managerUsername);
	                	objectOutputStream.writeObject(showManagerProperties(managerUsername));
	                    break;
	                case "AVAILABILITY":
	                	readAvailabilityFromStream(objectInputStream);
	                    break;
	                case "BOOKINGS":
	                	managerUsername = (String) objectInputStream.readObject();
	                	showManagerBookings(managerUsername);
	                    break;
	                case "BOOK":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	DateRange bookingRange = readDateRangeFromStream(objectInputStream);
	                    forwardPropertyBooking(renterUsername, propertyName, bookingRange);
	                    break;
	                case "RATE":
	                    // Handle property booking request
	                    // Forward request to the appropriate worker
	                	renterUsername = (String) objectInputStream.readObject();
	                	propertyName = (String) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                    forwardPropertyRating(renterUsername, propertyName, stars);
	                    break;
	                case "FILTER":
	                	area = (String) objectInputStream.readObject();
	                	dateRange=readDateRangeFromStream(objectInputStream);
	                	people = (Integer) objectInputStream.readObject();
	                	price = (Integer) objectInputStream.readObject();
	                	stars = (Integer) objectInputStream.readObject();
	                	forwardPropertyFiltering(area, dateRange, people, price, stars);
	                    break;
	                // Implement cases for other request types (UPDATE, etc.) as needed
	                default:
	                    // Unknown action, send error response
	                    break;
	               }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void readPropertyFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyInfo = (String) objectInputStream.readObject();

        // Read property info
        String[] keyValuePairs = propertyInfo.substring(1, propertyInfo.length() - 1).split(",");

        String roomName = "";
        int noOfPersons = 0;
        String area = "";
        int stars = 0;
        int noOfReviews = 0;
        String roomImage = "";

        // Iterate over key-value pairs and split them based on colons
        for (String pair : keyValuePairs) {
            System.out.println(pair);
            String[] keyValue = pair.split(":");
            String key = keyValue[0].trim().replaceAll("\"", "");
            String value = keyValue[1].trim().replaceAll("\"", ""); // Remove quotes

            // Assign values to appropriate variables based on keys
            switch (key) {
                case "roomName":
                    roomName = value;
                    break;
                case "noOfPersons":
                    noOfPersons = Integer.parseInt(value);
                    break;
                case "area":
                    area = value;
                    break;
                case "stars":
                    stars = Integer.parseInt(value);
                    break;
                case "noOfReviews":
                    noOfReviews = Integer.parseInt(value);
                    break;
                case "roomImage":
                    roomImage = value;
                    break;
            }
        }
        
     // Print the values to verify
        System.out.println("Room Name: " + roomName);
        System.out.println("Number of Persons: " + noOfPersons);
        System.out.println("Area: " + area);
        System.out.println("Stars: " + stars);
        System.out.println("Number of Reviews: " + noOfReviews);
        System.out.println("Room Image: " + roomImage);

        // Read image data
        byte[] imageData = (byte[]) objectInputStream.readObject();

        // Convert byte array to BufferedImage
        ByteArrayInputStream bis = new ByteArrayInputStream(imageData);
//        BufferedImage bufferedImage = ImageIO.read(bis);
        
        forwardPropertyAddition(roomName, managerUsername ,new Property(roomName, noOfPersons, area, stars, noOfReviews, roomImage,propertyCounter), imageData);
        propertyCounter=propertyCounter+1;
        // Return property object with image
    }
    
    private void readAvailabilityFromStream(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {
    	
    	String managerUsername = (String) objectInputStream.readObject();
    	
        String propertyName = (String) objectInputStream.readObject();
        
        String dateRangeAvailability = (String) objectInputStream.readObject();
        
        forwardPropertyAvailability(managerUsername, propertyName,dateRangeAvailability);

        // Return property object with image
    }

    private Map<String, Object> readFiltersFromStream(BufferedReader reader) throws IOException {
        Map<String, Object> filters = new HashMap<>();
        
        String line;
        while ((line = reader.readLine()) != null) {
            String[] tokens = line.split(":");
            String filterName = tokens[0];
            Object filterValue = tokens[1]; // Assuming filter value is string for simplicity, you may need to parse it accordingly
            filters.put(filterName, filterValue);
        }
        
        return filters;
    }

    private DateRange readDateRangeFromStream(ObjectInputStream objectInputStream) throws IOException, ParseException, ClassNotFoundException {
    	String startDateStr = (String) objectInputStream.readObject();
        String endDateStr = (String) objectInputStream.readObject();
        // Assuming date format is in "day/month/year"
        SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
        Date startDate = dateFormat.parse(startDateStr);
        Date endDate = dateFormat.parse(endDateStr);
        return new DateRange(startDate, endDate);
    }

    private void forwardPropertyAddition(String propertyName, String managerUsername,Property property, byte [] imageBytes) throws IOException {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new property...");

       String add = "ADD";
       objectOutputStream.writeObject(add);
       System.out.println("ADD SENT");
       objectOutputStream.writeObject(managerUsername);
       objectOutputStream.writeObject(property);
       objectOutputStream.writeObject(imageBytes);

          
    }
    
    private void forwardPropertyAvailability(String managerUsername,String propertyName,String dateRangeAvailability) throws IOException {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);
        

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new availability...");

       String availability = "AVAILABILITY";
       objectOutputStream.writeObject(availability);
       objectOutputStream.writeObject(managerUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(dateRangeAvailability);

    }

    private String showManagerProperties(String managerUsername) throws IOException, ClassNotFoundException {
    	
    	ArrayList<Property> mergedProperties = new ArrayList<>();
        
    	// Iterate over worker ports
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
    	    ObjectInputStream objectInputStream = workerInputStreams.get(i);

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("SHOW");
    	        objectOutputStream.writeObject(managerUsername);
    	        System.out.println("talked to worker");
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> workerProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedProperties.addAll(workerProperties);

    	        System.out.println("Received properties from worker on port: " + port);
    	        
    	        
    	        
    	 
    	}
    	
    	String returnedPropertiesAsString="";
    	
    	System.out.println(mergedProperties.get(0));
    	
    	for (int i=0;i<mergedProperties.size();i++) {
    		returnedPropertiesAsString=returnedPropertiesAsString+mergedProperties.get(i).toString();
    	}
    	
    	return returnedPropertiesAsString;
    	
    }
    	
    	private void showManagerBookings(String managerUsername) throws IOException, ClassNotFoundException {
        	
    		Map<String,List<DateRange>> mergedPropertyNamesBookings= new HashMap<>();
            
        	// Iterate over worker ports
        	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
        	    int port = 5000 + i; // Calculate port number
        	    
        	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
        	    ObjectInputStream objectInputStream = workerInputStreams.get(i);

        	        // Send "SHOW" request to worker
        	        objectOutputStream.writeObject("BOOKINGS");
        	        objectOutputStream.writeObject(managerUsername);
        	        
        	        // Receive ArrayList<Property> response from worker
        	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
        	        Map<String,List<DateRange>> propertyNamesBookings = (Map<String,List<DateRange>>) objectInputStream.readObject();
        	        
                    for (Map.Entry<String, List<DateRange>> entry : propertyNamesBookings.entrySet()) {
                        String propertyName = entry.getKey();
                        List<DateRange> bookings = entry.getValue();
                        
                        if (mergedPropertyNamesBookings.containsKey(propertyName)) {
                            // If the property already exists in the merged map, merge its bookings
                            mergedPropertyNamesBookings.get(propertyName).addAll(bookings);
                        } else {
                            // If the property doesn't exist in the merged map, add it with its bookings
                            mergedPropertyNamesBookings.put(propertyName, new ArrayList<>(bookings));
                        }
                    }
                    
                    for (Map.Entry<String, List<DateRange>> entry : mergedPropertyNamesBookings.entrySet()) {
                        String propertyName = entry.getKey();
                        List<DateRange> bookings = entry.getValue();
                        
                        // Print the property name
                        System.out.println("Property Name: " + propertyName);
                        
                        // Iterate over the list of date ranges for the current property
                        for (DateRange dateRange : bookings) {
                            // Print each date range
                            System.out.println("Date Range: " + dateRange);
                        }
                        
                        // Add a separator for better readability
                        System.out.println("------------------------------------");
                    }
                    
                    System.out.println("Received property bookings from worker on port: " + port);
        	        
        	}
    	
    	try (PrintWriter writer = new PrintWriter(clientSocket.getOutputStream(), true)) {
            // Send the string to the client
            writer.println("These are your properties:");
            System.out.println("Sent merged properties to the client");
        } catch (IOException e) {
            e.printStackTrace();
        }
    	
    }

    private void forwardPropertySearch(String propertyId, Map<String, Object> filters) {
        // Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyId.hashCode()) % workers.size();
        Worker worker = workers.get(workerIndex);

        // Search for properties on the chosen worker
        List<Property> searchResults = worker.searchProperties(filters);

        // Print search results to the console
        System.out.println("Search results for property ID " + propertyId + ":");
        for (Property property : searchResults) {
            System.out.println(property.toString()); // Assuming Property class overrides toString() method
        }
    }


    private void forwardPropertyBooking(String renterUsername, String propertyName, DateRange bookingRange) throws IOException {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new booking...");

       String book = "BOOK";
       objectOutputStream.writeObject(book);
       objectOutputStream.writeObject(renterUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(bookingRange);

           
    }
    
    private void forwardPropertyRating(String renterUsername, String propertyName, Integer stars) throws IOException {
    	// Choose a worker based on propertyId (e.g., using a hash function)
        int workerIndex = Math.abs(propertyName.hashCode()) % workers.size();
//        Worker worker = workers.get(workerIndex);

        // Add the property to the chosen worker
//        worker.addProperty(propertyId, property);
        
        int port;
        
        if (workerIndex==0)port=5001;
        else if (workerIndex==1)port=5002;
        else port=5002;
        
        ObjectOutputStream objectOutputStream=workerOutputStreams.get(workerIndex);

       System.out.println("Established connection with worker on port:"+ port);
       System.out.println("Adding new rating...");

       String rate = "RATE";
       objectOutputStream.writeObject(rate);
       objectOutputStream.writeObject(renterUsername);
       objectOutputStream.writeObject(propertyName);
       objectOutputStream.writeObject(stars);

    }
    
    private void forwardPropertyFiltering(String area, DateRange dateRange, Integer people, Integer price, Integer stars) {
    	
    	ArrayList<Property> mergedFilteredProperties= new ArrayList<Property>();
    	
    	for (int i = 0; i <= 2; i++) { // Assuming you have workers on ports 5001 to 5003
    	    int port = 5000 + i; // Calculate port number

    	    ObjectOutputStream objectOutputStream=workerOutputStreams.get(i);
    	    ObjectInputStream objectInputStream = workerInputStreams.get(i); 

    	        // Send "SHOW" request to worker
    	        objectOutputStream.writeObject("FILTER");
    	        objectOutputStream.writeObject(area);
    	        objectOutputStream.writeObject(dateRange);
    	        objectOutputStream.writeObject(people);
    	        objectOutputStream.writeObject(price);
    	        objectOutputStream.writeObject(stars);
    	        
    	        // Receive ArrayList<Property> response from worker
    	        @SuppressWarnings("unchecked") // Suppressing unchecked warning for type casting
    	        ArrayList<Property> filteredProperties = (ArrayList<Property>) objectInputStream.readObject();
    	        
    	        // Merge received properties with the merged list
    	        mergedFilteredProperties.addAll(filteredProperties);

    	        System.out.println("Received filtered properties from worker on port: " + port);
    	        
    	        
    	    } catch (IOException | ClassNotFoundException e) {
    	        e.printStackTrace();
    	    }
    	}
    }
    
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-04-12 22:12:06.793
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-04-12 22:12:06.794
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.ui.workbench 4 2 2024-04-12 22:25:06.517
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.ui.workbench".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.ui.internal.handlers.LegacyHandlerService.getCurrentState(LegacyHandlerService.java:572)
	at org.eclipse.egit.ui.internal.selection.SelectionUtils.getEvaluationContext(SelectionUtils.java:534)
	at org.eclipse.egit.ui.internal.selection.SelectionUtils.getStructuredSelection(SelectionUtils.java:237)
	at org.eclipse.egit.ui.internal.selection.RepositorySourceProvider.selectionChanged(RepositorySourceProvider.java:90)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.notifyListeners(SelectionService.java:266)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.notifyListeners(SelectionService.java:178)
	at org.eclipse.ui.internal.WorkbenchWindow$WWinPartService.partActivated(WorkbenchWindow.java:3171)
	at org.eclipse.ui.internal.WorkbenchPage$3.run(WorkbenchPage.java:4896)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.WorkbenchPage.firePartActivated(WorkbenchPage.java:4893)
	at org.eclipse.ui.internal.WorkbenchPage.access$3(WorkbenchPage.java:4878)
	at org.eclipse.ui.internal.WorkbenchPage$E4PartListener.partActivated(WorkbenchPage.java:219)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl$2.run(PartServiceImpl.java:249)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.firePartActivated(PartServiceImpl.java:246)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.activate(PartServiceImpl.java:770)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.setPart(PartServiceImpl.java:217)
	at jdk.internal.reflect.GeneratedMethodAccessor47.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.contexts.ContextObjectSupplier$ContextInjectionListener.update(ContextObjectSupplier.java:95)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:105)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.processScheduled(EclipseContext.java:364)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.dispose(EclipseContext.java:188)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.clearContext(PartRenderingEngine.java:990)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:963)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:870)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.disposeWidget(ContributedPartRenderer.java:274)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:942)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:870)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.disposeWidget(ElementReferenceRenderer.java:115)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:942)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:870)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:904)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:870)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:897)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:870)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:897)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:870)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:904)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:870)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:904)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:870)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:904)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:870)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:904)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:870)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:904)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:870)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:904)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:870)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:904)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:870)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.ui.internal.WorkbenchWindow.hardClose(WorkbenchWindow.java:2095)
	at org.eclipse.ui.internal.WorkbenchWindow.busyClose(WorkbenchWindow.java:1726)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$5(WorkbenchWindow.java:1751)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1751)
	at org.eclipse.ui.internal.Workbench$11.run(Workbench.java:1108)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.Workbench.busyClose(Workbench.java:1091)
	at org.eclipse.ui.internal.Workbench.lambda$4(Workbench.java:1392)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1392)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1368)
	at org.eclipse.ui.internal.WorkbenchWindow.busyClose(WorkbenchWindow.java:1722)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$5(WorkbenchWindow.java:1751)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1751)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1760)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$2(WorkbenchWindow.java:503)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.lambda$4(WBWRenderer.java:579)
	at org.eclipse.swt.events.ShellListener$2.shellClosed(ShellListener.java:102)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:102)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4195)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Decorations.closeWidget(Decorations.java:269)
	at org.eclipse.swt.widgets.Decorations.WM_CLOSE(Decorations.java:1552)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4761)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4913)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4860)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4913)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4860)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4913)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3610)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
!SESSION 2024-04-12 22:25:11.879 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.20
java.vendor=Microsoft
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.ecf.provider.filetransfer.httpclient45.win32 4 0 2024-04-12 22:25:13.322
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.ecf.provider.filetransfer.httpclient45.win32 [116]
  Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
       org.apache.httpcomponents.httpclient [40]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
  Unresolved requirement: Import-Package: org.apache.http.impl.client; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="javax.net.ssl,org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.client.methods,org.apache.http.concurrent,org.apache.http.config,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.conn.socket,org.apache.http.conn.ssl,org.apache.http.conn.util,org.apache.http.cookie,org.apache.http.impl,org.apache.http.impl.auth,org.apache.http.impl.execchain,org.apache.http.message,org.apache.http.params,org.apache.http.pool,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth.win; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.auth.win; bundle-symbolic-name="org.apache.httpcomponents.httpclient.win"; bundle-version="4.5.10.v20200113-2105"; version="4.5.10"; x-internal:="true"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.impl.auth,org.apache.http.protocol,org.apache.http.util"
       org.apache.httpcomponents.httpclient.win [41]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
         Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.conn.routing; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.conn.routing; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.client.config; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client.config; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.epp.mpc.core.win32 4 0 2024-04-12 22:25:13.322
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.epp.mpc.core.win32 [135]
  Unresolved requirement: Import-Package: org.apache.http.client.config; version="4.3.6"
    -> Export-Package: org.apache.http.client.config; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http"
       org.apache.httpcomponents.httpclient [40]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="4.3.6"
    -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.client; version="4.3.6"
    -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth.win; version="4.3.6"
    -> Export-Package: org.apache.http.impl.auth.win; bundle-symbolic-name="org.apache.httpcomponents.httpclient.win"; bundle-version="4.5.10.v20200113-2105"; version="4.5.10"; x-internal:="true"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.impl.auth,org.apache.http.protocol,org.apache.http.util"
       org.apache.httpcomponents.httpclient.win [41]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
         Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.conn.routing; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.conn.routing; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.auth; version="4.3.6"
    -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.impl.client; version="4.3.6"
    -> Export-Package: org.apache.http.impl.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="javax.net.ssl,org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.client.methods,org.apache.http.concurrent,org.apache.http.config,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.conn.socket,org.apache.http.conn.ssl,org.apache.http.conn.util,org.apache.http.cookie,org.apache.http.impl,org.apache.http.impl.auth,org.apache.http.impl.execchain,org.apache.http.message,org.apache.http.params,org.apache.http.pool,org.apache.http.protocol"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.commons.notifications.feed 4 0 2024-04-12 22:25:13.448
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.commons.notifications.feed [603]
  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.tasks.ui 4 0 2024-04-12 22:25:13.495
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.tasks.ui [620]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.0.0"
    -> Bundle-SymbolicName: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.18.0.v20190930-2131"; singleton:="true"
       org.eclipse.mylyn.commons.notifications.feed [603]
         No resolution report for the bundle.  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.trac.ui 4 0 2024-04-12 22:25:13.511
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.trac.ui [622]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.tasks.ui; bundle-version="[3.8.0,4.0.0)"
    -> Bundle-SymbolicName: org.eclipse.mylyn.tasks.ui; bundle-version="3.25.2.v20200814-0512"; singleton:="true"
       org.eclipse.mylyn.tasks.ui [620]
         Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.0.0"
           -> Bundle-SymbolicName: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.18.0.v20190930-2131"; singleton:="true"
              org.eclipse.mylyn.commons.notifications.feed [603]
                No resolution report for the bundle.  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.jface 2 0 2024-04-12 22:25:34.007
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-04-12 22:25:34.007
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6d035815,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6fd2acf5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-04-12 22:25:39.722
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Giannis'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2024-04-13 01:08:13.816 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.20
java.vendor=Microsoft
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.ecf.provider.filetransfer.httpclient45.win32 4 0 2024-04-13 01:08:16.533
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.ecf.provider.filetransfer.httpclient45.win32 [116]
  Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
       org.apache.httpcomponents.httpclient [40]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
  Unresolved requirement: Import-Package: org.apache.http.client.config; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client.config; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http"
  Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth.win; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.auth.win; bundle-symbolic-name="org.apache.httpcomponents.httpclient.win"; bundle-version="4.5.10.v20200113-2105"; version="4.5.10"; x-internal:="true"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.impl.auth,org.apache.http.protocol,org.apache.http.util"
       org.apache.httpcomponents.httpclient.win [41]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
         Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.conn.routing; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.conn.routing; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.impl.client; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="javax.net.ssl,org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.client.methods,org.apache.http.concurrent,org.apache.http.config,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.conn.socket,org.apache.http.conn.ssl,org.apache.http.conn.util,org.apache.http.cookie,org.apache.http.impl,org.apache.http.impl.auth,org.apache.http.impl.execchain,org.apache.http.message,org.apache.http.params,org.apache.http.pool,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.epp.mpc.core.win32 4 0 2024-04-13 01:08:16.533
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.epp.mpc.core.win32 [135]
  Unresolved requirement: Import-Package: org.apache.http.impl.client; version="4.3.6"
    -> Export-Package: org.apache.http.impl.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="javax.net.ssl,org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.client.methods,org.apache.http.concurrent,org.apache.http.config,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.conn.socket,org.apache.http.conn.ssl,org.apache.http.conn.util,org.apache.http.cookie,org.apache.http.impl,org.apache.http.impl.auth,org.apache.http.impl.execchain,org.apache.http.message,org.apache.http.params,org.apache.http.pool,org.apache.http.protocol"
       org.apache.httpcomponents.httpclient [40]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
  Unresolved requirement: Import-Package: org.apache.http.client; version="4.3.6"
    -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="4.3.6"
    -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.auth; version="4.3.6"
    -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.client.config; version="4.3.6"
    -> Export-Package: org.apache.http.client.config; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth.win; version="4.3.6"
    -> Export-Package: org.apache.http.impl.auth.win; bundle-symbolic-name="org.apache.httpcomponents.httpclient.win"; bundle-version="4.5.10.v20200113-2105"; version="4.5.10"; x-internal:="true"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.impl.auth,org.apache.http.protocol,org.apache.http.util"
       org.apache.httpcomponents.httpclient.win [41]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
         Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.conn.routing; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.conn.routing; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.commons.notifications.feed 4 0 2024-04-13 01:08:17.789
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.commons.notifications.feed [603]
  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.tasks.ui 4 0 2024-04-13 01:08:17.831
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.tasks.ui [620]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.0.0"
    -> Bundle-SymbolicName: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.18.0.v20190930-2131"; singleton:="true"
       org.eclipse.mylyn.commons.notifications.feed [603]
         No resolution report for the bundle.  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.trac.ui 4 0 2024-04-13 01:08:17.857
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.trac.ui [622]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.tasks.ui; bundle-version="[3.8.0,4.0.0)"
    -> Bundle-SymbolicName: org.eclipse.mylyn.tasks.ui; bundle-version="3.25.2.v20200814-0512"; singleton:="true"
       org.eclipse.mylyn.tasks.ui [620]
         Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.0.0"
           -> Bundle-SymbolicName: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.18.0.v20190930-2131"; singleton:="true"
              org.eclipse.mylyn.commons.notifications.feed [603]
                No resolution report for the bundle.  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.jface 2 0 2024-04-13 01:08:29.128
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-04-13 01:08:29.128
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3c2188f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@646bf8a6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-04-13 01:08:35.133
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Giannis'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY com.yattasolutions.platform.marketplace.client 4 0 2024-04-13 01:17:11.081
!MESSAGE Problem retrieving marketplace UUID, an own UUID will be used.
!STACK 0
java.lang.RuntimeException: The plugin could not be started. Please restart Eclipse.
	at com.yattasolutions.platform.marketplace.client.MarketplaceClientPlugin.getDefault(MarketplaceClientPlugin.java:245)
	at com.yattasolutions.platform.marketplace.client.MarketplaceClient.get(MarketplaceClient.java:33)
	at de.yatta.platform.marketplace.licensing.client.LicensingClient.getAccountUuid(LicensingClient.java:603)
	at de.yatta.platform.marketplace.licensing.client.LicensingClient.access$3(LicensingClient.java:599)
	at de.yatta.platform.marketplace.licensing.client.LicensingClient$1.run(LicensingClient.java:509)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2024-04-13 13:09:29.171 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.20
java.vendor=Microsoft
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.ecf.provider.filetransfer.httpclient45.win32 4 0 2024-04-13 13:09:30.631
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.ecf.provider.filetransfer.httpclient45.win32 [116]
  Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
       org.apache.httpcomponents.httpclient [40]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
  Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth.win; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.auth.win; bundle-symbolic-name="org.apache.httpcomponents.httpclient.win"; bundle-version="4.5.10.v20200113-2105"; version="4.5.10"; x-internal:="true"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.impl.auth,org.apache.http.protocol,org.apache.http.util"
       org.apache.httpcomponents.httpclient.win [41]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
         Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.conn.routing; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.conn.routing; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.impl.client; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="javax.net.ssl,org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.client.methods,org.apache.http.concurrent,org.apache.http.config,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.conn.socket,org.apache.http.conn.ssl,org.apache.http.conn.util,org.apache.http.cookie,org.apache.http.impl,org.apache.http.impl.auth,org.apache.http.impl.execchain,org.apache.http.message,org.apache.http.params,org.apache.http.pool,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.client.config; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client.config; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.epp.mpc.core.win32 4 0 2024-04-13 13:09:30.631
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.epp.mpc.core.win32 [135]
  Unresolved requirement: Import-Package: org.apache.http.impl.auth.win; version="4.3.6"
    -> Export-Package: org.apache.http.impl.auth.win; bundle-symbolic-name="org.apache.httpcomponents.httpclient.win"; bundle-version="4.5.10.v20200113-2105"; version="4.5.10"; x-internal:="true"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.impl.auth,org.apache.http.protocol,org.apache.http.util"
       org.apache.httpcomponents.httpclient.win [41]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
         Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
              org.apache.httpcomponents.httpclient [40]
                Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
         Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.conn.routing; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.conn.routing; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="4.3.6"
    -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.auth; version="4.3.6"
    -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.client; version="4.3.6"
    -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.impl.client; version="4.3.6"
    -> Export-Package: org.apache.http.impl.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="javax.net.ssl,org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.client.methods,org.apache.http.concurrent,org.apache.http.config,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.conn.socket,org.apache.http.conn.ssl,org.apache.http.conn.util,org.apache.http.cookie,org.apache.http.impl,org.apache.http.impl.auth,org.apache.http.impl.execchain,org.apache.http.message,org.apache.http.params,org.apache.http.pool,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.client.config; version="4.3.6"
    -> Export-Package: org.apache.http.client.config; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.commons.notifications.feed 4 0 2024-04-13 13:09:30.758
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.commons.notifications.feed [603]
  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.tasks.ui 4 0 2024-04-13 13:09:30.805
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.tasks.ui [620]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.0.0"
    -> Bundle-SymbolicName: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.18.0.v20190930-2131"; singleton:="true"
       org.eclipse.mylyn.commons.notifications.feed [603]
         No resolution report for the bundle.  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.trac.ui 4 0 2024-04-13 13:09:30.821
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.trac.ui [622]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.tasks.ui; bundle-version="[3.8.0,4.0.0)"
    -> Bundle-SymbolicName: org.eclipse.mylyn.tasks.ui; bundle-version="3.25.2.v20200814-0512"; singleton:="true"
       org.eclipse.mylyn.tasks.ui [620]
         Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.0.0"
           -> Bundle-SymbolicName: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.18.0.v20190930-2131"; singleton:="true"
              org.eclipse.mylyn.commons.notifications.feed [603]
                No resolution report for the bundle.  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.jface 2 0 2024-04-13 13:09:36.210
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-04-13 13:09:36.210
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@25b8f9d2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2979c6ef,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-04-13 13:09:46.257
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Giannis'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY de.yatta.platform.marketplace.licensing.client 2 0 2024-04-13 15:40:01.792
!MESSAGE Could not receive a valid response for solution feature de.yatta.feature.emf from the license server.
!STACK 0
java.net.SocketTimeoutException: Read timed out
	at java.base/java.net.SocketInputStream.socketRead0(Native Method)
	at java.base/java.net.SocketInputStream.socketRead(SocketInputStream.java:115)
	at java.base/java.net.SocketInputStream.read(SocketInputStream.java:168)
	at java.base/java.net.SocketInputStream.read(SocketInputStream.java:140)
	at java.base/sun.security.ssl.SSLSocketInputRecord.read(SSLSocketInputRecord.java:484)
	at java.base/sun.security.ssl.SSLSocketInputRecord.readHeader(SSLSocketInputRecord.java:478)
	at java.base/sun.security.ssl.SSLSocketInputRecord.bytesInCompletePacket(SSLSocketInputRecord.java:70)
	at java.base/sun.security.ssl.SSLSocketImpl.readApplicationRecord(SSLSocketImpl.java:1459)
	at java.base/sun.security.ssl.SSLSocketImpl$AppInputStream.read(SSLSocketImpl.java:1070)
	at org.apache.http.impl.conn.LoggingInputStream.read(LoggingInputStream.java:84)
	at org.apache.http.impl.io.SessionInputBufferImpl.streamRead(SessionInputBufferImpl.java:137)
	at org.apache.http.impl.io.SessionInputBufferImpl.fillBuffer(SessionInputBufferImpl.java:153)
	at org.apache.http.impl.io.SessionInputBufferImpl.readLine(SessionInputBufferImpl.java:280)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:138)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:56)
	at org.apache.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:259)
	at org.apache.http.impl.DefaultBHttpClientConnection.receiveResponseHeader(DefaultBHttpClientConnection.java:163)
	at org.apache.http.impl.conn.CPoolProxy.receiveResponseHeader(CPoolProxy.java:157)
	at org.apache.http.protocol.HttpRequestExecutor.doReceiveResponse(HttpRequestExecutor.java:273)
	at de.yatta.eclipse.launcher.communication.utils.HttpRequestContext$RequestTemplateExecutor.doReceiveResponse(HttpRequestContext.java:707)
	at org.apache.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:125)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:272)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)
	at org.apache.http.client.fluent.Request.internalExecute(Request.java:173)
	at org.apache.http.client.fluent.Executor.execute(Executor.java:262)
	at de.yatta.eclipse.launcher.communication.utils.RequestTemplate.execute(RequestTemplate.java:200)
	at de.yatta.platform.marketplace.licensing.client.LicensingClient$1.run(LicensingClient.java:500)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY de.yatta.platform.marketplace.licensing.client 2 0 2024-04-13 15:48:47.620
!MESSAGE Could not receive a valid response for solution feature de.yatta.feature.roundtrip from the license server.
!STACK 0
java.net.SocketException: Connection reset
	at java.base/java.net.SocketInputStream.read(SocketInputStream.java:186)
	at java.base/java.net.SocketInputStream.read(SocketInputStream.java:140)
	at java.base/sun.security.ssl.SSLSocketInputRecord.read(SSLSocketInputRecord.java:484)
	at java.base/sun.security.ssl.SSLSocketInputRecord.readHeader(SSLSocketInputRecord.java:478)
	at java.base/sun.security.ssl.SSLSocketInputRecord.bytesInCompletePacket(SSLSocketInputRecord.java:70)
	at java.base/sun.security.ssl.SSLSocketImpl.readApplicationRecord(SSLSocketImpl.java:1459)
	at java.base/sun.security.ssl.SSLSocketImpl$AppInputStream.read(SSLSocketImpl.java:1070)
	at org.apache.http.impl.conn.LoggingInputStream.read(LoggingInputStream.java:84)
	at org.apache.http.impl.io.SessionInputBufferImpl.streamRead(SessionInputBufferImpl.java:137)
	at org.apache.http.impl.io.SessionInputBufferImpl.fillBuffer(SessionInputBufferImpl.java:153)
	at org.apache.http.impl.io.SessionInputBufferImpl.readLine(SessionInputBufferImpl.java:280)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:138)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:56)
	at org.apache.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:259)
	at org.apache.http.impl.DefaultBHttpClientConnection.receiveResponseHeader(DefaultBHttpClientConnection.java:163)
	at org.apache.http.impl.conn.CPoolProxy.receiveResponseHeader(CPoolProxy.java:157)
	at org.apache.http.protocol.HttpRequestExecutor.doReceiveResponse(HttpRequestExecutor.java:273)
	at de.yatta.eclipse.launcher.communication.utils.HttpRequestContext$RequestTemplateExecutor.doReceiveResponse(HttpRequestContext.java:707)
	at org.apache.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:125)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:272)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)
	at org.apache.http.client.fluent.Request.internalExecute(Request.java:173)
	at org.apache.http.client.fluent.Executor.execute(Executor.java:262)
	at de.yatta.eclipse.launcher.communication.utils.RequestTemplate.execute(RequestTemplate.java:200)
	at de.yatta.platform.marketplace.licensing.client.LicensingClient$1.run(LicensingClient.java:500)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY de.yatta.platform.marketplace.licensing.client 2 0 2024-04-13 17:37:28.613
!MESSAGE Could not receive a valid response for solution feature de.yatta.feature.roundtrip from the license server.
!STACK 0
java.net.SocketTimeoutException: Read timed out
	at java.base/java.net.SocketInputStream.socketRead0(Native Method)
	at java.base/java.net.SocketInputStream.socketRead(SocketInputStream.java:115)
	at java.base/java.net.SocketInputStream.read(SocketInputStream.java:168)
	at java.base/java.net.SocketInputStream.read(SocketInputStream.java:140)
	at java.base/sun.security.ssl.SSLSocketInputRecord.read(SSLSocketInputRecord.java:484)
	at java.base/sun.security.ssl.SSLSocketInputRecord.readHeader(SSLSocketInputRecord.java:478)
	at java.base/sun.security.ssl.SSLSocketInputRecord.bytesInCompletePacket(SSLSocketInputRecord.java:70)
	at java.base/sun.security.ssl.SSLSocketImpl.readApplicationRecord(SSLSocketImpl.java:1459)
	at java.base/sun.security.ssl.SSLSocketImpl$AppInputStream.read(SSLSocketImpl.java:1070)
	at org.apache.http.impl.io.SessionInputBufferImpl.streamRead(SessionInputBufferImpl.java:137)
	at org.apache.http.impl.io.SessionInputBufferImpl.fillBuffer(SessionInputBufferImpl.java:153)
	at org.apache.http.impl.io.SessionInputBufferImpl.readLine(SessionInputBufferImpl.java:280)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:138)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:56)
	at org.apache.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:259)
	at org.apache.http.impl.DefaultBHttpClientConnection.receiveResponseHeader(DefaultBHttpClientConnection.java:163)
	at org.apache.http.impl.conn.CPoolProxy.receiveResponseHeader(CPoolProxy.java:157)
	at org.apache.http.protocol.HttpRequestExecutor.doReceiveResponse(HttpRequestExecutor.java:273)
	at de.yatta.eclipse.launcher.communication.utils.HttpRequestContext$RequestTemplateExecutor.doReceiveResponse(HttpRequestContext.java:707)
	at org.apache.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:125)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:272)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)
	at org.apache.http.client.fluent.Request.internalExecute(Request.java:173)
	at org.apache.http.client.fluent.Executor.execute(Executor.java:262)
	at de.yatta.eclipse.launcher.communication.utils.RequestTemplate.execute(RequestTemplate.java:200)
	at de.yatta.platform.marketplace.licensing.client.LicensingClient$1.run(LicensingClient.java:500)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY de.yatta.platform.marketplace.licensing.client 2 0 2024-04-13 19:06:00.581
!MESSAGE Could not receive a valid response for solution feature de.yatta.feature.emf from the license server.
!STACK 0
java.net.SocketException: Connection reset
	at java.base/java.net.SocketInputStream.read(SocketInputStream.java:186)
	at java.base/java.net.SocketInputStream.read(SocketInputStream.java:140)
	at java.base/sun.security.ssl.SSLSocketInputRecord.read(SSLSocketInputRecord.java:484)
	at java.base/sun.security.ssl.SSLSocketInputRecord.readHeader(SSLSocketInputRecord.java:478)
	at java.base/sun.security.ssl.SSLSocketInputRecord.bytesInCompletePacket(SSLSocketInputRecord.java:70)
	at java.base/sun.security.ssl.SSLSocketImpl.readApplicationRecord(SSLSocketImpl.java:1459)
	at java.base/sun.security.ssl.SSLSocketImpl$AppInputStream.read(SSLSocketImpl.java:1070)
	at org.apache.http.impl.io.SessionInputBufferImpl.streamRead(SessionInputBufferImpl.java:137)
	at org.apache.http.impl.io.SessionInputBufferImpl.fillBuffer(SessionInputBufferImpl.java:153)
	at org.apache.http.impl.io.SessionInputBufferImpl.readLine(SessionInputBufferImpl.java:280)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:138)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:56)
	at org.apache.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:259)
	at org.apache.http.impl.DefaultBHttpClientConnection.receiveResponseHeader(DefaultBHttpClientConnection.java:163)
	at org.apache.http.impl.conn.CPoolProxy.receiveResponseHeader(CPoolProxy.java:157)
	at org.apache.http.protocol.HttpRequestExecutor.doReceiveResponse(HttpRequestExecutor.java:273)
	at de.yatta.eclipse.launcher.communication.utils.HttpRequestContext$RequestTemplateExecutor.doReceiveResponse(HttpRequestContext.java:707)
	at org.apache.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:125)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:272)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)
	at org.apache.http.client.fluent.Request.internalExecute(Request.java:173)
	at org.apache.http.client.fluent.Executor.execute(Executor.java:262)
	at de.yatta.eclipse.launcher.communication.utils.RequestTemplate.execute(RequestTemplate.java:200)
	at de.yatta.platform.marketplace.licensing.client.LicensingClient$1.run(LicensingClient.java:500)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY de.yatta.platform.marketplace.licensing.client 2 0 2024-04-13 19:07:00.483
!MESSAGE Could not receive a valid response for solution feature de.yatta.feature.roundtrip from the license server.
!STACK 0
java.net.SocketTimeoutException: Read timed out
	at java.base/java.net.SocketInputStream.socketRead0(Native Method)
	at java.base/java.net.SocketInputStream.socketRead(SocketInputStream.java:115)
	at java.base/java.net.SocketInputStream.read(SocketInputStream.java:168)
	at java.base/java.net.SocketInputStream.read(SocketInputStream.java:140)
	at java.base/sun.security.ssl.SSLSocketInputRecord.read(SSLSocketInputRecord.java:484)
	at java.base/sun.security.ssl.SSLSocketInputRecord.readHeader(SSLSocketInputRecord.java:478)
	at java.base/sun.security.ssl.SSLSocketInputRecord.bytesInCompletePacket(SSLSocketInputRecord.java:70)
	at java.base/sun.security.ssl.SSLSocketImpl.readApplicationRecord(SSLSocketImpl.java:1459)
	at java.base/sun.security.ssl.SSLSocketImpl$AppInputStream.read(SSLSocketImpl.java:1070)
	at org.apache.http.impl.io.SessionInputBufferImpl.streamRead(SessionInputBufferImpl.java:137)
	at org.apache.http.impl.io.SessionInputBufferImpl.fillBuffer(SessionInputBufferImpl.java:153)
	at org.apache.http.impl.io.SessionInputBufferImpl.readLine(SessionInputBufferImpl.java:280)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:138)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:56)
	at org.apache.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:259)
	at org.apache.http.impl.DefaultBHttpClientConnection.receiveResponseHeader(DefaultBHttpClientConnection.java:163)
	at org.apache.http.impl.conn.CPoolProxy.receiveResponseHeader(CPoolProxy.java:157)
	at org.apache.http.protocol.HttpRequestExecutor.doReceiveResponse(HttpRequestExecutor.java:273)
	at de.yatta.eclipse.launcher.communication.utils.HttpRequestContext$RequestTemplateExecutor.doReceiveResponse(HttpRequestContext.java:707)
	at org.apache.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:125)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:272)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)
	at org.apache.http.client.fluent.Request.internalExecute(Request.java:173)
	at org.apache.http.client.fluent.Executor.execute(Executor.java:262)
	at de.yatta.eclipse.launcher.communication.utils.RequestTemplate.execute(RequestTemplate.java:200)
	at de.yatta.platform.marketplace.licensing.client.LicensingClient$1.run(LicensingClient.java:500)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY de.yatta.platform.marketplace.licensing.client 2 0 2024-04-13 19:09:50.672
!MESSAGE Could not receive a valid response for solution feature de.yatta.feature.emf from the license server.
!STACK 0
java.net.SocketException: Connection reset
	at java.base/java.net.SocketInputStream.read(SocketInputStream.java:186)
	at java.base/java.net.SocketInputStream.read(SocketInputStream.java:140)
	at java.base/sun.security.ssl.SSLSocketInputRecord.read(SSLSocketInputRecord.java:484)
	at java.base/sun.security.ssl.SSLSocketInputRecord.readHeader(SSLSocketInputRecord.java:478)
	at java.base/sun.security.ssl.SSLSocketInputRecord.bytesInCompletePacket(SSLSocketInputRecord.java:70)
	at java.base/sun.security.ssl.SSLSocketImpl.readApplicationRecord(SSLSocketImpl.java:1459)
	at java.base/sun.security.ssl.SSLSocketImpl$AppInputStream.read(SSLSocketImpl.java:1070)
	at org.apache.http.impl.io.SessionInputBufferImpl.streamRead(SessionInputBufferImpl.java:137)
	at org.apache.http.impl.io.SessionInputBufferImpl.fillBuffer(SessionInputBufferImpl.java:153)
	at org.apache.http.impl.io.SessionInputBufferImpl.readLine(SessionInputBufferImpl.java:280)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:138)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:56)
	at org.apache.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:259)
	at org.apache.http.impl.DefaultBHttpClientConnection.receiveResponseHeader(DefaultBHttpClientConnection.java:163)
	at org.apache.http.impl.conn.CPoolProxy.receiveResponseHeader(CPoolProxy.java:157)
	at org.apache.http.protocol.HttpRequestExecutor.doReceiveResponse(HttpRequestExecutor.java:273)
	at de.yatta.eclipse.launcher.communication.utils.HttpRequestContext$RequestTemplateExecutor.doReceiveResponse(HttpRequestContext.java:707)
	at org.apache.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:125)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:272)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)
	at org.apache.http.client.fluent.Request.internalExecute(Request.java:173)
	at org.apache.http.client.fluent.Executor.execute(Executor.java:262)
	at de.yatta.eclipse.launcher.communication.utils.RequestTemplate.execute(RequestTemplate.java:200)
	at de.yatta.platform.marketplace.licensing.client.LicensingClient$1.run(LicensingClient.java:500)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY de.yatta.platform.marketplace.licensing.client 2 0 2024-04-13 19:16:29.512
!MESSAGE Could not receive a valid response for solution feature de.yatta.feature.emf from the license server.
!STACK 0
java.net.SocketTimeoutException: Read timed out
	at java.base/java.net.SocketInputStream.socketRead0(Native Method)
	at java.base/java.net.SocketInputStream.socketRead(SocketInputStream.java:115)
	at java.base/java.net.SocketInputStream.read(SocketInputStream.java:168)
	at java.base/java.net.SocketInputStream.read(SocketInputStream.java:140)
	at java.base/sun.security.ssl.SSLSocketInputRecord.read(SSLSocketInputRecord.java:484)
	at java.base/sun.security.ssl.SSLSocketInputRecord.readHeader(SSLSocketInputRecord.java:478)
	at java.base/sun.security.ssl.SSLSocketInputRecord.bytesInCompletePacket(SSLSocketInputRecord.java:70)
	at java.base/sun.security.ssl.SSLSocketImpl.readApplicationRecord(SSLSocketImpl.java:1459)
	at java.base/sun.security.ssl.SSLSocketImpl$AppInputStream.read(SSLSocketImpl.java:1070)
	at org.apache.http.impl.io.SessionInputBufferImpl.streamRead(SessionInputBufferImpl.java:137)
	at org.apache.http.impl.io.SessionInputBufferImpl.fillBuffer(SessionInputBufferImpl.java:153)
	at org.apache.http.impl.io.SessionInputBufferImpl.readLine(SessionInputBufferImpl.java:280)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:138)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:56)
	at org.apache.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:259)
	at org.apache.http.impl.DefaultBHttpClientConnection.receiveResponseHeader(DefaultBHttpClientConnection.java:163)
	at org.apache.http.impl.conn.CPoolProxy.receiveResponseHeader(CPoolProxy.java:157)
	at org.apache.http.protocol.HttpRequestExecutor.doReceiveResponse(HttpRequestExecutor.java:273)
	at de.yatta.eclipse.launcher.communication.utils.HttpRequestContext$RequestTemplateExecutor.doReceiveResponse(HttpRequestContext.java:707)
	at org.apache.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:125)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:272)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)
	at org.apache.http.client.fluent.Request.internalExecute(Request.java:173)
	at org.apache.http.client.fluent.Executor.execute(Executor.java:262)
	at de.yatta.eclipse.launcher.communication.utils.RequestTemplate.execute(RequestTemplate.java:200)
	at de.yatta.platform.marketplace.licensing.client.LicensingClient$1.run(LicensingClient.java:500)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY de.yatta.platform.marketplace.licensing.client 2 0 2024-04-13 21:25:12.267
!MESSAGE Could not receive a valid response for solution feature de.yatta.feature.roundtrip from the license server.
!STACK 0
java.net.SocketException: Connection reset
	at java.base/java.net.SocketInputStream.read(SocketInputStream.java:186)
	at java.base/java.net.SocketInputStream.read(SocketInputStream.java:140)
	at java.base/sun.security.ssl.SSLSocketInputRecord.read(SSLSocketInputRecord.java:484)
	at java.base/sun.security.ssl.SSLSocketInputRecord.readHeader(SSLSocketInputRecord.java:478)
	at java.base/sun.security.ssl.SSLSocketInputRecord.bytesInCompletePacket(SSLSocketInputRecord.java:70)
	at java.base/sun.security.ssl.SSLSocketImpl.readApplicationRecord(SSLSocketImpl.java:1459)
	at java.base/sun.security.ssl.SSLSocketImpl$AppInputStream.read(SSLSocketImpl.java:1070)
	at org.apache.http.impl.io.SessionInputBufferImpl.streamRead(SessionInputBufferImpl.java:137)
	at org.apache.http.impl.io.SessionInputBufferImpl.fillBuffer(SessionInputBufferImpl.java:153)
	at org.apache.http.impl.io.SessionInputBufferImpl.readLine(SessionInputBufferImpl.java:280)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:138)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:56)
	at org.apache.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:259)
	at org.apache.http.impl.DefaultBHttpClientConnection.receiveResponseHeader(DefaultBHttpClientConnection.java:163)
	at org.apache.http.impl.conn.CPoolProxy.receiveResponseHeader(CPoolProxy.java:157)
	at org.apache.http.protocol.HttpRequestExecutor.doReceiveResponse(HttpRequestExecutor.java:273)
	at de.yatta.eclipse.launcher.communication.utils.HttpRequestContext$RequestTemplateExecutor.doReceiveResponse(HttpRequestContext.java:707)
	at org.apache.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:125)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:272)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)
	at org.apache.http.client.fluent.Request.internalExecute(Request.java:173)
	at org.apache.http.client.fluent.Executor.execute(Executor.java:262)
	at de.yatta.eclipse.launcher.communication.utils.RequestTemplate.execute(RequestTemplate.java:200)
	at de.yatta.platform.marketplace.licensing.client.LicensingClient$1.run(LicensingClient.java:500)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2024-04-16 01:08:27.991 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.20
java.vendor=Microsoft
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.ecf.provider.filetransfer.httpclient45.win32 4 0 2024-04-16 01:08:30.970
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.ecf.provider.filetransfer.httpclient45.win32 [116]
  Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
       org.apache.httpcomponents.httpclient [40]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth.win; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.auth.win; bundle-symbolic-name="org.apache.httpcomponents.httpclient.win"; bundle-version="4.5.10.v20200113-2105"; version="4.5.10"; x-internal:="true"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.impl.auth,org.apache.http.protocol,org.apache.http.util"
       org.apache.httpcomponents.httpclient.win [41]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
         Unresolved requirement: Import-Package: org.apache.http.conn.routing; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.conn.routing; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.client.config; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client.config; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http"
  Unresolved requirement: Import-Package: org.apache.http.impl.client; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="javax.net.ssl,org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.client.methods,org.apache.http.concurrent,org.apache.http.config,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.conn.socket,org.apache.http.conn.ssl,org.apache.http.conn.util,org.apache.http.cookie,org.apache.http.impl,org.apache.http.impl.auth,org.apache.http.impl.execchain,org.apache.http.message,org.apache.http.params,org.apache.http.pool,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.epp.mpc.core.win32 4 0 2024-04-16 01:08:30.980
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.epp.mpc.core.win32 [135]
  Unresolved requirement: Import-Package: org.apache.http.client.config; version="4.3.6"
    -> Export-Package: org.apache.http.client.config; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http"
       org.apache.httpcomponents.httpclient [40]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="4.3.6"
    -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.impl.client; version="4.3.6"
    -> Export-Package: org.apache.http.impl.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="javax.net.ssl,org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.client.methods,org.apache.http.concurrent,org.apache.http.config,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.conn.socket,org.apache.http.conn.ssl,org.apache.http.conn.util,org.apache.http.cookie,org.apache.http.impl,org.apache.http.impl.auth,org.apache.http.impl.execchain,org.apache.http.message,org.apache.http.params,org.apache.http.pool,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.auth; version="4.3.6"
    -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth.win; version="4.3.6"
    -> Export-Package: org.apache.http.impl.auth.win; bundle-symbolic-name="org.apache.httpcomponents.httpclient.win"; bundle-version="4.5.10.v20200113-2105"; version="4.5.10"; x-internal:="true"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.impl.auth,org.apache.http.protocol,org.apache.http.util"
       org.apache.httpcomponents.httpclient.win [41]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
         Unresolved requirement: Import-Package: org.apache.http.conn.routing; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.conn.routing; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.client; version="4.3.6"
    -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.commons.notifications.feed 4 0 2024-04-16 01:08:32.351
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.commons.notifications.feed [603]
  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.tasks.ui 4 0 2024-04-16 01:08:32.383
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.tasks.ui [620]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.0.0"
    -> Bundle-SymbolicName: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.18.0.v20190930-2131"; singleton:="true"
       org.eclipse.mylyn.commons.notifications.feed [603]
         No resolution report for the bundle.  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.trac.ui 4 0 2024-04-16 01:08:32.414
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.trac.ui [622]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.tasks.ui; bundle-version="[3.8.0,4.0.0)"
    -> Bundle-SymbolicName: org.eclipse.mylyn.tasks.ui; bundle-version="3.25.2.v20200814-0512"; singleton:="true"
       org.eclipse.mylyn.tasks.ui [620]
         Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.0.0"
           -> Bundle-SymbolicName: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.18.0.v20190930-2131"; singleton:="true"
              org.eclipse.mylyn.commons.notifications.feed [603]
                No resolution report for the bundle.  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.core.resources 2 10035 2024-04-16 01:08:37.339
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2024-04-16 01:08:44.038
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-04-16 01:08:44.038
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6d035815,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6fd2acf5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-04-16 01:08:52.590
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Giannis'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY de.yatta.platform.marketplace.licensing.client 2 0 2024-04-16 01:08:54.376
!MESSAGE Could not receive a valid response for solution feature de.yatta.feature.corediagrams from the license server.
!STACK 0
java.net.UnknownHostException: platform.yatta.de
	at java.base/java.net.InetAddress$CachedAddresses.get(InetAddress.java:797)
	at java.base/java.net.InetAddress$NameServiceAddresses.get(InetAddress.java:883)
	at java.base/java.net.InetAddress.getAllByName0(InetAddress.java:1533)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1386)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1307)
	at org.apache.http.impl.conn.SystemDefaultDnsResolver.resolve(SystemDefaultDnsResolver.java:45)
	at org.apache.http.impl.conn.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:112)
	at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:374)
	at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:393)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:236)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)
	at org.apache.http.client.fluent.Request.internalExecute(Request.java:173)
	at org.apache.http.client.fluent.Executor.execute(Executor.java:262)
	at de.yatta.eclipse.launcher.communication.utils.RequestTemplate.execute(RequestTemplate.java:200)
	at de.yatta.platform.marketplace.licensing.client.LicensingClient$1.run(LicensingClient.java:500)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY de.yatta.platform.marketplace.licensing.client 2 0 2024-04-16 01:08:54.376
!MESSAGE Could not receive a valid response for solution feature de.yatta.feature.roundtrip from the license server.
!STACK 0
java.net.UnknownHostException: platform.yatta.de
	at java.base/java.net.InetAddress$CachedAddresses.get(InetAddress.java:797)
	at java.base/java.net.InetAddress$NameServiceAddresses.get(InetAddress.java:883)
	at java.base/java.net.InetAddress.getAllByName0(InetAddress.java:1533)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1386)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1307)
	at org.apache.http.impl.conn.SystemDefaultDnsResolver.resolve(SystemDefaultDnsResolver.java:45)
	at org.apache.http.impl.conn.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:112)
	at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:374)
	at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:393)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:236)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)
	at org.apache.http.client.fluent.Request.internalExecute(Request.java:173)
	at org.apache.http.client.fluent.Executor.execute(Executor.java:262)
	at de.yatta.eclipse.launcher.communication.utils.RequestTemplate.execute(RequestTemplate.java:200)
	at de.yatta.platform.marketplace.licensing.client.LicensingClient$1.run(LicensingClient.java:500)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY de.yatta.platform.marketplace.licensing.client 2 0 2024-04-16 01:08:54.376
!MESSAGE Could not receive a valid response for solution feature de.yatta.feature.commandline from the license server.
!STACK 0
java.net.UnknownHostException: platform.yatta.de
	at java.base/java.net.InetAddress$CachedAddresses.get(InetAddress.java:797)
	at java.base/java.net.InetAddress$NameServiceAddresses.get(InetAddress.java:883)
	at java.base/java.net.InetAddress.getAllByName0(InetAddress.java:1533)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1386)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1307)
	at org.apache.http.impl.conn.SystemDefaultDnsResolver.resolve(SystemDefaultDnsResolver.java:45)
	at org.apache.http.impl.conn.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:112)
	at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:374)
	at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:393)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:236)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)
	at org.apache.http.client.fluent.Request.internalExecute(Request.java:173)
	at org.apache.http.client.fluent.Executor.execute(Executor.java:262)
	at de.yatta.eclipse.launcher.communication.utils.RequestTemplate.execute(RequestTemplate.java:200)
	at de.yatta.platform.marketplace.licensing.client.LicensingClient$1.run(LicensingClient.java:500)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY de.yatta.platform.marketplace.licensing.client 2 0 2024-04-16 01:08:54.376
!MESSAGE Could not receive a valid response for solution feature de.yatta.feature.emf from the license server.
!STACK 0
java.net.UnknownHostException: No such host is known (platform.yatta.de)
	at java.base/java.net.Inet6AddressImpl.lookupAllHostAddr(Native Method)
	at java.base/java.net.InetAddress$PlatformNameService.lookupAllHostAddr(InetAddress.java:930)
	at java.base/java.net.InetAddress.getAddressesFromNameService(InetAddress.java:1543)
	at java.base/java.net.InetAddress$NameServiceAddresses.get(InetAddress.java:848)
	at java.base/java.net.InetAddress.getAllByName0(InetAddress.java:1533)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1386)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1307)
	at org.apache.http.impl.conn.SystemDefaultDnsResolver.resolve(SystemDefaultDnsResolver.java:45)
	at org.apache.http.impl.conn.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:112)
	at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:374)
	at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:393)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:236)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)
	at org.apache.http.client.fluent.Request.internalExecute(Request.java:173)
	at org.apache.http.client.fluent.Executor.execute(Executor.java:262)
	at de.yatta.eclipse.launcher.communication.utils.RequestTemplate.execute(RequestTemplate.java:200)
	at de.yatta.platform.marketplace.licensing.client.LicensingClient$1.run(LicensingClient.java:500)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY de.yatta.platform.marketplace.licensing.client 2 0 2024-04-16 01:08:54.392
!MESSAGE Could not receive a valid response for solution feature de.yatta.feature.multiuser from the license server.
!STACK 0
java.net.UnknownHostException: platform.yatta.de
	at java.base/java.net.InetAddress$CachedAddresses.get(InetAddress.java:797)
	at java.base/java.net.InetAddress$NameServiceAddresses.get(InetAddress.java:883)
	at java.base/java.net.InetAddress.getAllByName0(InetAddress.java:1533)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1386)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1307)
	at org.apache.http.impl.conn.SystemDefaultDnsResolver.resolve(SystemDefaultDnsResolver.java:45)
	at org.apache.http.impl.conn.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:112)
	at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:374)
	at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:393)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:236)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)
	at org.apache.http.client.fluent.Request.internalExecute(Request.java:173)
	at org.apache.http.client.fluent.Executor.execute(Executor.java:262)
	at de.yatta.eclipse.launcher.communication.utils.RequestTemplate.execute(RequestTemplate.java:200)
	at de.yatta.platform.marketplace.licensing.client.LicensingClient$1.run(LicensingClient.java:500)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY de.yatta.platform.marketplace.licensing.client 2 0 2024-04-16 01:08:54.392
!MESSAGE Could not receive a valid response for solution feature de.yatta.feature.classdiagrams from the license server.
!STACK 0
java.net.UnknownHostException: platform.yatta.de
	at java.base/java.net.InetAddress$CachedAddresses.get(InetAddress.java:797)
	at java.base/java.net.InetAddress$NameServiceAddresses.get(InetAddress.java:883)
	at java.base/java.net.InetAddress.getAllByName0(InetAddress.java:1533)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1386)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1307)
	at org.apache.http.impl.conn.SystemDefaultDnsResolver.resolve(SystemDefaultDnsResolver.java:45)
	at org.apache.http.impl.conn.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:112)
	at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:374)
	at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:393)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:236)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)
	at org.apache.http.client.fluent.Request.internalExecute(Request.java:173)
	at org.apache.http.client.fluent.Executor.execute(Executor.java:262)
	at de.yatta.eclipse.launcher.communication.utils.RequestTemplate.execute(RequestTemplate.java:200)
	at de.yatta.platform.marketplace.licensing.client.LicensingClient$1.run(LicensingClient.java:500)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2024-04-16 01:50:28.986 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.20
java.vendor=Microsoft
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.ecf.provider.filetransfer.httpclient45.win32 4 0 2024-04-16 01:50:30.385
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.ecf.provider.filetransfer.httpclient45.win32 [116]
  Unresolved requirement: Import-Package: org.apache.http.impl.client; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="javax.net.ssl,org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.client.methods,org.apache.http.concurrent,org.apache.http.config,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.conn.socket,org.apache.http.conn.ssl,org.apache.http.conn.util,org.apache.http.cookie,org.apache.http.impl,org.apache.http.impl.auth,org.apache.http.impl.execchain,org.apache.http.message,org.apache.http.params,org.apache.http.pool,org.apache.http.protocol"
       org.apache.httpcomponents.httpclient [40]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
  Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.client.config; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client.config; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http"
  Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth.win; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.auth.win; bundle-symbolic-name="org.apache.httpcomponents.httpclient.win"; bundle-version="4.5.10.v20200113-2105"; version="4.5.10"; x-internal:="true"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.impl.auth,org.apache.http.protocol,org.apache.http.util"
       org.apache.httpcomponents.httpclient.win [41]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
         Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.conn.routing; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.conn.routing; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.epp.mpc.core.win32 4 0 2024-04-16 01:50:30.401
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.epp.mpc.core.win32 [135]
  Unresolved requirement: Import-Package: org.apache.http.impl.client; version="4.3.6"
    -> Export-Package: org.apache.http.impl.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="javax.net.ssl,org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.client.methods,org.apache.http.concurrent,org.apache.http.config,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.conn.socket,org.apache.http.conn.ssl,org.apache.http.conn.util,org.apache.http.cookie,org.apache.http.impl,org.apache.http.impl.auth,org.apache.http.impl.execchain,org.apache.http.message,org.apache.http.params,org.apache.http.pool,org.apache.http.protocol"
       org.apache.httpcomponents.httpclient [40]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth.win; version="4.3.6"
    -> Export-Package: org.apache.http.impl.auth.win; bundle-symbolic-name="org.apache.httpcomponents.httpclient.win"; bundle-version="4.5.10.v20200113-2105"; version="4.5.10"; x-internal:="true"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.impl.auth,org.apache.http.protocol,org.apache.http.util"
       org.apache.httpcomponents.httpclient.win [41]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
         Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.conn.routing; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.conn.routing; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.auth; version="4.3.6"
    -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.client; version="4.3.6"
    -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.client.config; version="4.3.6"
    -> Export-Package: org.apache.http.client.config; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="4.3.6"
    -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.commons.notifications.feed 4 0 2024-04-16 01:50:30.528
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.commons.notifications.feed [603]
  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.tasks.ui 4 0 2024-04-16 01:50:30.559
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.tasks.ui [620]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.0.0"
    -> Bundle-SymbolicName: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.18.0.v20190930-2131"; singleton:="true"
       org.eclipse.mylyn.commons.notifications.feed [603]
         No resolution report for the bundle.  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.trac.ui 4 0 2024-04-16 01:50:30.591
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.trac.ui [622]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.tasks.ui; bundle-version="[3.8.0,4.0.0)"
    -> Bundle-SymbolicName: org.eclipse.mylyn.tasks.ui; bundle-version="3.25.2.v20200814-0512"; singleton:="true"
       org.eclipse.mylyn.tasks.ui [620]
         Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.0.0"
           -> Bundle-SymbolicName: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.18.0.v20190930-2131"; singleton:="true"
              org.eclipse.mylyn.commons.notifications.feed [603]
                No resolution report for the bundle.  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.jface 2 0 2024-04-16 01:50:36.052
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-04-16 01:50:36.052
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1b5623b4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@8c34631,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-04-16 01:50:43.872
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Giannis'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.core.jobs 2 2 2024-04-16 01:57:30.501
!MESSAGE Job found still running after platform shutdown.  Jobs should be canceled by the plugin that scheduled them during shutdown: de.yatta.platform.marketplace.licensing.client.LicensingClient$1
!SESSION 2024-04-16 17:01:33.865 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.20
java.vendor=Microsoft
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.ecf.provider.filetransfer.httpclient45.win32 4 0 2024-04-16 17:01:37.091
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.ecf.provider.filetransfer.httpclient45.win32 [116]
  Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
       org.apache.httpcomponents.httpclient [40]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
  Unresolved requirement: Import-Package: org.apache.http.client.config; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client.config; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http"
  Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth.win; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.auth.win; bundle-symbolic-name="org.apache.httpcomponents.httpclient.win"; bundle-version="4.5.10.v20200113-2105"; version="4.5.10"; x-internal:="true"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.impl.auth,org.apache.http.protocol,org.apache.http.util"
       org.apache.httpcomponents.httpclient.win [41]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
         Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.conn.routing; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.conn.routing; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.impl.client; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="javax.net.ssl,org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.client.methods,org.apache.http.concurrent,org.apache.http.config,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.conn.socket,org.apache.http.conn.ssl,org.apache.http.conn.util,org.apache.http.cookie,org.apache.http.impl,org.apache.http.impl.auth,org.apache.http.impl.execchain,org.apache.http.message,org.apache.http.params,org.apache.http.pool,org.apache.http.protocol"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.epp.mpc.core.win32 4 0 2024-04-16 17:01:37.095
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.epp.mpc.core.win32 [135]
  Unresolved requirement: Import-Package: org.apache.http.impl.client; version="4.3.6"
    -> Export-Package: org.apache.http.impl.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="javax.net.ssl,org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.client.methods,org.apache.http.concurrent,org.apache.http.config,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.conn.socket,org.apache.http.conn.ssl,org.apache.http.conn.util,org.apache.http.cookie,org.apache.http.impl,org.apache.http.impl.auth,org.apache.http.impl.execchain,org.apache.http.message,org.apache.http.params,org.apache.http.pool,org.apache.http.protocol"
       org.apache.httpcomponents.httpclient [40]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
  Unresolved requirement: Import-Package: org.apache.http.auth; version="4.3.6"
    -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.client.config; version="4.3.6"
    -> Export-Package: org.apache.http.client.config; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth.win; version="4.3.6"
    -> Export-Package: org.apache.http.impl.auth.win; bundle-symbolic-name="org.apache.httpcomponents.httpclient.win"; bundle-version="4.5.10.v20200113-2105"; version="4.5.10"; x-internal:="true"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.impl.auth,org.apache.http.protocol,org.apache.http.util"
       org.apache.httpcomponents.httpclient.win [41]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
         Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.conn.routing; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.conn.routing; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="4.3.6"
    -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.client; version="4.3.6"
    -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.commons.notifications.feed 4 0 2024-04-16 17:01:38.397
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.commons.notifications.feed [603]
  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.tasks.ui 4 0 2024-04-16 17:01:38.437
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.tasks.ui [620]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.0.0"
    -> Bundle-SymbolicName: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.18.0.v20190930-2131"; singleton:="true"
       org.eclipse.mylyn.commons.notifications.feed [603]
         No resolution report for the bundle.  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.trac.ui 4 0 2024-04-16 17:01:38.469
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.trac.ui [622]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.tasks.ui; bundle-version="[3.8.0,4.0.0)"
    -> Bundle-SymbolicName: org.eclipse.mylyn.tasks.ui; bundle-version="3.25.2.v20200814-0512"; singleton:="true"
       org.eclipse.mylyn.tasks.ui [620]
         Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.0.0"
           -> Bundle-SymbolicName: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.18.0.v20190930-2131"; singleton:="true"
              org.eclipse.mylyn.commons.notifications.feed [603]
                No resolution report for the bundle.  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.jface 2 0 2024-04-16 17:09:29.030
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-04-16 17:09:29.030
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3c2188f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@646bf8a6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-04-16 17:09:36.137
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Giannis'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY de.yatta.platform.marketplace.licensing.client 2 0 2024-04-16 18:47:05.072
!MESSAGE Could not receive a valid response for solution feature de.yatta.feature.corediagrams from the license server.
!STACK 0
org.apache.http.NoHttpResponseException: platform.yatta.de:443 failed to respond
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:141)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:56)
	at org.apache.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:259)
	at org.apache.http.impl.DefaultBHttpClientConnection.receiveResponseHeader(DefaultBHttpClientConnection.java:163)
	at org.apache.http.impl.conn.CPoolProxy.receiveResponseHeader(CPoolProxy.java:157)
	at org.apache.http.protocol.HttpRequestExecutor.doReceiveResponse(HttpRequestExecutor.java:273)
	at de.yatta.eclipse.launcher.communication.utils.HttpRequestContext$RequestTemplateExecutor.doReceiveResponse(HttpRequestContext.java:707)
	at org.apache.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:125)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:272)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)
	at org.apache.http.client.fluent.Request.internalExecute(Request.java:173)
	at org.apache.http.client.fluent.Executor.execute(Executor.java:262)
	at de.yatta.eclipse.launcher.communication.utils.RequestTemplate.execute(RequestTemplate.java:200)
	at de.yatta.platform.marketplace.licensing.client.LicensingClient$1.run(LicensingClient.java:500)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY de.yatta.platform.marketplace.licensing.client 2 0 2024-04-16 18:50:13.377
!MESSAGE Could not receive a valid response for solution feature de.yatta.feature.corediagrams from the license server.
!STACK 0
org.apache.http.NoHttpResponseException: platform.yatta.de:443 failed to respond
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:141)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:56)
	at org.apache.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:259)
	at org.apache.http.impl.DefaultBHttpClientConnection.receiveResponseHeader(DefaultBHttpClientConnection.java:163)
	at org.apache.http.impl.conn.CPoolProxy.receiveResponseHeader(CPoolProxy.java:157)
	at org.apache.http.protocol.HttpRequestExecutor.doReceiveResponse(HttpRequestExecutor.java:273)
	at de.yatta.eclipse.launcher.communication.utils.HttpRequestContext$RequestTemplateExecutor.doReceiveResponse(HttpRequestContext.java:707)
	at org.apache.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:125)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:272)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)
	at org.apache.http.client.fluent.Request.internalExecute(Request.java:173)
	at org.apache.http.client.fluent.Executor.execute(Executor.java:262)
	at de.yatta.eclipse.launcher.communication.utils.RequestTemplate.execute(RequestTemplate.java:200)
	at de.yatta.platform.marketplace.licensing.client.LicensingClient$1.run(LicensingClient.java:500)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY de.yatta.platform.marketplace.licensing.client 2 0 2024-04-16 19:41:45.235
!MESSAGE Could not receive a valid response for solution feature de.yatta.feature.roundtrip from the license server.
!STACK 0
org.apache.http.NoHttpResponseException: platform.yatta.de:443 failed to respond
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:141)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:56)
	at org.apache.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:259)
	at org.apache.http.impl.DefaultBHttpClientConnection.receiveResponseHeader(DefaultBHttpClientConnection.java:163)
	at org.apache.http.impl.conn.CPoolProxy.receiveResponseHeader(CPoolProxy.java:157)
	at org.apache.http.protocol.HttpRequestExecutor.doReceiveResponse(HttpRequestExecutor.java:273)
	at de.yatta.eclipse.launcher.communication.utils.HttpRequestContext$RequestTemplateExecutor.doReceiveResponse(HttpRequestContext.java:707)
	at org.apache.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:125)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:272)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)
	at org.apache.http.client.fluent.Request.internalExecute(Request.java:173)
	at org.apache.http.client.fluent.Executor.execute(Executor.java:262)
	at de.yatta.eclipse.launcher.communication.utils.RequestTemplate.execute(RequestTemplate.java:200)
	at de.yatta.platform.marketplace.licensing.client.LicensingClient$1.run(LicensingClient.java:500)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY de.yatta.platform.marketplace.licensing.client 2 0 2024-04-16 20:28:13.826
!MESSAGE Could not receive a valid response for solution feature de.yatta.feature.emf from the license server.
!STACK 0
java.net.SocketException: Connection reset
	at java.base/java.net.SocketInputStream.read(SocketInputStream.java:186)
	at java.base/java.net.SocketInputStream.read(SocketInputStream.java:140)
	at java.base/sun.security.ssl.SSLSocketInputRecord.read(SSLSocketInputRecord.java:484)
	at java.base/sun.security.ssl.SSLSocketInputRecord.readHeader(SSLSocketInputRecord.java:478)
	at java.base/sun.security.ssl.SSLSocketInputRecord.bytesInCompletePacket(SSLSocketInputRecord.java:70)
	at java.base/sun.security.ssl.SSLSocketImpl.readApplicationRecord(SSLSocketImpl.java:1459)
	at java.base/sun.security.ssl.SSLSocketImpl$AppInputStream.read(SSLSocketImpl.java:1070)
	at org.apache.http.impl.io.SessionInputBufferImpl.streamRead(SessionInputBufferImpl.java:137)
	at org.apache.http.impl.io.SessionInputBufferImpl.fillBuffer(SessionInputBufferImpl.java:153)
	at org.apache.http.impl.io.SessionInputBufferImpl.readLine(SessionInputBufferImpl.java:280)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:138)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:56)
	at org.apache.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:259)
	at org.apache.http.impl.DefaultBHttpClientConnection.receiveResponseHeader(DefaultBHttpClientConnection.java:163)
	at org.apache.http.impl.conn.CPoolProxy.receiveResponseHeader(CPoolProxy.java:157)
	at org.apache.http.protocol.HttpRequestExecutor.doReceiveResponse(HttpRequestExecutor.java:273)
	at de.yatta.eclipse.launcher.communication.utils.HttpRequestContext$RequestTemplateExecutor.doReceiveResponse(HttpRequestContext.java:707)
	at org.apache.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:125)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:272)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)
	at org.apache.http.client.fluent.Request.internalExecute(Request.java:173)
	at org.apache.http.client.fluent.Executor.execute(Executor.java:262)
	at de.yatta.eclipse.launcher.communication.utils.RequestTemplate.execute(RequestTemplate.java:200)
	at de.yatta.platform.marketplace.licensing.client.LicensingClient$1.run(LicensingClient.java:500)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY de.yatta.platform.marketplace.licensing.client 2 0 2024-04-16 20:28:13.841
!MESSAGE Could not receive a valid response for solution feature de.yatta.feature.roundtrip from the license server.
!STACK 0
java.net.SocketException: Connection reset
	at java.base/java.net.SocketInputStream.read(SocketInputStream.java:186)
	at java.base/java.net.SocketInputStream.read(SocketInputStream.java:140)
	at java.base/sun.security.ssl.SSLSocketInputRecord.read(SSLSocketInputRecord.java:484)
	at java.base/sun.security.ssl.SSLSocketInputRecord.readHeader(SSLSocketInputRecord.java:478)
	at java.base/sun.security.ssl.SSLSocketInputRecord.bytesInCompletePacket(SSLSocketInputRecord.java:70)
	at java.base/sun.security.ssl.SSLSocketImpl.readApplicationRecord(SSLSocketImpl.java:1459)
	at java.base/sun.security.ssl.SSLSocketImpl$AppInputStream.read(SSLSocketImpl.java:1070)
	at org.apache.http.impl.io.SessionInputBufferImpl.streamRead(SessionInputBufferImpl.java:137)
	at org.apache.http.impl.io.SessionInputBufferImpl.fillBuffer(SessionInputBufferImpl.java:153)
	at org.apache.http.impl.io.SessionInputBufferImpl.readLine(SessionInputBufferImpl.java:280)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:138)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:56)
	at org.apache.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:259)
	at org.apache.http.impl.DefaultBHttpClientConnection.receiveResponseHeader(DefaultBHttpClientConnection.java:163)
	at org.apache.http.impl.conn.CPoolProxy.receiveResponseHeader(CPoolProxy.java:157)
	at org.apache.http.protocol.HttpRequestExecutor.doReceiveResponse(HttpRequestExecutor.java:273)
	at de.yatta.eclipse.launcher.communication.utils.HttpRequestContext$RequestTemplateExecutor.doReceiveResponse(HttpRequestContext.java:707)
	at org.apache.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:125)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:272)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)
	at org.apache.http.client.fluent.Request.internalExecute(Request.java:173)
	at org.apache.http.client.fluent.Executor.execute(Executor.java:262)
	at de.yatta.eclipse.launcher.communication.utils.RequestTemplate.execute(RequestTemplate.java:200)
	at de.yatta.platform.marketplace.licensing.client.LicensingClient$1.run(LicensingClient.java:500)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2024-04-17 02:40:22.938 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.20
java.vendor=Microsoft
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.ecf.provider.filetransfer.httpclient45.win32 4 0 2024-04-17 02:40:26.282
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.ecf.provider.filetransfer.httpclient45.win32 [116]
  Unresolved requirement: Import-Package: org.apache.http.client.config; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client.config; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http"
       org.apache.httpcomponents.httpclient [40]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth.win; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.auth.win; bundle-symbolic-name="org.apache.httpcomponents.httpclient.win"; bundle-version="4.5.10.v20200113-2105"; version="4.5.10"; x-internal:="true"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.impl.auth,org.apache.http.protocol,org.apache.http.util"
       org.apache.httpcomponents.httpclient.win [41]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
         Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.conn.routing; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.conn.routing; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.impl.client; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="javax.net.ssl,org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.client.methods,org.apache.http.concurrent,org.apache.http.config,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.conn.socket,org.apache.http.conn.ssl,org.apache.http.conn.util,org.apache.http.cookie,org.apache.http.impl,org.apache.http.impl.auth,org.apache.http.impl.execchain,org.apache.http.message,org.apache.http.params,org.apache.http.pool,org.apache.http.protocol"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.epp.mpc.core.win32 4 0 2024-04-17 02:40:26.290
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.epp.mpc.core.win32 [135]
  Unresolved requirement: Import-Package: org.apache.http.client.config; version="4.3.6"
    -> Export-Package: org.apache.http.client.config; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http"
       org.apache.httpcomponents.httpclient [40]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
  Unresolved requirement: Import-Package: org.apache.http.client; version="4.3.6"
    -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.impl.client; version="4.3.6"
    -> Export-Package: org.apache.http.impl.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="javax.net.ssl,org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.client.methods,org.apache.http.concurrent,org.apache.http.config,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.conn.socket,org.apache.http.conn.ssl,org.apache.http.conn.util,org.apache.http.cookie,org.apache.http.impl,org.apache.http.impl.auth,org.apache.http.impl.execchain,org.apache.http.message,org.apache.http.params,org.apache.http.pool,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.auth; version="4.3.6"
    -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth.win; version="4.3.6"
    -> Export-Package: org.apache.http.impl.auth.win; bundle-symbolic-name="org.apache.httpcomponents.httpclient.win"; bundle-version="4.5.10.v20200113-2105"; version="4.5.10"; x-internal:="true"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.impl.auth,org.apache.http.protocol,org.apache.http.util"
       org.apache.httpcomponents.httpclient.win [41]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
         Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.conn.routing; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.conn.routing; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="4.3.6"
    -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.commons.notifications.feed 4 0 2024-04-17 02:40:27.585
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.commons.notifications.feed [603]
  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.tasks.ui 4 0 2024-04-17 02:40:27.627
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.tasks.ui [620]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.0.0"
    -> Bundle-SymbolicName: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.18.0.v20190930-2131"; singleton:="true"
       org.eclipse.mylyn.commons.notifications.feed [603]
         No resolution report for the bundle.  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.trac.ui 4 0 2024-04-17 02:40:27.660
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.trac.ui [622]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.tasks.ui; bundle-version="[3.8.0,4.0.0)"
    -> Bundle-SymbolicName: org.eclipse.mylyn.tasks.ui; bundle-version="3.25.2.v20200814-0512"; singleton:="true"
       org.eclipse.mylyn.tasks.ui [620]
         Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.0.0"
           -> Bundle-SymbolicName: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.18.0.v20190930-2131"; singleton:="true"
              org.eclipse.mylyn.commons.notifications.feed [603]
                No resolution report for the bundle.  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.jface 2 0 2024-04-17 02:40:38.615
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-04-17 02:40:38.615
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3c2188f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@646bf8a6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-04-17 02:40:45.009
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Giannis'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY de.yatta.platform.marketplace.licensing.client 2 0 2024-04-17 02:40:52.198
!MESSAGE Could not receive a valid response for solution feature de.yatta.feature.commandline from the license server.
!STACK 0
org.apache.http.NoHttpResponseException: platform.yatta.de:443 failed to respond
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:141)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:56)
	at org.apache.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:259)
	at org.apache.http.impl.DefaultBHttpClientConnection.receiveResponseHeader(DefaultBHttpClientConnection.java:163)
	at org.apache.http.impl.conn.CPoolProxy.receiveResponseHeader(CPoolProxy.java:157)
	at org.apache.http.protocol.HttpRequestExecutor.doReceiveResponse(HttpRequestExecutor.java:273)
	at de.yatta.eclipse.launcher.communication.utils.HttpRequestContext$RequestTemplateExecutor.doReceiveResponse(HttpRequestContext.java:707)
	at org.apache.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:125)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:272)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)
	at org.apache.http.client.fluent.Request.internalExecute(Request.java:173)
	at org.apache.http.client.fluent.Executor.execute(Executor.java:262)
	at de.yatta.eclipse.launcher.communication.utils.RequestTemplate.execute(RequestTemplate.java:200)
	at de.yatta.platform.marketplace.licensing.client.LicensingClient$1.run(LicensingClient.java:500)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY de.yatta.platform.marketplace.licensing.client 2 0 2024-04-17 02:56:54.856
!MESSAGE Could not receive a valid response for solution feature de.yatta.feature.roundtrip from the license server.
!STACK 0
org.apache.http.NoHttpResponseException: platform.yatta.de:443 failed to respond
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:141)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:56)
	at org.apache.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:259)
	at org.apache.http.impl.DefaultBHttpClientConnection.receiveResponseHeader(DefaultBHttpClientConnection.java:163)
	at org.apache.http.impl.conn.CPoolProxy.receiveResponseHeader(CPoolProxy.java:157)
	at org.apache.http.protocol.HttpRequestExecutor.doReceiveResponse(HttpRequestExecutor.java:273)
	at de.yatta.eclipse.launcher.communication.utils.HttpRequestContext$RequestTemplateExecutor.doReceiveResponse(HttpRequestContext.java:707)
	at org.apache.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:125)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:272)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)
	at org.apache.http.client.fluent.Request.internalExecute(Request.java:173)
	at org.apache.http.client.fluent.Executor.execute(Executor.java:262)
	at de.yatta.eclipse.launcher.communication.utils.RequestTemplate.execute(RequestTemplate.java:200)
	at de.yatta.platform.marketplace.licensing.client.LicensingClient$1.run(LicensingClient.java:500)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2024-04-17 16:04:54.040 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.20
java.vendor=Microsoft
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.ecf.provider.filetransfer.httpclient45.win32 4 0 2024-04-17 16:04:56.893
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.ecf.provider.filetransfer.httpclient45.win32 [116]
  Unresolved requirement: Import-Package: org.apache.http.client.config; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client.config; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http"
       org.apache.httpcomponents.httpclient [40]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
  Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.impl.client; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="javax.net.ssl,org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.client.methods,org.apache.http.concurrent,org.apache.http.config,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.conn.socket,org.apache.http.conn.ssl,org.apache.http.conn.util,org.apache.http.cookie,org.apache.http.impl,org.apache.http.impl.auth,org.apache.http.impl.execchain,org.apache.http.message,org.apache.http.params,org.apache.http.pool,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth.win; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.auth.win; bundle-symbolic-name="org.apache.httpcomponents.httpclient.win"; bundle-version="4.5.10.v20200113-2105"; version="4.5.10"; x-internal:="true"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.impl.auth,org.apache.http.protocol,org.apache.http.util"
       org.apache.httpcomponents.httpclient.win [41]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
         Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.conn.routing; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.conn.routing; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.epp.mpc.core.win32 4 0 2024-04-17 16:04:56.897
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.epp.mpc.core.win32 [135]
  Unresolved requirement: Import-Package: org.apache.http.impl.auth.win; version="4.3.6"
    -> Export-Package: org.apache.http.impl.auth.win; bundle-symbolic-name="org.apache.httpcomponents.httpclient.win"; bundle-version="4.5.10.v20200113-2105"; version="4.5.10"; x-internal:="true"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.impl.auth,org.apache.http.protocol,org.apache.http.util"
       org.apache.httpcomponents.httpclient.win [41]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
         Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
              org.apache.httpcomponents.httpclient [40]
                Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
         Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.conn.routing; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.conn.routing; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.client.config; version="4.3.6"
    -> Export-Package: org.apache.http.client.config; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http"
  Unresolved requirement: Import-Package: org.apache.http.impl.client; version="4.3.6"
    -> Export-Package: org.apache.http.impl.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="javax.net.ssl,org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.client.methods,org.apache.http.concurrent,org.apache.http.config,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.conn.socket,org.apache.http.conn.ssl,org.apache.http.conn.util,org.apache.http.cookie,org.apache.http.impl,org.apache.http.impl.auth,org.apache.http.impl.execchain,org.apache.http.message,org.apache.http.params,org.apache.http.pool,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.client; version="4.3.6"
    -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="4.3.6"
    -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.auth; version="4.3.6"
    -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.commons.notifications.feed 4 0 2024-04-17 16:04:58.247
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.commons.notifications.feed [603]
  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.tasks.ui 4 0 2024-04-17 16:04:58.285
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.tasks.ui [620]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.0.0"
    -> Bundle-SymbolicName: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.18.0.v20190930-2131"; singleton:="true"
       org.eclipse.mylyn.commons.notifications.feed [603]
         No resolution report for the bundle.  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.trac.ui 4 0 2024-04-17 16:04:58.314
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.trac.ui [622]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.tasks.ui; bundle-version="[3.8.0,4.0.0)"
    -> Bundle-SymbolicName: org.eclipse.mylyn.tasks.ui; bundle-version="3.25.2.v20200814-0512"; singleton:="true"
       org.eclipse.mylyn.tasks.ui [620]
         Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.0.0"
           -> Bundle-SymbolicName: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.18.0.v20190930-2131"; singleton:="true"
              org.eclipse.mylyn.commons.notifications.feed [603]
                No resolution report for the bundle.  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.jface 2 0 2024-04-17 16:05:08.794
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-04-17 16:05:08.794
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3c2188f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@646bf8a6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-04-17 16:05:16.146
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Giannis'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2024-04-19 11:40:54.858 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.20
java.vendor=Microsoft
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.ecf.provider.filetransfer.httpclient45.win32 4 0 2024-04-19 11:40:55.857
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.ecf.provider.filetransfer.httpclient45.win32 [116]
  Unresolved requirement: Import-Package: org.apache.http.client.config; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client.config; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http"
       org.apache.httpcomponents.httpclient [40]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
  Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth.win; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.auth.win; bundle-symbolic-name="org.apache.httpcomponents.httpclient.win"; bundle-version="4.5.10.v20200113-2105"; version="4.5.10"; x-internal:="true"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.impl.auth,org.apache.http.protocol,org.apache.http.util"
       org.apache.httpcomponents.httpclient.win [41]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
         Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.conn.routing; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.conn.routing; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.impl.client; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="javax.net.ssl,org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.client.methods,org.apache.http.concurrent,org.apache.http.config,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.conn.socket,org.apache.http.conn.ssl,org.apache.http.conn.util,org.apache.http.cookie,org.apache.http.impl,org.apache.http.impl.auth,org.apache.http.impl.execchain,org.apache.http.message,org.apache.http.params,org.apache.http.pool,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.epp.mpc.core.win32 4 0 2024-04-19 11:40:55.862
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.epp.mpc.core.win32 [135]
  Unresolved requirement: Import-Package: org.apache.http.client.config; version="4.3.6"
    -> Export-Package: org.apache.http.client.config; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http"
       org.apache.httpcomponents.httpclient [40]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="4.3.6"
    -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.client; version="4.3.6"
    -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.impl.client; version="4.3.6"
    -> Export-Package: org.apache.http.impl.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="javax.net.ssl,org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.client.methods,org.apache.http.concurrent,org.apache.http.config,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.conn.socket,org.apache.http.conn.ssl,org.apache.http.conn.util,org.apache.http.cookie,org.apache.http.impl,org.apache.http.impl.auth,org.apache.http.impl.execchain,org.apache.http.message,org.apache.http.params,org.apache.http.pool,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.auth; version="4.3.6"
    -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth.win; version="4.3.6"
    -> Export-Package: org.apache.http.impl.auth.win; bundle-symbolic-name="org.apache.httpcomponents.httpclient.win"; bundle-version="4.5.10.v20200113-2105"; version="4.5.10"; x-internal:="true"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.impl.auth,org.apache.http.protocol,org.apache.http.util"
       org.apache.httpcomponents.httpclient.win [41]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
         Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.conn.routing; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.conn.routing; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.commons.notifications.feed 4 0 2024-04-19 11:40:55.953
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.commons.notifications.feed [603]
  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.tasks.ui 4 0 2024-04-19 11:40:55.980
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.tasks.ui [620]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.0.0"
    -> Bundle-SymbolicName: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.18.0.v20190930-2131"; singleton:="true"
       org.eclipse.mylyn.commons.notifications.feed [603]
         No resolution report for the bundle.  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.trac.ui 4 0 2024-04-19 11:40:56.015
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.trac.ui [622]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.tasks.ui; bundle-version="[3.8.0,4.0.0)"
    -> Bundle-SymbolicName: org.eclipse.mylyn.tasks.ui; bundle-version="3.25.2.v20200814-0512"; singleton:="true"
       org.eclipse.mylyn.tasks.ui [620]
         Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.0.0"
           -> Bundle-SymbolicName: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.18.0.v20190930-2131"; singleton:="true"
              org.eclipse.mylyn.commons.notifications.feed [603]
                No resolution report for the bundle.  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.jface 2 0 2024-04-19 11:41:06.996
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-04-19 11:41:06.996
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3aa63b53,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@39a9becc,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-04-19 11:41:12.781
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Giannis'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2024-04-30 14:08:26.998 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.20
java.vendor=Microsoft
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.ecf.provider.filetransfer.httpclient45.win32 4 0 2024-04-30 14:08:29.945
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.ecf.provider.filetransfer.httpclient45.win32 [116]
  Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
       org.apache.httpcomponents.httpclient [40]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth.win; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.auth.win; bundle-symbolic-name="org.apache.httpcomponents.httpclient.win"; bundle-version="4.5.10.v20200113-2105"; version="4.5.10"; x-internal:="true"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.impl.auth,org.apache.http.protocol,org.apache.http.util"
       org.apache.httpcomponents.httpclient.win [41]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
         Unresolved requirement: Import-Package: org.apache.http.conn.routing; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.conn.routing; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.client.config; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client.config; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http"
  Unresolved requirement: Import-Package: org.apache.http.impl.client; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="javax.net.ssl,org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.client.methods,org.apache.http.concurrent,org.apache.http.config,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.conn.socket,org.apache.http.conn.ssl,org.apache.http.conn.util,org.apache.http.cookie,org.apache.http.impl,org.apache.http.impl.auth,org.apache.http.impl.execchain,org.apache.http.message,org.apache.http.params,org.apache.http.pool,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.epp.mpc.core.win32 4 0 2024-04-30 14:08:29.949
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.epp.mpc.core.win32 [135]
  Unresolved requirement: Import-Package: org.apache.http.client.config; version="4.3.6"
    -> Export-Package: org.apache.http.client.config; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http"
       org.apache.httpcomponents.httpclient [40]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="4.3.6"
    -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.impl.client; version="4.3.6"
    -> Export-Package: org.apache.http.impl.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="javax.net.ssl,org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.client.methods,org.apache.http.concurrent,org.apache.http.config,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.conn.socket,org.apache.http.conn.ssl,org.apache.http.conn.util,org.apache.http.cookie,org.apache.http.impl,org.apache.http.impl.auth,org.apache.http.impl.execchain,org.apache.http.message,org.apache.http.params,org.apache.http.pool,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.auth; version="4.3.6"
    -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth.win; version="4.3.6"
    -> Export-Package: org.apache.http.impl.auth.win; bundle-symbolic-name="org.apache.httpcomponents.httpclient.win"; bundle-version="4.5.10.v20200113-2105"; version="4.5.10"; x-internal:="true"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.impl.auth,org.apache.http.protocol,org.apache.http.util"
       org.apache.httpcomponents.httpclient.win [41]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
         Unresolved requirement: Import-Package: org.apache.http.conn.routing; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.conn.routing; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.client; version="4.3.6"
    -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.commons.notifications.feed 4 0 2024-04-30 14:08:31.467
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.commons.notifications.feed [603]
  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.tasks.ui 4 0 2024-04-30 14:08:31.511
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.tasks.ui [620]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.0.0"
    -> Bundle-SymbolicName: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.18.0.v20190930-2131"; singleton:="true"
       org.eclipse.mylyn.commons.notifications.feed [603]
         No resolution report for the bundle.  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.trac.ui 4 0 2024-04-30 14:08:31.550
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.trac.ui [622]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.tasks.ui; bundle-version="[3.8.0,4.0.0)"
    -> Bundle-SymbolicName: org.eclipse.mylyn.tasks.ui; bundle-version="3.25.2.v20200814-0512"; singleton:="true"
       org.eclipse.mylyn.tasks.ui [620]
         Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.0.0"
           -> Bundle-SymbolicName: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.18.0.v20190930-2131"; singleton:="true"
              org.eclipse.mylyn.commons.notifications.feed [603]
                No resolution report for the bundle.  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.jface 2 0 2024-04-30 14:09:09.072
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-04-30 14:09:09.072
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3516f436,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@59c00010,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-04-30 14:09:21.413
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Giannis'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY de.yatta.platform.marketplace.licensing.client 2 0 2024-04-30 15:11:40.744
!MESSAGE Could not receive a valid response for solution feature de.yatta.feature.roundtrip from the license server.
!STACK 0
java.net.SocketTimeoutException: Read timed out
	at java.base/java.net.SocketInputStream.socketRead0(Native Method)
	at java.base/java.net.SocketInputStream.socketRead(SocketInputStream.java:115)
	at java.base/java.net.SocketInputStream.read(SocketInputStream.java:168)
	at java.base/java.net.SocketInputStream.read(SocketInputStream.java:140)
	at java.base/sun.security.ssl.SSLSocketInputRecord.read(SSLSocketInputRecord.java:484)
	at java.base/sun.security.ssl.SSLSocketInputRecord.readHeader(SSLSocketInputRecord.java:478)
	at java.base/sun.security.ssl.SSLSocketInputRecord.bytesInCompletePacket(SSLSocketInputRecord.java:70)
	at java.base/sun.security.ssl.SSLSocketImpl.readApplicationRecord(SSLSocketImpl.java:1459)
	at java.base/sun.security.ssl.SSLSocketImpl$AppInputStream.read(SSLSocketImpl.java:1070)
	at org.apache.http.impl.conn.LoggingInputStream.read(LoggingInputStream.java:84)
	at org.apache.http.impl.io.SessionInputBufferImpl.streamRead(SessionInputBufferImpl.java:137)
	at org.apache.http.impl.io.SessionInputBufferImpl.fillBuffer(SessionInputBufferImpl.java:153)
	at org.apache.http.impl.io.SessionInputBufferImpl.readLine(SessionInputBufferImpl.java:280)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:138)
	at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:56)
	at org.apache.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:259)
	at org.apache.http.impl.DefaultBHttpClientConnection.receiveResponseHeader(DefaultBHttpClientConnection.java:163)
	at org.apache.http.impl.conn.CPoolProxy.receiveResponseHeader(CPoolProxy.java:157)
	at org.apache.http.protocol.HttpRequestExecutor.doReceiveResponse(HttpRequestExecutor.java:273)
	at de.yatta.eclipse.launcher.communication.utils.HttpRequestContext$RequestTemplateExecutor.doReceiveResponse(HttpRequestContext.java:707)
	at org.apache.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:125)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:272)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)
	at org.apache.http.client.fluent.Request.internalExecute(Request.java:173)
	at org.apache.http.client.fluent.Executor.execute(Executor.java:262)
	at de.yatta.eclipse.launcher.communication.utils.RequestTemplate.execute(RequestTemplate.java:200)
	at de.yatta.platform.marketplace.licensing.client.LicensingClient$1.run(LicensingClient.java:500)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2024-06-03 18:33:27.302 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.20
java.vendor=Microsoft
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.ecf.provider.filetransfer.httpclient45.win32 4 0 2024-06-03 18:33:28.575
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.ecf.provider.filetransfer.httpclient45.win32 [116]
  Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
       org.apache.httpcomponents.httpclient [40]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
  Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.impl.client; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="javax.net.ssl,org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.client.methods,org.apache.http.concurrent,org.apache.http.config,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.conn.socket,org.apache.http.conn.ssl,org.apache.http.conn.util,org.apache.http.cookie,org.apache.http.impl,org.apache.http.impl.auth,org.apache.http.impl.execchain,org.apache.http.message,org.apache.http.params,org.apache.http.pool,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.client.config; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client.config; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth.win; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.auth.win; bundle-symbolic-name="org.apache.httpcomponents.httpclient.win"; bundle-version="4.5.10.v20200113-2105"; version="4.5.10"; x-internal:="true"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.impl.auth,org.apache.http.protocol,org.apache.http.util"
       org.apache.httpcomponents.httpclient.win [41]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
         Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.conn.routing; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.conn.routing; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.epp.mpc.core.win32 4 0 2024-06-03 18:33:28.583
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.epp.mpc.core.win32 [135]
  Unresolved requirement: Import-Package: org.apache.http.auth; version="4.3.6"
    -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
       org.apache.httpcomponents.httpclient [40]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
  Unresolved requirement: Import-Package: org.apache.http.impl.client; version="4.3.6"
    -> Export-Package: org.apache.http.impl.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="javax.net.ssl,org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.client.methods,org.apache.http.concurrent,org.apache.http.config,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.conn.socket,org.apache.http.conn.ssl,org.apache.http.conn.util,org.apache.http.cookie,org.apache.http.impl,org.apache.http.impl.auth,org.apache.http.impl.execchain,org.apache.http.message,org.apache.http.params,org.apache.http.pool,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.client; version="4.3.6"
    -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth.win; version="4.3.6"
    -> Export-Package: org.apache.http.impl.auth.win; bundle-symbolic-name="org.apache.httpcomponents.httpclient.win"; bundle-version="4.5.10.v20200113-2105"; version="4.5.10"; x-internal:="true"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.impl.auth,org.apache.http.protocol,org.apache.http.util"
       org.apache.httpcomponents.httpclient.win [41]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
         Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.conn.routing; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.conn.routing; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="4.3.6"
    -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.client.config; version="4.3.6"
    -> Export-Package: org.apache.http.client.config; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.commons.notifications.feed 4 0 2024-06-03 18:33:28.712
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.commons.notifications.feed [603]
  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.tasks.ui 4 0 2024-06-03 18:33:28.756
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.tasks.ui [620]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.0.0"
    -> Bundle-SymbolicName: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.18.0.v20190930-2131"; singleton:="true"
       org.eclipse.mylyn.commons.notifications.feed [603]
         No resolution report for the bundle.  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.trac.ui 4 0 2024-06-03 18:33:28.792
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.trac.ui [622]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.tasks.ui; bundle-version="[3.8.0,4.0.0)"
    -> Bundle-SymbolicName: org.eclipse.mylyn.tasks.ui; bundle-version="3.25.2.v20200814-0512"; singleton:="true"
       org.eclipse.mylyn.tasks.ui [620]
         Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.0.0"
           -> Bundle-SymbolicName: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.18.0.v20190930-2131"; singleton:="true"
              org.eclipse.mylyn.commons.notifications.feed [603]
                No resolution report for the bundle.  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.core.resources 2 10035 2024-06-03 18:36:53.018
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2024-06-03 18:36:55.625
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-06-03 18:36:55.625
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@66e62fc4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7e28f150,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-06-03 18:37:04.865
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Giannis'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2024-06-04 21:55:52.596 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=11.0.20
java.vendor=Microsoft
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.ecf.provider.filetransfer.httpclient45.win32 4 0 2024-06-04 21:55:55.448
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.ecf.provider.filetransfer.httpclient45.win32 [116]
  Unresolved requirement: Import-Package: org.apache.http.impl.client; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="javax.net.ssl,org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.client.methods,org.apache.http.concurrent,org.apache.http.config,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.conn.socket,org.apache.http.conn.ssl,org.apache.http.conn.util,org.apache.http.cookie,org.apache.http.impl,org.apache.http.impl.auth,org.apache.http.impl.execchain,org.apache.http.message,org.apache.http.params,org.apache.http.pool,org.apache.http.protocol"
       org.apache.httpcomponents.httpclient [40]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
  Unresolved requirement: Import-Package: org.apache.http.client.config; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client.config; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth.win; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.impl.auth.win; bundle-symbolic-name="org.apache.httpcomponents.httpclient.win"; bundle-version="4.5.10.v20200113-2105"; version="4.5.10"; x-internal:="true"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.impl.auth,org.apache.http.protocol,org.apache.http.util"
       org.apache.httpcomponents.httpclient.win [41]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
         Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.conn.routing; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.conn.routing; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
  Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.0,5.0.0)"
    -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.epp.mpc.core.win32 4 0 2024-06-04 21:55:55.453
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.epp.mpc.core.win32 [135]
  Unresolved requirement: Import-Package: org.apache.http.client; version="4.3.6"
    -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
       org.apache.httpcomponents.httpclient [40]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
  Unresolved requirement: Import-Package: org.apache.http.client.config; version="4.3.6"
    -> Export-Package: org.apache.http.client.config; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http"
  Unresolved requirement: Import-Package: org.apache.http.auth; version="4.3.6"
    -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="4.3.6"
    -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.impl.auth.win; version="4.3.6"
    -> Export-Package: org.apache.http.impl.auth.win; bundle-symbolic-name="org.apache.httpcomponents.httpclient.win"; bundle-version="4.5.10.v20200113-2105"; version="4.5.10"; x-internal:="true"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.impl.auth,org.apache.http.protocol,org.apache.http.util"
       org.apache.httpcomponents.httpclient.win [41]
         Unresolved requirement: Import-Package: org.apache.commons.codec.binary; version="[1.13.0,1.14.0)"
         Unresolved requirement: Import-Package: org.apache.http.client.protocol; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client.protocol; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.config,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.config,org.apache.http.params,org.apache.http.protocol,org.ietf.jgss"
         Unresolved requirement: Import-Package: org.apache.http.conn.routing; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.conn.routing; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.client; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.http,org.apache.http.auth,org.apache.http.client.methods,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.cookie,org.apache.http.params,org.apache.http.protocol"
         Unresolved requirement: Import-Package: org.apache.http.impl.auth; version="[4.5.10,4.6.0)"
           -> Export-Package: org.apache.http.impl.auth; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.params,org.apache.http.protocol,org.apache.http.util,org.ietf.jgss"
  Unresolved requirement: Import-Package: org.apache.http.impl.client; version="4.3.6"
    -> Export-Package: org.apache.http.impl.client; bundle-symbolic-name="org.apache.httpcomponents.httpclient"; bundle-version="4.5.10.v20200114-1512"; version="4.5.10"; uses:="javax.net.ssl,org.apache.commons.logging,org.apache.http,org.apache.http.auth,org.apache.http.client,org.apache.http.client.config,org.apache.http.client.entity,org.apache.http.client.methods,org.apache.http.concurrent,org.apache.http.config,org.apache.http.conn,org.apache.http.conn.routing,org.apache.http.conn.socket,org.apache.http.conn.ssl,org.apache.http.conn.util,org.apache.http.cookie,org.apache.http.impl,org.apache.http.impl.auth,org.apache.http.impl.execchain,org.apache.http.message,org.apache.http.params,org.apache.http.pool,org.apache.http.protocol"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.commons.notifications.feed 4 0 2024-06-04 21:55:56.851
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.commons.notifications.feed [603]
  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.tasks.ui 4 0 2024-06-04 21:55:56.886
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.tasks.ui [620]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.0.0"
    -> Bundle-SymbolicName: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.18.0.v20190930-2131"; singleton:="true"
       org.eclipse.mylyn.commons.notifications.feed [603]
         No resolution report for the bundle.  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.trac.ui 4 0 2024-06-04 21:55:56.916
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.mylyn.trac.ui [622]
  Unresolved requirement: Require-Bundle: org.eclipse.mylyn.tasks.ui; bundle-version="[3.8.0,4.0.0)"
    -> Bundle-SymbolicName: org.eclipse.mylyn.tasks.ui; bundle-version="3.25.2.v20200814-0512"; singleton:="true"
       org.eclipse.mylyn.tasks.ui [620]
         Unresolved requirement: Require-Bundle: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.0.0"
           -> Bundle-SymbolicName: org.eclipse.mylyn.commons.notifications.feed; bundle-version="1.18.0.v20190930-2131"; singleton:="true"
              org.eclipse.mylyn.commons.notifications.feed [603]
                No resolution report for the bundle.  Bundle was not resolved because of a uses constraint violation.
  org.apache.felix.resolver.reason.ReasonException: Uses constraint violation. Unable to resolve resource org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"] because it is exposed to package 'javax.xml.bind' from resources javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"] and jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"] via two dependency chains.

Chain 1:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=javax.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle: javax.xml.bind
  javax.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.2.0.v201105210648"; osgi.identity="javax.xml.bind"]

Chain 2:
  org.eclipse.mylyn.commons.notifications.feed [osgi.identity; type="osgi.bundle"; version:Version="1.18.0.v20190930-2131"; osgi.identity="org.eclipse.mylyn.commons.notifications.feed"; singleton:="true"]
    require: (&(osgi.wiring.bundle=com.sun.xml.bind)(bundle-version>=2.2.0))
     |
    provide: osgi.wiring.bundle; bundle-version:Version="2.3.3.v20201118-1818"; osgi.wiring.bundle="com.sun.xml.bind"
  com.sun.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="com.sun.xml.bind"]
    import: (&(osgi.wiring.package=javax.xml.bind)(&(version>=2.3.3)(!(version>=2.3.4))))
     |
    export: osgi.wiring.package: javax.xml.bind
  jakarta.xml.bind [osgi.identity; type="osgi.bundle"; version:Version="2.3.3.v20201118-1818"; osgi.identity="jakarta.xml.bind"]
	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1845)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1838)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1779)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1743)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1665)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)
